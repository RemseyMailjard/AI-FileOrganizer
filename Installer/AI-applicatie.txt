Directory structure:
└── remseymailjard-ai-fileorganizer2/
    ├── README.md
    ├── AI-FileOrganizer2.csproj
    ├── AI-FileOrganizer2.sln
    ├── AIFileOrganizerLinkedIn.zip
    ├── App.config
    ├── appsettings.json
    ├── Form1.cs
    ├── Form1.Designer.cs
    ├── Form1.resx
    ├── FormRenameFile.cs
    ├── FormRenameFile.Designer.cs
    ├── FormRenameFile.resx
    ├── packages.config
    ├── Program.cs
    ├── README_AI_File_Organizer.md
    ├── Models/
    │   └── ApplicationSettings.cs
    ├── Properties/
    │   ├── AssemblyInfo.cs
    │   ├── Resources.Designer.cs
    │   ├── Resources.resx
    │   ├── Settings.Designer.cs
    │   └── Settings.settings
    ├── Services/
    │   ├── AiClassificationService.cs
    │   ├── AzureOpenAiProvider.cs
    │   ├── CredentialStorageService.cs
    │   ├── DocxTextExtractor.cs
    │   ├── FileOrganizerService.cs
    │   ├── GeminiAiProvider.cs
    │   ├── IaProvider.cs
    │   ├── ITextExtractor.cs
    │   ├── OpenAiProvider.cs
    │   ├── PdfTextExtractor.cs
    │   ├── PlainTextExtractor.cs
    │   └── TextExtractionService.cs
    └── Utils/
        ├── FileLogger.cs
        ├── FileUtil.cs
        ├── ILogger.cs
        └── UiLogger.cs


Files Content:

================================================
FILE: README.md
================================================
﻿# AI File Organizer

![AI File Organizer Screenshot (voorbeeld - plaats hier een screenshot van je applicatie)](https://via.placeholder.com/800x450?text=Plaats+hier+een+screenshot+van+de+UI)

Dit project is een Windows Forms-applicatie (.NET Framework 4.8) die is ontworpen om uw digitale documenten automatisch te organiseren met behulp van kunstmatige intelligentie. Het analyseert de inhoud van uw bestanden (PDF, DOCX, TXT, MD) en verplaatst ze naar vooraf gedefinieerde, logische categoriefolders, inclusief de mogelijkheid om AI-gegenereerde submappen en bestandsnamen voor te stellen.

## Inhoudsopgave

*   [Functies](#functies)
*   [Vereisten](#vereisten)
*   [Installatie](#installatie)
*   [API-sleutel instellen](#api-sleutel-instellen)
    *   [Google Gemini API-sleutel](#google-gemini-api-sleutel)
    *   [OpenAI API-sleutel](#openai-api-sleutel)
    *   [Azure OpenAI API-sleutel](#azure-openai-api-sleutel)
*   [Gebruik](#gebruik)
    *   [Stap 1: Applicatie starten](#stap-1-applicatie-starten)
    *   [Stap 2: API-provider en -model selecteren](#stap-2-api-provider-en--model-selecteren)
    *   [Stap 3: Mappen configureren](#stap-3-mappen-configureren)
    *   [Stap 4: Bestanden hernoemen (optioneel)](#stap-4-bestanden-hernoemen-optioneel)
    *   [Stap 5: Organisatie starten](#stap-5-organisatie-starten)
    *   [Stap 6: Voortgang en logboek](#stap-6-voortgang-en-logboek)
*   [Ondersteunde bestandstypen](#ondersteunde-bestandstypen)
*   [Voorgedefinieerde mapcategorieën](#voorgedefinieerde-mapcategorieën)
*   [Projectstructuur](#projectstructuur)
*   [Credits](#credits)

## Functies

*   **AI-gestuurde classificatie**: Automatische categorisatie van documenten in vooraf gedefinieerde mappen.
*   **Intelligente submap-suggesties**: De AI stelt beschrijvende submapnamen voor op basis van de inhoud.
*   **AI-gegenereerde bestandsnamen**: Mogelijkheid om bestandsnamen te hernoemen met AI-suggesties (met gebruikersbevestiging).
*   **Ondersteuning voor meerdere AI-providers**: Kies tussen Google Gemini, OpenAI (via openai.com) en Azure OpenAI.
*   **Robuuste tekstextractie**: Extraheert tekst uit PDF-, DOCX-, TXT- en MD-bestanden, inclusief verbeterde lay-outanalyse voor PDF's.
*   **Moderne UI-dialoogvensters**: Gebruikt moderne Windows-dialoogvensters voor map- en bestandsselectie/opslaan.
*   **Uitgebreide logging**: Gedetailleerde logboeken van het organisatieproces, direct zichtbaar in de UI en opslaanbaar naar een bestand.
*   **Annulering van processen**: Mogelijkheid om een lopend organisatieproces te stoppen.

## Vereisten

*   **Besturingssysteem**: Windows 10 of nieuwer.
*   **.NET Framework**: .NET Framework 4.8 Runtime geïnstalleerd.
*   **Internetverbinding**: Vereist voor communicatie met de AI-API's.
*   **API-sleutel**: Een geldige API-sleutel voor de gekozen AI-provider (Google Gemini, OpenAI of Azure OpenAI). Zie [API-sleutel instellen](#api-sleutel-instellen) voor instructies.

## Installatie

Dit project is een Visual Studio-oplossing. Volg deze stappen om het te installeren en te draaien:

1.  **Kloon de repository**:
    ```bash
    git clone https://github.com/remseymailjard/remseymailjard-ai-fileorganizer2.git
    cd remseymailjard-ai-fileorganizer2
    ```
2.  **Open in Visual Studio**: Open het `AI-FileOrganizer2.sln` bestand in Visual Studio (Visual Studio 2019 of nieuwer wordt aanbevolen voor .NET Framework 4.8 projecten).
3.  **Herstel NuGet-pakketten**: Visual Studio zou automatisch de benodigde NuGet-pakketten moeten herstellen bij het openen van de oplossing. Als dit niet gebeurt, klik dan met de rechtermuisknop op de oplossing in Solution Explorer en kies "Restore NuGet Packages".
    *   **Belangrijke NuGet-pakketten**: Dit project maakt gebruik van:
        *   `PdfPig` (voor PDF-extractie)
        *   `DocumentFormat.OpenXml` (voor DOCX-extractie)
        *   `Microsoft.WindowsAPICodePack.Shell` en `Microsoft.WindowsAPICodePack.Core` (voor moderne dialoogvensters)
        *   `Google.GenerativeAI` (voor Gemini API)
        *   `OpenAI` (voor OpenAI API)
        *   `Azure.AI.OpenAI` (voor Azure OpenAI API)
        *   `Newtonsoft.Json` (voor JSON-serialisatie/deserialisatie)
4.  **Bouw de oplossing**: Klik in Visual Studio op "Build" > "Build Solution" (of druk op `F6`).
5.  **Start de applicatie**: Nadat de build is voltooid, kunt u de applicatie starten door op `F5` te drukken of door te navigeren naar de `bin\Debug` (of `bin\Release`) map in uw projectdirectory en `AI-FileOrganizer2.exe` uit te voeren.

## API-sleutel instellen

U hebt een API-sleutel nodig van de door u gekozen AI-provider om de applicatie te kunnen gebruiken. De applicatie ondersteunt Google Gemini, OpenAI en Azure OpenAI.

**Beveiligingstip**: Bewaar uw API-sleutels altijd veilig en deel ze nooit met anderen.

### Google Gemini API-sleutel

1.  **Ga naar Google AI Studio**: Open uw webbrowser en ga naar [https://aistudio.google.com/](https://aistudio.google.com/).
2.  **Log in**: Log in met uw Google-account.
3.  **Navigeer naar API-sleutels**: Klik in het linkernavigatiemenu op "Get API key" (of "API keys" als u er al een heeft).
4.  **Maak een nieuwe API-sleutel aan**: Klik op "Create API key in new project" of "Create API key".
5.  **Kopieer de sleutel**: Kopieer de gegenereerde API-sleutel en plak deze in het `Google API Key:` veld in de applicatie.

### OpenAI API-sleutel

1.  **Ga naar het OpenAI-platform**: Open uw webbrowser en ga naar [https://platform.openai.com/](https://platform.openai.com/).
2.  **Log in**: Log in met uw OpenAI-account.
3.  **Navigeer naar API-sleutels**: Klik op uw profielpictogram (rechtsboven) en selecteer "View API keys".
4.  **Maak een nieuwe sleutel aan**: Klik op "Create new secret key". Geef de sleutel eventueel een naam voor herkenbaarheid.
5.  **Kopieer de sleutel**: Kopieer de **geheime** sleutel die wordt weergegeven. Deze wordt slechts één keer getoond. Plak deze in het `OpenAI API Key:` veld in de applicatie.

### Azure OpenAI API-sleutel

Azure OpenAI vereist een Azure-abonnement en de implementatie van een OpenAI-model in uw Azure-resource.

1.  **Meld u aan bij Azure Portal**: Ga naar [https://portal.azure.com/](https://portal.azure.com/) en log in.
2.  **Maak een Azure OpenAI Service-resource aan**:
    *   Zoek in de zoekbalk naar "Azure OpenAI".
    *   Klik op "Create Azure OpenAI".
    *   Volg de stappen om een nieuwe resource te maken (kies een abonnement, resourcegroep, regio en naam).
    *   Zorg ervoor dat u aanvraagt voor toegang tot de Azure OpenAI service, aangezien deze beperkt is.
3.  **Implementeer een model**:
    *   Navigeer naar uw zojuist gemaakte Azure OpenAI resource.
    *   Klik in het linkernavigatiemenu onder "Resource Management" op "Model deployments".
    *   Klik op "Manage deployments" om naar Azure OpenAI Studio te gaan.
    *   Klik in Azure OpenAI Studio op "Deployments" > "Create new deployment".
    *   Kies een model (bijv. `gpt-4o`, `gpt-35-turbo`) en geef het een "Deployment name" (bijv. `my-gpt4o-deployment`). Dit is de naam die u in de applicatie als "Model" selecteert.
4.  **Verzamel de API-sleutel en Endpoint**:
    *   Ga terug naar uw Azure OpenAI resource in Azure Portal.
    *   Klik in het linkernavigatiemenu onder "Resource Management" op "Keys and Endpoint".
    *   U ziet hier twee sleutels (KEY 1, KEY 2) en een Endpoint.
    *   **Kopieer één van de sleutels** (bijv. KEY 1) en plak deze in het `Azure OpenAI API Key:` veld in de applicatie.
    *   **Kopieer de Endpoint URL** en plak deze in het `Azure Endpoint:` veld in de applicatie.
    *   **Onthoud de "Deployment name"** die u heeft gekozen in stap 3. Dit is de waarde die u in het `Model:` dropdown-menu in de applicatie kiest wanneer u "Azure OpenAI" als provider selecteert.

## Gebruik

### Stap 1: Applicatie starten

Start `AI-FileOrganizer2.exe` vanuit de `bin\Debug` of `bin\Release` map.

### Stap 2: API-provider en -model selecteren

1.  **Provider selecteren**: Kies uw AI-provider uit het `Provider:` dropdown-menu (Gemini (Google), OpenAI (openai.com), of Azure OpenAI).
2.  **API Key en Endpoint (indien van toepassing)**: Vul uw API-sleutel in het `API Key:` veld. Als u Azure OpenAI hebt geselecteerd, vul dan ook de `Azure Endpoint:` URL in.
3.  **Model selecteren**: Kies het specifieke AI-model dat u wilt gebruiken uit het `Model:` dropdown-menu.

### Stap 3: Mappen configureren

1.  **Bronmap (`Source Folder`)**: Klik op "Select Source" om de map te kiezen die de bestanden bevat die u wilt organiseren. De applicatie scant alle submappen in deze bronmap.
2.  **Doelmap (`Destination Folder`)**: Klik op "Select Destination" om de map te kiezen waar de georganiseerde bestanden naartoe moeten worden verplaatst. De applicatie creëert hierin de categoriefolders en, indien gewenst, submappen.

### Stap 4: Bestanden hernoemen (optioneel)

*   Schakel het selectievakje `Bestandsnamen AI hernoemen` in als u wilt dat de AI suggesties doet voor nieuwe, meer beschrijvende bestandsnamen. Wanneer dit is ingeschakeld, krijgt u voor elk bestand een pop-up waarin u de AI-suggestie kunt accepteren, bewerken of overslaan.

### Stap 5: Organisatie starten

*   Klik op de knop **"Start"** om het organisatieproces te starten.

### Stap 6: Voortgang en logboek

*   **Voortgangsbalk**: Monitor de voortgang onderaan het venster.
*   **Logboek (`rtbLog`)**: Gedetailleerde informatie over elke stap van het proces (extractie, classificatie, verplaatsing, hernoeming) wordt in realtime weergegeven.
*   **"Stop" knop**: U kunt het proces op elk moment onderbreken door op de "Stop" knop te klikken.
*   **"Log Opslaan" knop**: Na voltooiing (of annulering) van het proces, kunt u het volledige logboek opslaan naar een tekstbestand via de "Log Opslaan" knop.

## Ondersteunde bestandstypen

De AI File Organizer kan tekst extraheren uit de volgende bestandstypen:

*   `.pdf` (Portable Document Format)
*   `.docx` (Microsoft Word Document)
*   `.txt` (Plain Text File)
*   `.md` (Markdown File)

## Voorgedefinieerde mapcategorieën

De applicatie probeert bestanden in een van de volgende hoofdcategorieën te plaatsen. Als geen duidelijke match wordt gevonden, wordt het bestand in de 'Overig' map geplaatst.

*   1. Financiën
*   2. Belastingen
*   3. Verzekeringen
*   4. Woning
*   5. Gezondheid en Medisch
*   6. Familie en Kinderen
*   7. Voertuigen
*   8. Persoonlijke Documenten
*   9. Hobbies en interesses
*   10. Carrière en Professionele Ontwikkeling
*   11. Bedrijfsadministratie
*   12. Reizen en vakanties
*   0. Overig (Fallback-categorie)

## Projectstructuur


================================================
FILE: AI-FileOrganizer2.csproj
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{A58EBE3F-C926-432E-B874-AD6F29494AC7}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>AI_FileOrganizer2</RootNamespace>
    <AssemblyName>AI-FileOrganizer2</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>C:\Users\Remse\Desktop\AIFileOrganizerLinkedIn\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>2</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <PublishWizardCompleted>true</PublishWizardCompleted>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ManifestCertificateThumbprint>6F5EC5C02B4F1B3306729060BCE598E3CEF7AC6E</ManifestCertificateThumbprint>
  </PropertyGroup>
  <PropertyGroup>
    <ManifestKeyFile>AI-FileOrganizer2_TemporaryKey.pfx</ManifestKeyFile>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateManifests>true</GenerateManifests>
  </PropertyGroup>
  <PropertyGroup>
    <SignManifests>false</SignManifests>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Azure.AI.OpenAI, Version=2.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8, processorArchitecture=MSIL">
      <HintPath>packages\Azure.AI.OpenAI.2.1.0\lib\netstandard2.0\Azure.AI.OpenAI.dll</HintPath>
    </Reference>
    <Reference Include="Azure.Core, Version=1.44.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8, processorArchitecture=MSIL">
      <HintPath>packages\Azure.Core.1.44.1\lib\net472\Azure.Core.dll</HintPath>
    </Reference>
    <Reference Include="CredentialManagement, Version=1.0.2.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>packages\CredentialManagement.1.0.2\lib\net35\CredentialManagement.dll</HintPath>
    </Reference>
    <Reference Include="CustomMarshalers" />
    <Reference Include="DocumentFormat.OpenXml, Version=3.3.0.0, Culture=neutral, PublicKeyToken=8fb06cb64d019a17, processorArchitecture=MSIL">
      <HintPath>packages\DocumentFormat.OpenXml.3.3.0\lib\net46\DocumentFormat.OpenXml.dll</HintPath>
    </Reference>
    <Reference Include="DocumentFormat.OpenXml.Framework, Version=3.3.0.0, Culture=neutral, PublicKeyToken=8fb06cb64d019a17, processorArchitecture=MSIL">
      <HintPath>packages\DocumentFormat.OpenXml.Framework.3.3.0\lib\net46\DocumentFormat.OpenXml.Framework.dll</HintPath>
    </Reference>
    <Reference Include="GenerativeAI, Version=2.5.10.0, Culture=neutral, PublicKeyToken=125a6b2231c8ea71, processorArchitecture=MSIL">
      <HintPath>packages\Google_GenerativeAI.2.5.10\lib\net462\GenerativeAI.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Bcl.AsyncInterfaces, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Bcl.AsyncInterfaces.9.0.3\lib\net462\Microsoft.Bcl.AsyncInterfaces.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Bcl.HashCode, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Bcl.HashCode.6.0.0\lib\net462\Microsoft.Bcl.HashCode.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.DependencyInjection, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.DependencyInjection.9.0.3\lib\net462\Microsoft.Extensions.DependencyInjection.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.DependencyInjection.Abstractions, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.DependencyInjection.Abstractions.9.0.3\lib\net462\Microsoft.Extensions.DependencyInjection.Abstractions.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Logging, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Logging.9.0.3\lib\net462\Microsoft.Extensions.Logging.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Logging.Abstractions, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Logging.Abstractions.9.0.3\lib\net462\Microsoft.Extensions.Logging.Abstractions.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Options, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Options.9.0.3\lib\net462\Microsoft.Extensions.Options.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Primitives, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Primitives.9.0.3\lib\net462\Microsoft.Extensions.Primitives.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.WindowsAPICodePack, Version=1.1.5.0, Culture=neutral, PublicKeyToken=8985beaab7ea3f04, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft-WindowsAPICodePack-Core.1.1.5\lib\net48\Microsoft.WindowsAPICodePack.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.WindowsAPICodePack.Shell, Version=1.1.5.0, Culture=neutral, PublicKeyToken=8985beaab7ea3f04, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft-WindowsAPICodePack-Shell.1.1.5\lib\net48\Microsoft.WindowsAPICodePack.Shell.dll</HintPath>
    </Reference>
    <Reference Include="Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
      <HintPath>packages\Newtonsoft.Json.13.0.3\lib\net45\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="OpenAI, Version=2.1.0.0, Culture=neutral, PublicKeyToken=b4187f3e65366280, processorArchitecture=MSIL">
      <HintPath>packages\OpenAI.2.1.0\lib\netstandard2.0\OpenAI.dll</HintPath>
    </Reference>
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="System" />
    <Reference Include="System.Buffers, Version=4.0.4.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Buffers.4.6.0\lib\net462\System.Buffers.dll</HintPath>
    </Reference>
    <Reference Include="System.ClientModel, Version=1.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8, processorArchitecture=MSIL">
      <HintPath>packages\System.ClientModel.1.2.1\lib\netstandard2.0\System.ClientModel.dll</HintPath>
    </Reference>
    <Reference Include="System.ComponentModel.Annotations, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.ComponentModel.Annotations.5.0.0\lib\net461\System.ComponentModel.Annotations.dll</HintPath>
    </Reference>
    <Reference Include="System.ComponentModel.Composition" />
    <Reference Include="System.ComponentModel.DataAnnotations" />
    <Reference Include="System.Core" />
    <Reference Include="System.Diagnostics.DiagnosticSource, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Diagnostics.DiagnosticSource.9.0.3\lib\net462\System.Diagnostics.DiagnosticSource.dll</HintPath>
    </Reference>
    <Reference Include="System.IO, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.4.3.0\lib\net462\System.IO.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.Pipelines, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.Pipelines.9.0.3\lib\net462\System.IO.Pipelines.dll</HintPath>
    </Reference>
    <Reference Include="System.Memory, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Memory.4.6.0\lib\net462\System.Memory.dll</HintPath>
    </Reference>
    <Reference Include="System.Memory.Data, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Memory.Data.6.0.0\lib\net461\System.Memory.Data.dll</HintPath>
    </Reference>
    <Reference Include="System.Net" />
    <Reference Include="System.Net.Http, Version=4.1.1.3, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Net.Http.4.3.4\lib\net46\System.Net.Http.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Numerics" />
    <Reference Include="System.Numerics.Vectors, Version=4.1.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Numerics.Vectors.4.6.0\lib\net462\System.Numerics.Vectors.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.4.3.0\lib\net462\System.Runtime.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.CompilerServices.Unsafe, Version=6.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.CompilerServices.Unsafe.6.1.0\lib\net462\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
    </Reference>
    <Reference Include="System.Security.Cryptography.Algorithms, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Algorithms.4.3.0\lib\net463\System.Security.Cryptography.Algorithms.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Encoding, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Encoding.4.3.0\lib\net46\System.Security.Cryptography.Encoding.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Primitives, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Primitives.4.3.0\lib\net46\System.Security.Cryptography.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.X509Certificates.4.3.0\lib\net461\System.Security.Cryptography.X509Certificates.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Text.Encodings.Web, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Text.Encodings.Web.9.0.3\lib\net462\System.Text.Encodings.Web.dll</HintPath>
    </Reference>
    <Reference Include="System.Text.Json, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Text.Json.9.0.3\lib\net462\System.Text.Json.dll</HintPath>
    </Reference>
    <Reference Include="System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Threading.Tasks.Extensions.4.5.4\lib\net461\System.Threading.Tasks.Extensions.dll</HintPath>
    </Reference>
    <Reference Include="System.ValueTuple, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.ValueTuple.4.5.0\lib\net47\System.ValueTuple.dll</HintPath>
    </Reference>
    <Reference Include="System.Web" />
    <Reference Include="System.Xaml" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="UglyToad.PdfPig, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Core, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Core.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.DocumentLayoutAnalysis, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.DocumentLayoutAnalysis.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Fonts, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Fonts.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Package, Version=0.1.10.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Package.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Tokenization, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Tokenization.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Tokens, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Tokens.dll</HintPath>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="WindowsFormsIntegration" />
    <Reference Include="Xceed.Document.NET, Version=5.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Document.NET.5.0.25228.6154\lib\net40\Xceed.Document.NET.dll</HintPath>
    </Reference>
    <Reference Include="Xceed.Drawing.NET, Version=1.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Drawing.NET.1.0.25228.6154\lib\net40\Xceed.Drawing.NET.dll</HintPath>
    </Reference>
    <Reference Include="Xceed.Pdf, Version=5.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Pdf.5.0.25228.6154\lib\net40\Xceed.Pdf.dll</HintPath>
    </Reference>
    <Reference Include="Xceed.Words.NET, Version=5.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Words.NET.5.0.25228.6154\lib\net40\Xceed.Words.NET.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Form1.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Include="FormRenameFile.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="FormRenameFile.Designer.cs">
      <DependentUpon>FormRenameFile.cs</DependentUpon>
    </Compile>
    <Compile Include="Models\ApplicationSettings.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Services\AiClassificationService.cs" />
    <Compile Include="Services\AzureOpenAiProvider.cs" />
    <Compile Include="Services\CredentialStorageService.cs" />
    <Compile Include="Services\DocxTextExtractor.cs" />
    <Compile Include="Services\FileOrganizerService.cs" />
    <Compile Include="Services\GeminiAiProvider.cs" />
    <Compile Include="Services\IaProvider.cs" />
    <Compile Include="Services\ITextExtractor.cs" />
    <Compile Include="Services\OpenAiProvider.cs" />
    <Compile Include="Services\PdfTextExtractor.cs" />
    <Compile Include="Services\PlainTextExtractor.cs" />
    <Compile Include="Services\TextExtractionService.cs" />
    <Compile Include="Utils\FileLogger.cs" />
    <Compile Include="Utils\FileUtil.cs" />
    <Compile Include="Utils\ILogger.cs" />
    <Compile Include="Utils\UiLogger.cs" />
    <EmbeddedResource Include="Form1.resx">
      <DependentUpon>Form1.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="FormRenameFile.resx">
      <DependentUpon>FormRenameFile.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="appsettings.json" />
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <None Include="README.md" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.8">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.8 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>


================================================
FILE: AI-FileOrganizer2.sln
================================================
﻿
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34723.18
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AI-FileOrganizer2", "AI-FileOrganizer2.csproj", "{A58EBE3F-C926-432E-B874-AD6F29494AC7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {94165174-0940-4E0D-9C1C-FAE76A986586}
	EndGlobalSection
EndGlobal



================================================
FILE: AIFileOrganizerLinkedIn.zip
================================================
[Non-text file]


================================================
FILE: App.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.1.0" newVersion="6.0.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.4.0" newVersion="4.0.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.5.0" newVersion="4.1.5.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.3" newVersion="9.0.0.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.3" newVersion="9.0.0.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.3" newVersion="9.0.0.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.ClientModel" publicKeyToken="92742159e12e44c8" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.2.1.0" newVersion="1.2.1.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>


================================================
FILE: appsettings.json
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AI_FileOrganizer2
{
  class appsettings
  {
    "OpenAIKey": "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

  }
}



================================================
FILE: Form1.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http; 
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Microsoft.WindowsAPICodePack.Dialogs; 

using AI_FileOrganizer2.Services;
using AI_FileOrganizer2.Utils;
using AI_FileOrganizer2.Models; 
using ILogger = AI_FileOrganizer2.Utils.ILogger;

namespace AI_FileOrganizer2
{
    public partial class Form1 : Form
    {
        private readonly ILogger _logger; // Logt naar UI
        private static readonly HttpClient _httpClient = new HttpClient(); // Hergebruik voor API-calls
        private long _totalTokensUsed = 0; // Voor tonen in UI
        private CancellationTokenSource _cancellationTokenSource;

        // Services voor hoofdlogica
        private readonly FileOrganizerService _fileOrganizerService;
        private readonly AiClassificationService _aiService;
        private readonly TextExtractionService _textExtractionService;
        private readonly CredentialStorageService _credentialStorageService;

        public Form1()
        {
            InitializeComponent();

            // Init logging en onderliggende services
            _logger = new UiLogger(rtbLog);
            _aiService = new AiClassificationService(_logger);
            _credentialStorageService = new CredentialStorageService(_logger);
            _textExtractionService = new TextExtractionService(
                _logger,
                new List<ITextExtractor>
                {
                    new PdfTextExtractor(_logger),
                    new DocxTextExtractor(_logger),
                    new PlainTextExtractor(_logger)
                }
            );

            _fileOrganizerService = new FileOrganizerService(
                _logger,
                _aiService,
                _textExtractionService,
                _credentialStorageService,
                _httpClient
            );

            // UI-progress en events koppelen aan de service
            _fileOrganizerService.ProgressChanged += (current, total) =>
            {
                if (progressBar1.InvokeRequired)
                    progressBar1.BeginInvoke(new Action(() => { progressBar1.Maximum = total; progressBar1.Value = current; }));
                else
                {
                    progressBar1.Maximum = total;
                    progressBar1.Value = current;
                }
            };
            _fileOrganizerService.TokensUsedUpdated += (tokens) =>
            {
                _totalTokensUsed = tokens;
                UpdateTokensUsedLabel();
            };

            // Callback voor interactieve rename
            _fileOrganizerService.RequestRenameFile += (originalName, suggestedName) =>
            {
                // UI-aanroep op main thread
                return Invoke((Func<Task<(DialogResult, string, bool)>>)(() =>
                {
                    using (var renameForm = new FormRenameFile(originalName, suggestedName))
                    {
                        DialogResult result = renameForm.ShowDialog();
                        return Task.FromResult((result, renameForm.NewFileName, renameForm.SkipFile));
                    }
                })) as Task<(DialogResult, string, bool)>;
            };

            _cancellationTokenSource = new CancellationTokenSource();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // Init providerselectie en standaardwaarden UI
            if (cmbProviderSelection.Items.Count == 0)
            {
                cmbProviderSelection.Items.AddRange(new object[]
                {
                    "Gemini (Google)",
                    "OpenAI (openai.com)",
                    "Azure OpenAI"
                });
            }
            cmbProviderSelection.SelectedIndexChanged -= cmbProviderSelection_SelectedIndexChanged;
            cmbProviderSelection.SelectedIndexChanged += cmbProviderSelection_SelectedIndexChanged;
            cmbProviderSelection.SelectedIndex = 0; // Zet eerste provider (triggert ook modelkeuze)

            txtApiKey.Text = "YOUR_GOOGLE_API_KEY_HERE";
            SetupApiKeyPlaceholder(txtApiKey, "YOUR_GOOGLE_API_KEY_HERE");
            txtApiKey.UseSystemPasswordChar = true;

            string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
            string documentsPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            txtSourceFolder.Text = Path.Combine(desktopPath, "AI Organizer Bronmap");
            txtDestinationFolder.Text = Path.Combine(documentsPath, "AI Organizer Resultaat");

            lblTokensUsed.Text = "Tokens gebruikt: 0";
            progressBar1.Minimum = 0;
            progressBar1.Value = 0;
            progressBar1.Style = ProgressBarStyle.Continuous;
            progressBar1.Visible = false;
            btnStopOrganization.Enabled = false;
            btnSaveLog.Enabled = false;
            chkRenameFiles.Checked = false;
            lblAzureEndpoint.Visible = false;
            txtAzureEndpoint.Visible = false;

            LoadApiKeyForSelectedProvider();
        }

        /// <summary>
        /// Laad API-key (en evt. Azure endpoint) uit Credential Manager op basis van provider.
        /// </summary>
        /// <summary>
        /// Laad de API-key (en evt. Azure endpoint) uit Credential Manager op basis van provider en
        /// zet deze altijd correct zichtbaar in het textfield. Als er geen key is, toon je een placeholder.
        /// </summary>
        private void LoadApiKeyForSelectedProvider()
        {
            string selectedProviderName = cmbProviderSelection.SelectedItem?.ToString() ?? "";
            (string loadedApiKey, string loadedAzureEndpoint) = _credentialStorageService.GetApiKey(selectedProviderName);

            // --- API KEY TEXTBOX ---
            if (!string.IsNullOrWhiteSpace(loadedApiKey))
            {
                // Toon de gevonden key als zwarte tekst
                txtApiKey.Text = loadedApiKey;
                txtApiKey.ForeColor = System.Drawing.Color.Black;
                txtApiKey.Tag = GetDefaultApiKeyPlaceholder(selectedProviderName); // Zorg dat de Tag klopt voor placeholder logic
            }
            else
            {
                // Geen opgeslagen key? Toon placeholder in grijs
                txtApiKey.Text = GetDefaultApiKeyPlaceholder(selectedProviderName);
                txtApiKey.ForeColor = System.Drawing.Color.Gray;
                txtApiKey.Tag = GetDefaultApiKeyPlaceholder(selectedProviderName);
            }

            // --- AZURE ENDPOINT TEXTBOX (alleen voor Azure OpenAI) ---
            if (selectedProviderName == "Azure OpenAI")
            {
                if (!string.IsNullOrWhiteSpace(loadedAzureEndpoint))
                {
                    txtAzureEndpoint.Text = loadedAzureEndpoint;
                    txtAzureEndpoint.ForeColor = System.Drawing.Color.Black;
                    txtAzureEndpoint.Tag = "YOUR_AZURE_ENDPOINT_HERE";
                }
                else
                {
                    txtAzureEndpoint.Text = "YOUR_AZURE_ENDPOINT_HERE";
                    txtAzureEndpoint.ForeColor = System.Drawing.Color.Gray;
                    txtAzureEndpoint.Tag = "YOUR_AZURE_ENDPOINT_HERE";
                }
            }
            else
            {
                txtAzureEndpoint.Text = "YOUR_AZURE_ENDPOINT_HERE";
                txtAzureEndpoint.ForeColor = System.Drawing.Color.Gray;
                txtAzureEndpoint.Tag = "YOUR_AZURE_ENDPOINT_HERE";
            }
        }

        private string GetDefaultApiKeyPlaceholder(string providerName)
        {
            if (providerName.Contains("Gemini")) return "YOUR_GOOGLE_API_KEY_HERE";
            if (providerName.Contains("OpenAI (openai.com)")) return "YOUR_OPENAI_API_KEY_HERE";
            if (providerName.Contains("Azure OpenAI")) return "YOUR_AZURE_ENDPOINT_HERE";
            return "YOUR_API_KEY_HERE";
        }

        /// <summary>
        /// Update modellenlijst en API-key veld bij wisselen van provider.
        /// </summary>
        private void cmbProviderSelection_SelectedIndexChanged(object sender, EventArgs e)
        {
            cmbModelSelection.Items.Clear();
            string provider = cmbProviderSelection.SelectedItem?.ToString() ?? "";
            if (provider == "Gemini (Google)")
            {
                cmbModelSelection.Items.AddRange(new object[] { "gemini-1.5-pro-latest", "gemini-1.5-flash-latest", "gemini-1.0-pro-latest", "gemini-pro", "gemini-2.5-pro-preview-05-06", "gemini-2.5-flash-preview-04-17", "gemini-2.0-flash-001", "gemini-2.0-flash-lite-001" });
                lblApiKey.Text = "Google API Key:";
                lblAzureEndpoint.Visible = false;
                txtAzureEndpoint.Visible = false;
            }
            else if (provider == "OpenAI (openai.com)")
            {
                cmbModelSelection.Items.AddRange(new object[] { "gpt-4o", "gpt-4-turbo", "gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-0125", "gpt-3.5-turbo-0613" });
                lblApiKey.Text = "OpenAI API Key:";
                lblAzureEndpoint.Visible = false;
                txtAzureEndpoint.Visible = false;
            }
            else if (provider == "Azure OpenAI")
            {
                cmbModelSelection.Items.AddRange(new object[] { "YOUR-AZURE-DEPLOYMENT-NAME" });
                lblApiKey.Text = "Azure OpenAI API Key:";
                lblAzureEndpoint.Visible = true;
                txtAzureEndpoint.Visible = true;
            }
            cmbModelSelection.SelectedIndex = 0;
            LoadApiKeyForSelectedProvider();
        }

        /// <summary>
        /// Plaatst placeholder text in een TextBox en regelt kleur.
        /// </summary>
        private void SetupApiKeyPlaceholder(TextBox textBox, string placeholderText)
        {
            textBox.GotFocus -= RemoveApiKeyPlaceholderInternal;
            textBox.LostFocus -= AddApiKeyPlaceholderInternal;
            textBox.Tag = placeholderText;

            if (string.IsNullOrWhiteSpace(textBox.Text) || textBox.Text == placeholderText)
            {
                textBox.Text = placeholderText;
                textBox.ForeColor = System.Drawing.Color.Gray;
            }
            else
            {
                textBox.ForeColor = System.Drawing.Color.Black;
            }

            textBox.GotFocus += RemoveApiKeyPlaceholderInternal;
            textBox.LostFocus += AddApiKeyPlaceholderInternal;
        }

        private void RemoveApiKeyPlaceholderInternal(object sender, EventArgs e)
        {
            TextBox textBox = sender as TextBox;
            string placeholderText = textBox.Tag?.ToString();
            if (textBox.Text == placeholderText)
            {
                textBox.Text = "";
                textBox.ForeColor = System.Drawing.Color.Black;
            }
        }

        private void AddApiKeyPlaceholderInternal(object sender, EventArgs e)
        {
            TextBox textBox = sender as TextBox;
            string placeholderText = textBox.Tag?.ToString();
            if (string.IsNullOrWhiteSpace(textBox.Text))
            {
                textBox.Text = placeholderText;
                textBox.ForeColor = System.Drawing.Color.Gray;
            }
        }

        /// <summary>
        /// Moderne folderdialog voor bronmap selectie.
        /// </summary>
        private void btnSelectSourceFolder_Click(object sender, EventArgs e)
        {
            using (var dialog = new CommonOpenFileDialog())
            {
                dialog.IsFolderPicker = true;
                dialog.Title = "Selecteer de bronmap met bestanden (inclusief submappen)";
                dialog.InitialDirectory = Directory.Exists(txtSourceFolder.Text) ? txtSourceFolder.Text : Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
                dialog.RestoreDirectory = true;
                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    txtSourceFolder.Text = dialog.FileName;
                }
            }
        }

        /// <summary>
        /// Moderne folderdialog voor doelmap selectie.
        /// </summary>
        private void btnSelectDestinationFolder_Click(object sender, EventArgs e)
        {
            using (var dialog = new CommonOpenFileDialog())
            {
                dialog.IsFolderPicker = true;
                dialog.Title = "Selecteer de doelmap voor geordende bestanden";
                dialog.EnsurePathExists = true;
                dialog.InitialDirectory = Directory.Exists(txtDestinationFolder.Text) ? txtDestinationFolder.Text : Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                dialog.RestoreDirectory = true;
                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    txtDestinationFolder.Text = dialog.FileName;
                }
            }
        }

        /// <summary>
        /// Start bestandsorganisatieproces.
        /// </summary>
        private async void btnStartOrganization_Click(object sender, EventArgs e)
        {
            rtbLog.Clear();
            SetUiEnabled(false);
            btnStopOrganization.Enabled = true;
            btnSaveLog.Enabled = false;
            progressBar1.Visible = true;

            string apiKey = txtApiKey.Text;
            string currentApiKeyPlaceholder = txtApiKey.Tag?.ToString();
            if (string.IsNullOrWhiteSpace(apiKey) || apiKey == currentApiKeyPlaceholder)
            {
                _logger.Log("FOUT: Gelieve een geldige API Key in te vullen.");
                SetUiEnabled(true); btnStopOrganization.Enabled = false; progressBar1.Visible = false; return;
            }

            string providerName = cmbProviderSelection.SelectedItem?.ToString() ?? "";
            string azureEndpoint = txtAzureEndpoint.Text;
            string selectedModel = cmbModelSelection.SelectedItem?.ToString() ?? "gemini-1.5-pro-latest";

            if (!Directory.Exists(txtSourceFolder.Text))
            {
                _logger.Log($"FOUT: Bronmap '{txtSourceFolder.Text}' niet gevonden.");
                SetUiEnabled(true); btnStopOrganization.Enabled = false; progressBar1.Visible = false; return;
            }

            _logger.Log($"Starten met organiseren van bestanden uit: {txtSourceFolder.Text} (inclusief submappen)");
            _logger.Log($"Gebruikt model: {selectedModel}");
            if (chkRenameFiles.Checked)
            {
                _logger.Log("Bestandsnamen worden hernoemd met AI-suggesties.");
            }

            _totalTokensUsed = 0;
            UpdateTokensUsedLabel();
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = new CancellationTokenSource();

            try
            {
                await _fileOrganizerService.OrganizeFilesAsync(
                    txtSourceFolder.Text,
                    txtDestinationFolder.Text,
                    apiKey,
                    providerName,
                    selectedModel,
                    azureEndpoint,
                    chkRenameFiles.Checked,
                    _cancellationTokenSource.Token
                );
            }
            catch (OperationCanceledException)
            {
                _logger.Log("\nOrganisatie geannuleerd door gebruiker.");
            }
            catch (Exception ex)
            {
                _logger.Log($"KRITIEKE FOUT tijdens organisatie: {ex.Message}");
            }
            finally
            {
                _logger.Log("\nOrganisatie voltooid!");
                SetUiEnabled(true);
                btnStopOrganization.Enabled = false;
                btnSaveLog.Enabled = true;
                progressBar1.Visible = false;
                _cancellationTokenSource.Dispose();
                _cancellationTokenSource = null;
            }
        }

        /// <summary>
        /// Annuleert huidig organisatieproces.
        /// </summary>
        private void btnStopOrganization_Click(object sender, EventArgs e)
        {
            _cancellationTokenSource?.Cancel();
            _logger.Log("Annulering aangevraagd...");
            btnStopOrganization.Enabled = false;
        }

        /// <summary>
        /// Sla logbestand op via moderne dialoog.
        /// </summary>
        private void btnSaveLog_Click(object sender, EventArgs e)
        {
            using (var dialog = new CommonSaveFileDialog())
            {
                dialog.Filters.Add(new CommonFileDialogFilter("Tekstbestanden", "*.txt"));
                dialog.DefaultExtension = "txt";
                dialog.Title = "Sla logbestand op";
                dialog.DefaultFileName = $"AI_Organizer_Log_{DateTime.Now:yyyyMMdd_HHmmss}.txt";
                dialog.InitialDirectory = Directory.Exists(txtDestinationFolder.Text) ? txtDestinationFolder.Text : Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                dialog.RestoreDirectory = true;

                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    try
                    {
                        File.WriteAllText(dialog.FileName, rtbLog.Text);
                        MessageBox.Show("Logbestand succesvol opgeslagen.", "Succes", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Fout bij opslaan: {ex.Message}", "Fout", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        /// <summary>
        /// Schakelt UI-elementen in/uit.
        /// </summary>
        private void SetUiEnabled(bool enabled)
        {
            txtApiKey.Enabled = enabled;
            txtSourceFolder.Enabled = enabled;
            btnSelectSourceFolder.Enabled = enabled;
            txtDestinationFolder.Enabled = enabled;
            btnSelectDestinationFolder.Enabled = enabled;
            cmbModelSelection.Enabled = enabled;
            cmbProviderSelection.Enabled = enabled;
            txtAzureEndpoint.Enabled = enabled;
            btnStartOrganization.Enabled = enabled;
            btnRenameSingleFile.Enabled = enabled;
            linkLabelAuthor.Enabled = enabled;
            chkRenameFiles.Enabled = enabled;
        }

        /// <summary>
        /// Update token label (UI-thread safe).
        /// </summary>
        private void UpdateTokensUsedLabel()
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(UpdateTokensUsedLabel));
                return;
            }
            lblTokensUsed.Text = $"Tokens gebruikt: {_totalTokensUsed}";
        }

        /// <summary>
        /// Open LinkedIn van auteur.
        /// </summary>
        private void linkLabelAuthor_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            try
            {
                string url = "https://www.linkedin.com/in/remseymailjard/";
                Process.Start(new ProcessStartInfo
                {
                    FileName = url,
                    UseShellExecute = true
                });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Kan link niet openen: {ex.Message}", "Fout", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        /// <summary>
        /// Hernaam één bestand via AI met moderne file-dialog.
        /// </summary>
        private async void btnRenameSingleFile_Click(object sender, EventArgs e)
        {
            rtbLog.Clear();
            SetUiEnabled(false);
            btnStopOrganization.Enabled = false;
            btnSaveLog.Enabled = false;
            progressBar1.Visible = false;

            string apiKey = txtApiKey.Text;
            if (string.IsNullOrWhiteSpace(apiKey) || (txtApiKey.Tag != null && apiKey == txtApiKey.Tag.ToString()))
            {
                _logger.Log("FOUT: Gelieve een geldige API Key in te vullen.");
                SetUiEnabled(true); return;
            }

            string selectedModel = cmbModelSelection.SelectedItem?.ToString() ?? "gemini-1.5-pro-latest";
            string providerName = cmbProviderSelection.SelectedItem?.ToString() ?? "Gemini (Google)";
            string azureEndpoint = txtAzureEndpoint?.Text;

            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = new CancellationTokenSource();

            using (var dialog = new CommonOpenFileDialog())
            {
                dialog.IsFolderPicker = false;
                dialog.EnsureFileExists = true;
                dialog.Multiselect = false;
                dialog.Title = "Selecteer een bestand om te hernoemen";
                dialog.Filters.Add(new CommonFileDialogFilter("Ondersteunde bestanden", "*.pdf;*.docx;*.txt;*.md"));
                dialog.Filters.Add(new CommonFileDialogFilter("PDF Bestanden", "*.pdf"));
                dialog.Filters.Add(new CommonFileDialogFilter("Word Documenten", "*.docx"));
                dialog.Filters.Add(new CommonFileDialogFilter("Tekst Bestanden", "*.txt;*.md"));
                dialog.Filters.Add(new CommonFileDialogFilter("Alle Bestanden", "*.*"));
                dialog.InitialDirectory = txtSourceFolder.Text;
                dialog.RestoreDirectory = true;

                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    string filePath = dialog.FileName;
                    try
                    {
                        await _fileOrganizerService.RenameSingleFileInteractiveAsync(
                            filePath,
                            apiKey,
                            providerName,
                            selectedModel,
                            azureEndpoint,
                            _cancellationTokenSource.Token
                        );
                    }
                    catch (OperationCanceledException)
                    {
                        _logger.Log("Hernoem-actie geannuleerd door gebruiker.");
                    }
                    catch (Exception ex)
                    {
                        _logger.Log($"KRITIEKE FOUT tijdens enkel bestand hernoemen: {ex.Message}");
                    }
                }
                else
                {
                    _logger.Log("Bestandselectie geannuleerd. Geen bestand hernoemd.");
                }
            }
            SetUiEnabled(true);
            btnSaveLog.Enabled = true;
            _cancellationTokenSource.Dispose();
            _cancellationTokenSource = null;
        }
    }
}



================================================
FILE: Form1.Designer.cs
================================================
﻿namespace AI_FileOrganizer2
{
    partial class Form1
    {
        private System.ComponentModel.IContainer components = null;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.lblProvider = new System.Windows.Forms.Label();
            this.cmbProviderSelection = new System.Windows.Forms.ComboBox();
            this.lblApiKey = new System.Windows.Forms.Label();
            this.txtApiKey = new System.Windows.Forms.TextBox();
            this.lblAzureEndpoint = new System.Windows.Forms.Label();
            this.txtAzureEndpoint = new System.Windows.Forms.TextBox();
            this.lblSourceFolder = new System.Windows.Forms.Label();
            this.txtSourceFolder = new System.Windows.Forms.TextBox();
            this.btnSelectSourceFolder = new System.Windows.Forms.Button();
            this.lblDestinationFolder = new System.Windows.Forms.Label();
            this.txtDestinationFolder = new System.Windows.Forms.TextBox();
            this.btnSelectDestinationFolder = new System.Windows.Forms.Button();
            this.lblModel = new System.Windows.Forms.Label();
            this.cmbModelSelection = new System.Windows.Forms.ComboBox();
            this.chkRenameFiles = new System.Windows.Forms.CheckBox();
            this.btnStartOrganization = new System.Windows.Forms.Button();
            this.btnStopOrganization = new System.Windows.Forms.Button();
            this.btnSaveLog = new System.Windows.Forms.Button();
            this.btnRenameSingleFile = new System.Windows.Forms.Button();
            this.progressBar1 = new System.Windows.Forms.ProgressBar();
            this.lblTokensUsed = new System.Windows.Forms.Label();
            this.rtbLog = new System.Windows.Forms.RichTextBox();
            this.linkLabelAuthor = new System.Windows.Forms.LinkLabel();
            this.tableLayoutPanel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // tableLayoutPanel1
            // 
            this.tableLayoutPanel1.ColumnCount = 3;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 20F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 60F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 20F));
            this.tableLayoutPanel1.Controls.Add(this.lblProvider, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.cmbProviderSelection, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.lblApiKey, 0, 1);
            this.tableLayoutPanel1.Controls.Add(this.txtApiKey, 1, 1);
            this.tableLayoutPanel1.Controls.Add(this.lblAzureEndpoint, 0, 2);
            this.tableLayoutPanel1.Controls.Add(this.txtAzureEndpoint, 1, 2);
            this.tableLayoutPanel1.Controls.Add(this.lblSourceFolder, 0, 3);
            this.tableLayoutPanel1.Controls.Add(this.txtSourceFolder, 1, 3);
            this.tableLayoutPanel1.Controls.Add(this.btnSelectSourceFolder, 2, 3);
            this.tableLayoutPanel1.Controls.Add(this.lblDestinationFolder, 0, 4);
            this.tableLayoutPanel1.Controls.Add(this.txtDestinationFolder, 1, 4);
            this.tableLayoutPanel1.Controls.Add(this.btnSelectDestinationFolder, 2, 4);
            this.tableLayoutPanel1.Controls.Add(this.lblModel, 0, 5);
            this.tableLayoutPanel1.Controls.Add(this.cmbModelSelection, 1, 5);
            this.tableLayoutPanel1.Controls.Add(this.chkRenameFiles, 0, 6);
            this.tableLayoutPanel1.Controls.Add(this.btnStartOrganization, 0, 7);
            this.tableLayoutPanel1.Controls.Add(this.btnStopOrganization, 1, 7);
            this.tableLayoutPanel1.Controls.Add(this.btnSaveLog, 2, 7);
            this.tableLayoutPanel1.Controls.Add(this.btnRenameSingleFile, 0, 8);
            this.tableLayoutPanel1.Controls.Add(this.progressBar1, 0, 9);
            this.tableLayoutPanel1.Controls.Add(this.lblTokensUsed, 2, 9);
            this.tableLayoutPanel1.Controls.Add(this.rtbLog, 0, 10);
            this.tableLayoutPanel1.Controls.Add(this.linkLabelAuthor, 0, 11);
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.RowCount = 13;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 25F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 36F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 36F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 22F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 26F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 2F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(850, 480);
            this.tableLayoutPanel1.TabIndex = 0;
            // 
            // lblProvider
            // 
            this.lblProvider.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblProvider.AutoSize = true;
            this.lblProvider.Location = new System.Drawing.Point(3, 6);
            this.lblProvider.Name = "lblProvider";
            this.lblProvider.Size = new System.Drawing.Size(61, 16);
            this.lblProvider.TabIndex = 0;
            this.lblProvider.Text = "Provider:";
            // 
            // cmbProviderSelection
            // 
            this.cmbProviderSelection.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.cmbProviderSelection, 2);
            this.cmbProviderSelection.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbProviderSelection.Items.AddRange(new object[] {
            "Gemini (Google)",
            "OpenAI (openai.com)",
            "Azure OpenAI"});
            this.cmbProviderSelection.Location = new System.Drawing.Point(173, 3);
            this.cmbProviderSelection.Name = "cmbProviderSelection";
            this.cmbProviderSelection.Size = new System.Drawing.Size(674, 24);
            this.cmbProviderSelection.TabIndex = 1;
            this.cmbProviderSelection.SelectedIndexChanged += new System.EventHandler(this.cmbProviderSelection_SelectedIndexChanged);
            // 
            // lblApiKey
            // 
            this.lblApiKey.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblApiKey.AutoSize = true;
            this.lblApiKey.Location = new System.Drawing.Point(3, 34);
            this.lblApiKey.Name = "lblApiKey";
            this.lblApiKey.Size = new System.Drawing.Size(105, 16);
            this.lblApiKey.TabIndex = 2;
            this.lblApiKey.Text = "Google API Key:";
            // 
            // txtApiKey
            // 
            this.txtApiKey.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.txtApiKey, 2);
            this.txtApiKey.Location = new System.Drawing.Point(173, 31);
            this.txtApiKey.Name = "txtApiKey";
            this.txtApiKey.Size = new System.Drawing.Size(674, 22);
            this.txtApiKey.TabIndex = 3;
            this.txtApiKey.UseSystemPasswordChar = true;
            // 
            // lblAzureEndpoint
            // 
            this.lblAzureEndpoint.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblAzureEndpoint.AutoSize = true;
            this.lblAzureEndpoint.Location = new System.Drawing.Point(3, 62);
            this.lblAzureEndpoint.Name = "lblAzureEndpoint";
            this.lblAzureEndpoint.Size = new System.Drawing.Size(100, 16);
            this.lblAzureEndpoint.TabIndex = 4;
            this.lblAzureEndpoint.Text = "Azure Endpoint:";
            this.lblAzureEndpoint.Visible = false;
            // 
            // txtAzureEndpoint
            // 
            this.txtAzureEndpoint.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.txtAzureEndpoint, 2);
            this.txtAzureEndpoint.Location = new System.Drawing.Point(173, 59);
            this.txtAzureEndpoint.Name = "txtAzureEndpoint";
            this.txtAzureEndpoint.Size = new System.Drawing.Size(674, 22);
            this.txtAzureEndpoint.TabIndex = 5;
            this.txtAzureEndpoint.Visible = false;
            // 
            // lblSourceFolder
            // 
            this.lblSourceFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblSourceFolder.AutoSize = true;
            this.lblSourceFolder.Location = new System.Drawing.Point(3, 90);
            this.lblSourceFolder.Name = "lblSourceFolder";
            this.lblSourceFolder.Size = new System.Drawing.Size(95, 16);
            this.lblSourceFolder.TabIndex = 6;
            this.lblSourceFolder.Text = "Source Folder:";
            // 
            // txtSourceFolder
            // 
            this.txtSourceFolder.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.txtSourceFolder.Location = new System.Drawing.Point(173, 87);
            this.txtSourceFolder.Name = "txtSourceFolder";
            this.txtSourceFolder.ReadOnly = true;
            this.txtSourceFolder.Size = new System.Drawing.Size(504, 22);
            this.txtSourceFolder.TabIndex = 7;
            // 
            // btnSelectSourceFolder
            // 
            this.btnSelectSourceFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.btnSelectSourceFolder.Location = new System.Drawing.Point(683, 87);
            this.btnSelectSourceFolder.Name = "btnSelectSourceFolder";
            this.btnSelectSourceFolder.Size = new System.Drawing.Size(75, 22);
            this.btnSelectSourceFolder.TabIndex = 8;
            this.btnSelectSourceFolder.Text = "Select Source";
            this.btnSelectSourceFolder.Click += new System.EventHandler(this.btnSelectSourceFolder_Click);
            // 
            // lblDestinationFolder
            // 
            this.lblDestinationFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblDestinationFolder.AutoSize = true;
            this.lblDestinationFolder.Location = new System.Drawing.Point(3, 118);
            this.lblDestinationFolder.Name = "lblDestinationFolder";
            this.lblDestinationFolder.Size = new System.Drawing.Size(119, 16);
            this.lblDestinationFolder.TabIndex = 9;
            this.lblDestinationFolder.Text = "Destination Folder:";
            // 
            // txtDestinationFolder
            // 
            this.txtDestinationFolder.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.txtDestinationFolder.Location = new System.Drawing.Point(173, 115);
            this.txtDestinationFolder.Name = "txtDestinationFolder";
            this.txtDestinationFolder.ReadOnly = true;
            this.txtDestinationFolder.Size = new System.Drawing.Size(504, 22);
            this.txtDestinationFolder.TabIndex = 10;
            // 
            // btnSelectDestinationFolder
            // 
            this.btnSelectDestinationFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.btnSelectDestinationFolder.Location = new System.Drawing.Point(683, 115);
            this.btnSelectDestinationFolder.Name = "btnSelectDestinationFolder";
            this.btnSelectDestinationFolder.Size = new System.Drawing.Size(75, 22);
            this.btnSelectDestinationFolder.TabIndex = 11;
            this.btnSelectDestinationFolder.Text = "Select Destination";
            this.btnSelectDestinationFolder.Click += new System.EventHandler(this.btnSelectDestinationFolder_Click);
            // 
            // lblModel
            // 
            this.lblModel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblModel.AutoSize = true;
            this.lblModel.Location = new System.Drawing.Point(3, 146);
            this.lblModel.Name = "lblModel";
            this.lblModel.Size = new System.Drawing.Size(48, 16);
            this.lblModel.TabIndex = 12;
            this.lblModel.Text = "Model:";
            // 
            // cmbModelSelection
            // 
            this.cmbModelSelection.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.cmbModelSelection, 2);
            this.cmbModelSelection.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbModelSelection.Location = new System.Drawing.Point(173, 143);
            this.cmbModelSelection.Name = "cmbModelSelection";
            this.cmbModelSelection.Size = new System.Drawing.Size(674, 24);
            this.cmbModelSelection.TabIndex = 13;
            // 
            // chkRenameFiles
            // 
            this.chkRenameFiles.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.chkRenameFiles.AutoSize = true;
            this.tableLayoutPanel1.SetColumnSpan(this.chkRenameFiles, 3);
            this.chkRenameFiles.Location = new System.Drawing.Point(3, 171);
            this.chkRenameFiles.Name = "chkRenameFiles";
            this.chkRenameFiles.Size = new System.Drawing.Size(213, 19);
            this.chkRenameFiles.TabIndex = 14;
            this.chkRenameFiles.Text = "Bestandsnamen AI hernoemen";
            // 
            // btnStartOrganization
            // 
            this.btnStartOrganization.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnStartOrganization.Location = new System.Drawing.Point(3, 196);
            this.btnStartOrganization.Name = "btnStartOrganization";
            this.btnStartOrganization.Size = new System.Drawing.Size(164, 30);
            this.btnStartOrganization.TabIndex = 15;
            this.btnStartOrganization.Text = "Start Organisatie";
            this.btnStartOrganization.Click += new System.EventHandler(this.btnStartOrganization_Click);
            // 
            // btnStopOrganization
            // 
            this.btnStopOrganization.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnStopOrganization.Location = new System.Drawing.Point(173, 196);
            this.btnStopOrganization.Name = "btnStopOrganization";
            this.btnStopOrganization.Size = new System.Drawing.Size(504, 30);
            this.btnStopOrganization.TabIndex = 16;
            this.btnStopOrganization.Text = "Stop Organisatie";
            this.btnStopOrganization.Click += new System.EventHandler(this.btnStopOrganization_Click);
            // 
            // btnSaveLog
            // 
            this.btnSaveLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnSaveLog.Location = new System.Drawing.Point(683, 196);
            this.btnSaveLog.Name = "btnSaveLog";
            this.btnSaveLog.Size = new System.Drawing.Size(164, 30);
            this.btnSaveLog.TabIndex = 17;
            this.btnSaveLog.Text = "Log Opslaan";
            this.btnSaveLog.Click += new System.EventHandler(this.btnSaveLog_Click);
            // 
            // btnRenameSingleFile
            // 
            this.tableLayoutPanel1.SetColumnSpan(this.btnRenameSingleFile, 3);
            this.btnRenameSingleFile.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnRenameSingleFile.Location = new System.Drawing.Point(3, 232);
            this.btnRenameSingleFile.Name = "btnRenameSingleFile";
            this.btnRenameSingleFile.Size = new System.Drawing.Size(844, 30);
            this.btnRenameSingleFile.TabIndex = 18;
            this.btnRenameSingleFile.Text = "Hernoem Enkel Bestand met AI";
            this.btnRenameSingleFile.UseVisualStyleBackColor = true;
            this.btnRenameSingleFile.Click += new System.EventHandler(this.btnRenameSingleFile_Click);
            // 
            // progressBar1
            // 
            this.progressBar1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.progressBar1, 2);
            this.progressBar1.Location = new System.Drawing.Point(3, 268);
            this.progressBar1.Name = "progressBar1";
            this.progressBar1.Size = new System.Drawing.Size(674, 16);
            this.progressBar1.TabIndex = 19;
            this.progressBar1.Visible = false;
            // 
            // lblTokensUsed
            // 
            this.lblTokensUsed.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.lblTokensUsed.AutoSize = true;
            this.lblTokensUsed.Location = new System.Drawing.Point(730, 268);
            this.lblTokensUsed.Name = "lblTokensUsed";
            this.lblTokensUsed.Size = new System.Drawing.Size(117, 16);
            this.lblTokensUsed.TabIndex = 20;
            this.lblTokensUsed.Text = "Tokens gebruikt: 0";
            // 
            // rtbLog
            // 
            this.tableLayoutPanel1.SetColumnSpan(this.rtbLog, 3);
            this.rtbLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.rtbLog.Location = new System.Drawing.Point(3, 290);
            this.rtbLog.Name = "rtbLog";
            this.rtbLog.ReadOnly = true;
            this.rtbLog.Size = new System.Drawing.Size(844, 159);
            this.rtbLog.TabIndex = 21;
            this.rtbLog.Text = "";
            // 
            // linkLabelAuthor
            // 
            this.linkLabelAuthor.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.linkLabelAuthor.AutoSize = true;
            this.tableLayoutPanel1.SetColumnSpan(this.linkLabelAuthor, 3);
            this.linkLabelAuthor.Location = new System.Drawing.Point(682, 462);
            this.linkLabelAuthor.Name = "linkLabelAuthor";
            this.linkLabelAuthor.Size = new System.Drawing.Size(165, 16);
            this.linkLabelAuthor.TabIndex = 22;
            this.linkLabelAuthor.TabStop = true;
            this.linkLabelAuthor.Text = "Made by Remsey Mailjard";
            this.linkLabelAuthor.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.linkLabelAuthor.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabelAuthor_LinkClicked);
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(850, 480);
            this.Controls.Add(this.tableLayoutPanel1);
            this.Name = "Form1";
            this.Text = "AI File Organizer - Remsey Mailjard";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.tableLayoutPanel1.ResumeLayout(false);
            this.tableLayoutPanel1.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private System.Windows.Forms.Label lblProvider;
        private System.Windows.Forms.ComboBox cmbProviderSelection;
        private System.Windows.Forms.Label lblApiKey;
        private System.Windows.Forms.TextBox txtApiKey;
        private System.Windows.Forms.Label lblAzureEndpoint;
        private System.Windows.Forms.TextBox txtAzureEndpoint;
        private System.Windows.Forms.Label lblSourceFolder;
        private System.Windows.Forms.TextBox txtSourceFolder;
        private System.Windows.Forms.Button btnSelectSourceFolder;
        private System.Windows.Forms.Label lblDestinationFolder;
        private System.Windows.Forms.TextBox txtDestinationFolder;
        private System.Windows.Forms.Button btnSelectDestinationFolder;
        private System.Windows.Forms.Label lblModel;
        private System.Windows.Forms.ComboBox cmbModelSelection;
        private System.Windows.Forms.CheckBox chkRenameFiles;
        private System.Windows.Forms.Button btnStartOrganization;
        private System.Windows.Forms.Button btnStopOrganization;
        private System.Windows.Forms.Button btnSaveLog;
        private System.Windows.Forms.ProgressBar progressBar1;
        private System.Windows.Forms.Label lblTokensUsed;
        private System.Windows.Forms.RichTextBox rtbLog;
        private System.Windows.Forms.LinkLabel linkLabelAuthor;
        private System.Windows.Forms.Button btnRenameSingleFile;
    }
}



================================================
FILE: Form1.resx
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
FILE: FormRenameFile.cs
================================================
﻿using System;
using System.IO;
using System.Linq; // This using statement is explicitly needed for .Any() and .Contains()
using System.Windows.Forms;

namespace AI_FileOrganizer2
{
    public partial class FormRenameFile : Form
    {
        public string NewFileName { get; private set; }
        public bool SkipFile { get; private set; } = false;

        public FormRenameFile(string originalFileName, string suggestedFileName)
        {
            InitializeComponent(); // This call links to the FormRenameFile.Designer.cs file
            lblOriginalFileName.Text = originalFileName;
            txtSuggestedFileName.Text = suggestedFileName;
            NewFileName = suggestedFileName; // Default value
        }

        private void btnSave_Click(object sender, EventArgs e)
        {
            string newName = txtSuggestedFileName.Text.Trim();
            if (string.IsNullOrWhiteSpace(newName))
            {
                MessageBox.Show("De nieuwe bestandsnaam mag niet leeg zijn.", "Ongeldige naam", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Basis validatie: verwijder ongeldige karakters voor bestandsnamen
            char[] invalidChars = Path.GetInvalidFileNameChars();
            if (newName.Any(c => invalidChars.Contains(c)))
            {
                MessageBox.Show($"De nieuwe bestandsnaam bevat ongeldige karakters. Vermijd: {string.Join("", invalidChars)}", "Ongeldige naam", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            NewFileName = newName;
            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void btnSkip_Click(object sender, EventArgs e)
        {
            SkipFile = true;
            this.DialogResult = DialogResult.OK; // Gebruik OK om aan te geven dat een beslissing is genomen (overslaan)
            this.Close();
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        private void FormRenameFile_Load(object sender, EventArgs e)
        {
            // Any specific load logic for the form
        }
    }
}


================================================
FILE: FormRenameFile.Designer.cs
================================================
﻿using System.Linq; // Although not strictly needed for designer code, it was in your original.

namespace AI_FileOrganizer2
{
    partial class FormRenameFile
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.lblOriginalFileName = new System.Windows.Forms.Label();
            this.txtSuggestedFileName = new System.Windows.Forms.TextBox();
            this.btnSave = new System.Windows.Forms.Button();
            this.btnSkip = new System.Windows.Forms.Button();
            this.btnCancel = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.SuspendLayout();
            //
            // lblOriginalFileName
            //
            this.lblOriginalFileName.AutoSize = true;
            this.lblOriginalFileName.Location = new System.Drawing.Point(145, 23);
            this.lblOriginalFileName.Name = "lblOriginalFileName";
            this.lblOriginalFileName.Size = new System.Drawing.Size(150, 16);
            this.lblOriginalFileName.TabIndex = 0;
            this.lblOriginalFileName.Text = "[Oorspronkelijke Naam]";
            //
            // txtSuggestedFileName
            //
            this.txtSuggestedFileName.Location = new System.Drawing.Point(148, 62);
            this.txtSuggestedFileName.Name = "txtSuggestedFileName";
            this.txtSuggestedFileName.Size = new System.Drawing.Size(300, 22);
            this.txtSuggestedFileName.TabIndex = 1;
            //
            // btnSave
            //
            this.btnSave.Location = new System.Drawing.Point(148, 105);
            this.btnSave.Name = "btnSave";
            this.btnSave.Size = new System.Drawing.Size(95, 30);
            this.btnSave.TabIndex = 2;
            this.btnSave.Text = "Opslaan";
            this.btnSave.UseVisualStyleBackColor = true;
            this.btnSave.Click += new System.EventHandler(this.btnSave_Click);
            //
            // btnSkip
            //
            this.btnSkip.Location = new System.Drawing.Point(249, 105);
            this.btnSkip.Name = "btnSkip";
            this.btnSkip.Size = new System.Drawing.Size(95, 30);
            this.btnSkip.TabIndex = 3;
            this.btnSkip.Text = "Overslaan";
            this.btnSkip.UseVisualStyleBackColor = true;
            this.btnSkip.Click += new System.EventHandler(this.btnSkip_Click);
            //
            // btnCancel
            //
            this.btnCancel.Location = new System.Drawing.Point(350, 105);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(98, 30);
            this.btnCancel.TabIndex = 4;
            this.btnCancel.Text = "Annuleren";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            //
            // label1
            //
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(22, 23);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(101, 16);
            this.label1.TabIndex = 5;
            this.label1.Text = "Originele naam:";
            //
            // label2
            //
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(22, 65);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(129, 16);
            this.label2.TabIndex = 6;
            this.label2.Text = "Voorgestelde naam:";
            //
            // FormRenameFile
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(477, 158);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnSkip);
            this.Controls.Add(this.btnSave);
            this.Controls.Add(this.txtSuggestedFileName);
            this.Controls.Add(this.lblOriginalFileName);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "FormRenameFile";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Bestandsnaam Aanpassen";
            this.Load += new System.EventHandler(this.FormRenameFile_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label lblOriginalFileName;
        private System.Windows.Forms.TextBox txtSuggestedFileName;
        private System.Windows.Forms.Button btnSave;
        private System.Windows.Forms.Button btnSkip;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
    }
}


================================================
FILE: FormRenameFile.resx
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
FILE: packages.config
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Azure.AI.OpenAI" version="2.1.0" targetFramework="net48" />
  <package id="Azure.Core" version="1.44.1" targetFramework="net48" />
  <package id="CredentialManagement" version="1.0.2" targetFramework="net48" />
  <package id="DocumentFormat.OpenXml" version="3.3.0" targetFramework="net48" />
  <package id="DocumentFormat.OpenXml.Framework" version="3.3.0" targetFramework="net48" />
  <package id="Google_GenerativeAI" version="2.5.10" targetFramework="net48" />
  <package id="Microsoft.Bcl.AsyncInterfaces" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Bcl.HashCode" version="6.0.0" targetFramework="net48" />
  <package id="Microsoft.Extensions.DependencyInjection" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.DependencyInjection.Abstractions" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Logging" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Logging.Abstractions" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Options" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Primitives" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft-WindowsAPICodePack-Core" version="1.1.5" targetFramework="net48" />
  <package id="Microsoft-WindowsAPICodePack-Shell" version="1.1.5" targetFramework="net48" />
  <package id="Newtonsoft.Json" version="13.0.3" targetFramework="net48" />
  <package id="OpenAI" version="2.1.0" targetFramework="net48" />
  <package id="PdfPig" version="0.1.10" targetFramework="net48" />
  <package id="System.Buffers" version="4.6.0" targetFramework="net48" />
  <package id="System.ClientModel" version="1.2.1" targetFramework="net48" />
  <package id="System.ComponentModel.Annotations" version="5.0.0" targetFramework="net48" />
  <package id="System.Diagnostics.DiagnosticSource" version="9.0.3" targetFramework="net48" />
  <package id="System.IO" version="4.3.0" targetFramework="net48" />
  <package id="System.IO.Pipelines" version="9.0.3" targetFramework="net48" />
  <package id="System.Memory" version="4.6.0" targetFramework="net48" />
  <package id="System.Memory.Data" version="6.0.0" targetFramework="net48" />
  <package id="System.Net.Http" version="4.3.4" targetFramework="net48" />
  <package id="System.Numerics.Vectors" version="4.6.0" targetFramework="net48" />
  <package id="System.Runtime" version="4.3.0" targetFramework="net48" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.1.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Algorithms" version="4.3.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Encoding" version="4.3.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Primitives" version="4.3.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.X509Certificates" version="4.3.0" targetFramework="net48" />
  <package id="System.Text.Encodings.Web" version="9.0.3" targetFramework="net48" />
  <package id="System.Text.Json" version="9.0.3" targetFramework="net48" />
  <package id="System.Threading.Tasks.Extensions" version="4.5.4" targetFramework="net48" />
  <package id="System.ValueTuple" version="4.5.0" targetFramework="net48" />
  <package id="Xceed.Document.NET" version="5.0.25228.6154" targetFramework="net48" />
  <package id="Xceed.Drawing.NET" version="1.0.25228.6154" targetFramework="net48" />
  <package id="Xceed.Pdf" version="5.0.25228.6154" targetFramework="net48" />
  <package id="Xceed.Words.NET" version="5.0.25228.6154" targetFramework="net48" />
</packages>


================================================
FILE: Program.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AI_FileOrganizer2
{
    internal static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}



================================================
FILE: README_AI_File_Organizer.md
================================================

# AI File Organizer 🚀

Een slimme en gebruiksvriendelijke applicatie voor het automatisch ordenen en hernoemen van bestanden met behulp van geavanceerde AI-modellen zoals Gemini, OpenAI en Azure OpenAI.

## 📌 Vereisten

- Windows 10 of hoger
- .NET Framework 4.8 (wordt automatisch geïnstalleerd indien nodig)
- Een geldige API Key voor Gemini (Google), OpenAI, of Azure OpenAI
- Zorg ervoor dat billing actief is op je AI-provider project.

## 🚀 Installatie

Volg onderstaande stappen om de applicatie te installeren:

1. **Download** het installatiebestand (`setup.exe`) vanuit deze map.
2. Dubbelklik op het bestand `setup.exe` om het installatieproces te starten.
3. Volg de instructies van de installatie-wizard.

> **Let op**: Tijdens de installatie kan het nodig zijn om administratorrechten te verlenen.

## 🗝️ API Key instellen

Na installatie, volg deze stappen:

1. Open de applicatie "AI File Organizer".
2. Vul je API-sleutel in bij het daarvoor bestemde veld (Gemini, OpenAI of Azure).
3. Selecteer het gewenste AI-model.

## 📁 Bestanden organiseren

- Selecteer een **bronmap** met bestanden die je wilt organiseren.
- Kies een **doelmap** waar bestanden automatisch worden georganiseerd.
- Optioneel: vink aan of bestanden automatisch door AI moeten worden hernoemd.
- Klik op **Start** en de applicatie doet de rest!

## 📑 Logs en monitoring

Tijdens het organiseren toont de applicatie live voortgang en logs. Logs kunnen achteraf worden opgeslagen als tekstbestand.

## 🛠️ Ondersteunde bestandstypen

- PDF (`.pdf`)
- Word-documenten (`.docx`)
- Tekstbestanden (`.txt`, `.md`)

## 📞 Support & Feedback

Heb je hulp nodig of ideeën om de applicatie te verbeteren? Neem gerust contact op via:

- **LinkedIn**: [Remsey Mailjard](https://www.linkedin.com/in/remseymailjard/)
- **Website**: [remsey.nl](https://www.remsey.nl)

Veel plezier met organiseren! 🎉

---

© 2025 Remsey Mailjard | AI File Organizer



================================================
FILE: Models/ApplicationSettings.cs
================================================
﻿using System.Collections.Generic;

namespace AI_FileOrganizer2.Models
{
    public static class ApplicationSettings
    {
        public const int MaxTextLengthForLlm = 30000;
        public const int MinSubfolderNameLength = 3;
        public const int MaxSubfolderNameLength = 50;
        public const int MaxFilenameLength = 100; // Maximum length for AI-generated filename

        public static readonly string[] SupportedExtensions = { ".pdf", ".docx", ".txt", ".md" };

        public static readonly Dictionary<string, string> FolderCategories = new Dictionary<string, string>
            {
                { "Financiën", "1. Financieel" },
                { "Belastingen", "2. Belastingzaken" },
                { "Verzekeringen", "3. Verzekeringen en Polissen" },
                { "Woning", "4. Huis en Wonen" },
                { "Gezondheid en Medisch", "5. Gezondheid en Zorg" },
                { "Familie en Kinderen", "6. Gezin en Familie" },
                { "Voertuigen", "7. Vervoer en Voertuigen" },
                { "Persoonlijke Documenten", "8. Identiteit en Documenten" },
                { "Hobbies en interesses", "9. Vrije Tijd en Hobby's" },
                { "Carrière en Professionele Ontwikkeling", "10. Werk en Loopbaan" },
                { "Bedrijfsadministratie", "11. Zakelijke Administratie" },
                { "Reizen en vakanties", "12. Vakanties en Reizen" }
            };

        public const string FallbackCategoryName = "Diversen";

        public static string FallbackFolderName => $"0. {FallbackCategoryName}";
    }
}


================================================
FILE: Properties/AssemblyInfo.cs
================================================
﻿using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AI-FileOrganizer2")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("AI-FileOrganizer2")]
[assembly: AssemblyCopyright("Copyright ©  2025")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a58ebe3f-c926-432e-b874-ad6f29494ac7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
FILE: Properties/Resources.Designer.cs
================================================
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AI_FileOrganizer2.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("AI_FileOrganizer2.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}



================================================
FILE: Properties/Resources.resx
================================================
﻿<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
FILE: Properties/Settings.Designer.cs
================================================
﻿//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AI_FileOrganizer2.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}



================================================
FILE: Properties/Settings.settings
================================================
﻿<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>



================================================
FILE: Services/AiClassificationService.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO; // Nodig voor Path.GetFileNameWithoutExtension
using System.Linq;
using System.Text.RegularExpressions; // NIEUW: Nodig voor Regex.Replace
using System.Threading;
using System.Threading.Tasks;

using AI_FileOrganizer2.Utils; // Nodig voor FileUtils en ILogger

namespace AI_FileOrganizer2.Services
{
    public class AiClassificationService
    {
        private readonly ILogger _logger;

        private const string DEFAULT_FALLBACK_CATEGORY = "Overig";

        // Nieuwe constanten voor de AI-parameters, per taak
        private const int CATEGORY_MAX_TOKENS = 50;
        private const float CATEGORY_TEMPERATURE = 0.0f; // Lager voor precieze classificatie

        private const int SUBFOLDER_MAX_TOKENS = 20;
        private const float SUBFOLDER_TEMPERATURE = 0.2f; // Iets hoger voor creativiteit, maar nog steeds gericht

        private const int FILENAME_MAX_TOKENS = 30;
        private const float FILENAME_TEMPERATURE = 0.3f; // Nog iets hoger voor creativiteit

        public AiClassificationService(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Helpt bij het voorbereiden van tekst voor de AI door te controleren op zinvolle inhoud.
        /// Geeft een fallback-tekst terug met instructies als de originele tekst niet zinvol is.
        /// </summary>
        /// <param name="extractedText">De reeds geëxtraheerde tekst uit het document.</param>
        /// <param name="originalFilename">De originele bestandsnaam, gebruikt voor fallback context.</param>
        /// <param name="maxLength">Maximale lengte van de tekst die naar de AI wordt gestuurd.</param>
        /// <param name="wasTextMeaningful">Output parameter die aangeeft of de originele tekst zinvol was.</param>
        /// <returns>De tekst die naar de AI moet worden gestuurd.</returns>
        private string GetRelevantTextForAI(string extractedText, string originalFilename, int maxLength, out bool wasTextMeaningful)
        {
            // Controleer of de geëxtraheerde tekst zinvolle karakters bevat na trimmen
            if (string.IsNullOrWhiteSpace(extractedText?.Trim()))
            {
                wasTextMeaningful = false;
                // Geef de AI een expliciete instructie dat er geen tekstinhoud is en dat de focus op de bestandsnaam moet liggen.
                return $"Dit document heeft de bestandsnaam '{Path.GetFileNameWithoutExtension(originalFilename)}'. Er kon geen inhoud uit het document worden geëxtraheerd, of de inhoud was leeg. Analyseer alleen de bestandsnaam en probeer daaruit de essentie te halen.";
            }
            else
            {
                wasTextMeaningful = true;
                // Retourneer een afgekorte versie van de geëxtraheerde tekst
                return extractedText.Substring(0, Math.Min(extractedText.Length, maxLength));
            }
        }


        // ======= Publieke AI-methodes =======

        /// <summary>
        /// Classificeert de categorie van een document op basis van de tekstinhoud of bestandsnaam.
        /// </summary>
        /// <param name="textToClassify">De geëxtraheerde tekstinhoud van het document.</param>
        /// <param name="originalFilename">De originele bestandsnaam van het document. BELANGRIJK: Deze parameter is NIEUW.</param>
        /// <param name="categories">Lijst van mogelijke categorieën.</param>
        /// <param name="aiProvider">De AI-provider om de classificatie uit te voeren.</param>
        /// <param name="modelName">De naam van het AI-model.</param>
        /// <param name="cancellationToken">Token om de operatie te annuleren.</param>
        /// <returns>De geclassificeerde categorienaam.</returns>
        public async Task<string> ClassifyCategoryAsync(
            string textToClassify,
            string originalFilename, // NIEUW: originalFilename is nu een parameter
            List<string> categories,
            IAiProvider aiProvider,
            string modelName,
            CancellationToken cancellationToken)
        {
            if (string.IsNullOrWhiteSpace(textToClassify) && string.IsNullOrWhiteSpace(originalFilename))
            {
                _logger.Log("WAARSCHUWING: Geen tekst en geen bestandsnaam om te classificeren. Retourneer fallback categorie.");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            if (aiProvider == null)
            {
                _logger.Log("FOUT: AI-provider is null voor categorieclassificatie.");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            if (string.IsNullOrWhiteSpace(modelName))
            {
                _logger.Log("FOUT: Modelnaam is leeg voor categorieclassificatie.");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            var validCategories = new List<string>(categories) { DEFAULT_FALLBACK_CATEGORY };
            var categoryListForPrompt = string.Join("\n- ", categories);

            bool wasTextMeaningful;
            string aiInputText = GetRelevantTextForAI(textToClassify, originalFilename, 8000, out wasTextMeaningful);

            string textContext = wasTextMeaningful ?
                $@"<tekst_inhoud>
{aiInputText}
</tekst_inhoud>" :
                $@"<document_zonder_inhoud>
{aiInputText}
</document_zonder_inhode>";

            // AANGEPAST: Few-shot voorbeelden genereren nu ALLEEN de categorienaam.
            var fewShotExamples = @"
Voorbeeld 1:
Tekst: 'Ik heb mijn autoverzekering aangepast bij Interpolis.'
Antwoord: Verzekeringen

Voorbeeld 2:
Tekst: 'Onze zomervakantie naar Spanje is geboekt.'
Antwoord: Reizen en vakanties

Voorbeeld 3:
Tekst: 'Ik heb mijn salaris ontvangen en overgemaakt naar mijn spaarrekening.'
Antwoord: Financiën

Voorbeeld 4:
Tekst: 'De belastingaangifte voor 2022 is binnen.'
Antwoord: Belastingen

Voorbeeld 5:
Bestandsnaam: huwelijksakte_familie_Jansen.pdf
Tekst: Dit document heeft de bestandsnaam 'huwelijksakte_familie_Jansen'. Er kon geen inhoud uit het document worden geëxtraheerd, of de inhoud was leeg. Analyseer alleen de bestandsnaam en probeer daaruit de essentie te halen.
Antwoord: Persoonlijke documenten
";

            var prompt = $@"
Je bent een AI-classificatiemodel. Je taak is om tekstfragmenten te classificeren in één van de exact opgegeven categorieën.
**Retourneer uitsluitend de exacte categorienaam. Absoluut GEEN andere tekst, uitleg, nummering of opmaak (zoals quotes, opsommingstekens, of inleidende zinnen).**
Gebruik de fallbackcategorie als geen enkele andere categorie duidelijk past.

Je krijgt informatie over een document. Kies exact één van de volgende categorieën:

<categories>
- {categoryListForPrompt}
- {DEFAULT_FALLBACK_CATEGORY} (gebruik deze als geen enkele andere categorie duidelijk past)
</categories>

Regels:
- Retourneer **ENKEL EN ALLEEN** één categorie uit bovenstaande lijst.
- **GEEN uitleg, GEEN nummering, GEEN opmaak, GEEN inleidende zinnen (zoals 'De categorie is:').**
- Als meerdere categorieën mogelijk zijn: kies de meest specifieke.
- Gebruik de fallbackcategorie alleen als echt niets past.
- Als het document geen leesbare inhoud heeft (<document_zonder_inhoud>), baseer je dan uitsluitend op de bestandsnaam en de context daarvan.

{fewShotExamples}

Documentinformatie:
<bestandsnaam>
{originalFilename}
</bestandsnaam>

{textContext}

Antwoord: "; // AANGEPAST: Maak de laatste promptregel consistenter met de voorbeelden

            string chosenCategory = null;

            try
            {
                chosenCategory = await aiProvider.GetTextCompletionAsync(
                    prompt,
                    modelName,
                    CATEGORY_MAX_TOKENS,
                    CATEGORY_TEMPERATURE,
                    cancellationToken
                );
            }
            catch (OperationCanceledException)
            {
                _logger.Log("INFO: Categorieclassificatie geannuleerd.");
                throw;
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Fout bij classificatie AI-aanroep: {ex.Message}");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            _logger.Log($"DEBUG: Ruwe AI-antwoord voor categorie: '{chosenCategory?.Replace("\n", "\\n")}'.");

            // GECORRIGEERD: Gebruik Regex.Replace voor case-insensitive vervanging
            if (!string.IsNullOrWhiteSpace(chosenCategory))
            {
                // Verwijder specifieke prefixes die de AI mogelijk nog toevoegt
                chosenCategory = Regex.Replace(chosenCategory, "Antwoord:", "", RegexOptions.IgnoreCase).Trim();
                chosenCategory = Regex.Replace(chosenCategory, "Categorie:", "", RegexOptions.IgnoreCase).Trim();
                // Verwijder eventuele quotes als de AI deze onverhoopt toevoegt
                chosenCategory = chosenCategory.Trim('\'', '\"');
            }


            if (string.IsNullOrWhiteSpace(chosenCategory))
            {
                _logger.Log("WAARSCHUWING: AI retourneerde geen bruikbare categorie (leeg of witruimte). Val terug op default.");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            // `chosenCategory` is al getrimd door de bovenstaande opschoning, maar deze regel kan blijven voor consistentie.
            // chosenCategory = chosenCategory.Trim(); 

            if (validCategories.Contains(chosenCategory))
                return chosenCategory;

            // Verbeterde fuzzy matching: controleer op containment en gelijkenis
            foreach (var validCat in validCategories)
            {
                if (validCat.Equals(chosenCategory, StringComparison.OrdinalIgnoreCase) ||
                    validCat.ToLowerInvariant().Contains(chosenCategory.ToLowerInvariant()) ||
                    chosenCategory.ToLowerInvariant().Contains(validCat.ToLowerInvariant()))
                {
                    _logger.Log($"INFO: Gevonden categorie '{chosenCategory}' fuzzy-matched naar '{validCat}'.");
                    return validCat;
                }
            }

            _logger.Log($"WAARSCHUWING: AI-gekozen categorie '{chosenCategory}' is niet valide en kon niet fuzzy-matched worden. Val terug op default.");
            return DEFAULT_FALLBACK_CATEGORY;
        }


        /// <summary>
        /// Sugereert een submapnaam op basis van de inhoud van een document en de originele bestandsnaam.
        /// </summary>
        public async Task<string> SuggestSubfolderNameAsync(
            string textToAnalyze,
            string originalFilename,
            IAiProvider aiProvider,
            string modelName,
            CancellationToken cancellationToken)
        {
            if (aiProvider == null)
            {
                _logger.Log("FOUT: AI-provider is null voor submapnaam-suggestie.");
                return null;
            }

            if (string.IsNullOrWhiteSpace(modelName))
            {
                _logger.Log("FOUT: Modelnaam is leeg voor submapnaam-suggestie.");
                return null;
            }

            bool wasTextMeaningful;
            string aiInputText = GetRelevantTextForAI(textToAnalyze, originalFilename, 2000, out wasTextMeaningful); // Max 2000 chars

            // Pas de prompt aan op basis van de aanwezigheid van zinvolle tekst
            string textContext = wasTextMeaningful ?
                $@"<tekst_inhoud>
{aiInputText}
</tekst_inhoud>" :
                $@"<document_zonder_inhoud>
{aiInputText}
</document_zonder_inhoud>";


            var prompt = $@"
### SYSTEM INSTRUCTIE
Je bent een AI-assistent die helpt bij het organiseren van documenten in logische mappen. 
Je taak is om een **korte en beschrijvende submapnaam** te suggereren op basis van de documentinhoud of de bestandsnaam als fallback.

### INSTRUCTIES
- Gebruik maximaal **5 woorden**.
- Vat het hoofdonderwerp of doel van het document bondig samen.
- Vermijd generieke termen zoals 'document', 'info', 'bestand', 'overig' of alleen een datum.
- Gebruik bij voorkeur betekenisvolle termen zoals 'Belastingaangifte 2023' of 'CV Jan Jansen'.
- **GEEF ENKEL DE SUBMAPNAAM TERUG – GEEN uitleg, GEEN opmaak, GEEN opsomming, GEEN quotes of padscheidingstekens, GEEN inleidende zinnen (zoals 'De submapnaam is:').**
- Als het document geen leesbare inhoud heeft (<document_zonder_inhoud>), focus dan op de originele bestandsnaam en de algemene beschrijving in dat blok.

### FEW-SHOT VOORBEELDEN
<voorbeeld>
Bestandsnaam: jaaropgave_2023_ing.pdf  
Tekst: Dit document betreft uw jaarlijkse jaaropgave voor belastingdoeleinden...  
Antwoord: Jaaropgave ING 2023
</voorbeeld>

<voorbeeld>
Bestandsnaam: cv_jan.docx  
Tekst: Curriculum Vitae van Jan Jansen met werkervaring in IT...  
Antwoord: CV Jan Jansen
</voorbeeld>

<voorbeeld>
Bestandsnaam: offerte_hypotheek_rabobank.pdf  
Tekst: Geachte heer, hierbij ontvangt u uw hypotheekofferte...  
Antwoord: Hypotheekofferte Rabobank
</voorbeeld>

<voorbeeld>
Bestandsnaam: huwelijksakte_piet_en_nel_2023.pdf
Tekst: Dit document heeft de bestandsnaam 'huwelijksakte_piet_en_nel_2023'. Er kon geen inhoud uit het document worden geëxtraheerd, of de inhoud was leeg. Analyseer alleen de bestandsnaam en probeer daaruit de essentie te halen.
Antwoord: Huwelijksakte Piet en Nel
</voorbeeld>

### INPUT
<bestandsnaam>
{originalFilename}
</bestandsnaam>

{textContext}

Antwoord: "; // AANGEPAST: Maak de laatste promptregel consistenter met de voorbeelden

            string suggestedName = null;

            try
            {
                suggestedName = await aiProvider.GetTextCompletionAsync(
                    prompt,
                    modelName,
                    SUBFOLDER_MAX_TOKENS,
                    SUBFOLDER_TEMPERATURE,
                    cancellationToken
                );
            }
            catch (OperationCanceledException)
            {
                _logger.Log($"INFO: Submapnaam AI-suggestie voor '{originalFilename}' geannuleerd.");
                throw;
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Fout bij submapnaam AI-aanroep voor '{originalFilename}': {ex.Message}");
                return null;
            }

            _logger.Log($"DEBUG: Ruwe AI-antwoord voor submapnaam: '{suggestedName?.Replace("\n", "\\n")}'.");

            // GECORRIGEERD: Gebruik Regex.Replace voor case-insensitive vervanging
            if (!string.IsNullOrWhiteSpace(suggestedName))
            {
                suggestedName = Regex.Replace(suggestedName, "Antwoord:", "", RegexOptions.IgnoreCase).Trim();
                suggestedName = suggestedName.Trim('\'', '\"');
            }

            string cleaned = FileUtils.SanitizeFolderOrFileName(suggestedName?.Trim() ?? "");
            var generiek = new[] { "document", "bestand", "info", "overig", "algemeen", "diversen", "" };

            // Controleer of de eerste AI-suggestie bruikbaar is.
            bool needsRetry = string.IsNullOrWhiteSpace(cleaned) || cleaned.Length < 3 || generiek.Contains(cleaned.ToLowerInvariant());

            if (needsRetry)
            {
                _logger.Log($"INFO: Eerste AI-suggestie '{suggestedName?.Trim() ?? "[LEEG]"}' voor '{originalFilename}' was onbruikbaar (leeg/te kort/generiek). Start retry...");

                // Sterkere retry prompt om de AI te dwingen een bruikbare naam te geven.
                var retryPrompt = prompt + "\n\nDe vorige suggestie was niet bruikbaar. Denk goed na en geef nu alsnog een CONCRETE, KORTE EN BESCHRIJVENDE mapnaam. De output moet DIRECT de naam zijn.";
                try
                {
                    suggestedName = await aiProvider.GetTextCompletionAsync(
                        retryPrompt,
                        modelName,
                        SUBFOLDER_MAX_TOKENS,
                        SUBFOLDER_TEMPERATURE,
                        cancellationToken
                    );

                    _logger.Log($"DEBUG: Ruwe AI-antwoord voor submapnaam (retry): '{suggestedName?.Replace("\n", "\\n")}'.");
                    // GECORRIGEERD: Opschoning na retry met Regex.Replace
                    if (!string.IsNullOrWhiteSpace(suggestedName))
                    {
                        suggestedName = Regex.Replace(suggestedName, "Antwoord:", "", RegexOptions.IgnoreCase).Trim();
                        suggestedName = suggestedName.Trim('\'', '\"');
                    }
                    cleaned = FileUtils.SanitizeFolderOrFileName(suggestedName?.Trim() ?? "");
                }
                catch (Exception ex)
                {
                    _logger.Log($"FOUT: Retry submapnaam faalde voor '{originalFilename}': {ex.Message}");
                }
            }

            // Finale validatie na (eventuele) retry
            if (string.IsNullOrWhiteSpace(cleaned) || cleaned.Length < 3 || generiek.Contains(cleaned.ToLowerInvariant()))
            {
                _logger.Log($"INFO: AI faalde voor '{originalFilename}' na retry of initieel. Probeer patroon-gebaseerde fallback...");

                cleaned = FileUtils.FallbackFolderNameFromFilename(originalFilename);

                if (string.IsNullOrWhiteSpace(cleaned))
                {
                    _logger.Log($"WAARSCHUWING: Geen bruikbare submapnaam gevonden voor '{originalFilename}'. Bestand blijft mogelijk in hoofdmap van de categorie.");
                    return null; // Geen bruikbare submapnaam, laat hoger niveau bepalen
                }
            }

            // Zet naar title case voor consistentie
            return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(cleaned.ToLowerInvariant());
        }


        /// <summary>
        /// Sugereert een nieuwe bestandsnaam op basis van de inhoud van een document en de originele bestandsnaam.
        /// </summary>
        public async Task<string> SuggestFileNameAsync(
            string textToAnalyze,
            string originalFilename,
            IAiProvider aiProvider,
            string modelName,
            CancellationToken cancellationToken)
        {
            if (aiProvider == null)
            {
                _logger.Log("FOUT: AI-provider is null voor bestandsnaam-suggestie.");
                return Path.GetFileNameWithoutExtension(originalFilename); // Fallback gracefully
            }
            if (string.IsNullOrWhiteSpace(modelName))
            {
                _logger.Log("FOUT: Modelnaam is leeg voor bestandsnaam-suggestie.");
                return Path.GetFileNameWithoutExtension(originalFilename); // Fallback gracefully
            }

            bool wasTextMeaningful;
            string aiInputText = GetRelevantTextForAI(textToAnalyze, originalFilename, 2000, out wasTextMeaningful); // Max 2000 chars

            string textContext = wasTextMeaningful ?
                $@"<tekst_inhoud>
{aiInputText}
</tekst_inhoud>" :
                $@"<document_zonder_inhoud>
{aiInputText}
</document_zonder_inhoud>";


            var prompt = $@"
Je bent een AI-assistent die helpt bij het organiseren van bestanden.
Analyseer de volgende informatie over een document (oorspronkelijke bestandsnaam: ""{originalFilename}"") en stel een KORTE, BESCHRIJVENDE bestandsnaam voor (maximaal 10 woorden).
Deze bestandsnaam moet het hoofdonderwerp of de essentie van het document samenvatten, zonder de bestandsextensie.
Gebruik geen ongeldige karakters voor bestandsnamen.
Voorbeelden: ""Jaarverslag 2023 Hypotheekofferte Rabobank"", ""Notulen Project X"", ""CV Jan Jansen"".
Vermijd generieke namen zoals ""Document"", ""Bestand"", ""Info"", ""Factuur"" of simpelweg een datum zonder context.
**Geef ALLEEN de voorgestelde bestandsnaam terug, zonder extra uitleg of opmaak, en ZONDER quotes of extensie, en GEEN inleidende zinnen (zoals 'De bestandsnaam is:').**
Als het document geen leesbare inhoud heeft (<document_zonder_inhoud>), focus dan op de originele bestandsnaam en de algemene beschrijving in dat blok.

<bestandsnaam>
{originalFilename}
</bestandsnaam>

{textContext}

Antwoord: "; // AANGEPAST: Maak de laatste promptregel consistenter met de voorbeelden

            string suggestedName = null;
            try
            {
                suggestedName = await aiProvider.GetTextCompletionAsync(
                    prompt,
                    modelName,
                    FILENAME_MAX_TOKENS,
                    FILENAME_TEMPERATURE,
                    cancellationToken
                );
            }
            catch (OperationCanceledException)
            {
                _logger.Log($"INFO: Bestandsnaam AI-suggestie voor '{originalFilename}' geannuleerd.");
                throw; // Propagate cancellation
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Fout bij bestandsnaam AI-aanroep voor '{originalFilename}': {ex.Message}");
                return Path.GetFileNameWithoutExtension(originalFilename); // Fallback on error
            }

            _logger.Log($"DEBUG: Ruwe AI-antwoord voor bestandsnaam: '{suggestedName?.Replace("\n", "\\n")}'.");

            // GECORRIGEERD: Gebruik Regex.Replace voor case-insensitive vervanging
            if (!string.IsNullOrWhiteSpace(suggestedName))
            {
                suggestedName = Regex.Replace(suggestedName, "Antwoord:", "", RegexOptions.IgnoreCase).Trim();
                suggestedName = suggestedName.Trim('\'', '\"');
            }


            if (string.IsNullOrWhiteSpace(suggestedName))
            {
                _logger.Log($"WAARSCHUWING: AI retourneerde geen bruikbare bestandsnaam (leeg of witruimte) voor '{originalFilename}'. Gebruik originele naam.");
                return Path.GetFileNameWithoutExtension(originalFilename);
            }

            string cleanedName = FileUtils.SanitizeFolderOrFileName(suggestedName?.Trim() ?? "");

            var genericNames = new[] { "document", "bestand", "info", "overig", "algemeen", "factuur", "" };
            if (cleanedName.Length < 3 || genericNames.Contains(cleanedName.ToLowerInvariant()))
            {
                _logger.Log($"WAARSCHUWING: AI-suggestie '{suggestedName?.Trim() ?? "[LEEG]"}' voor '{originalFilename}' is te kort of te generiek na opschonen. Gebruik originele naam.");
                return Path.GetFileNameWithoutExtension(originalFilename);
            }

            // Apply max length constraint
            if (cleanedName.Length > 100) // Hardcoded max length for filenames, adjust as needed
            {
                cleanedName = cleanedName.Substring(0, 100);
                _logger.Log($"INFO: AI-gegenereerde bestandsnaam voor '{originalFilename}' afgekort naar '{cleanedName}' wegens lengtebeperking.");
            }

            return cleanedName;
        }
    }
}


================================================
FILE: Services/AzureOpenAiProvider.cs
================================================
﻿// AI_FileOrganizer2/Services/AzureOpenAiProvider.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.OpenAI;
using Azure.AI.OpenAI.Chat;
using OpenAI.Chat;

namespace AI_FileOrganizer2.Services
{
    public class AzureOpenAiProvider : IAiProvider
    {
        private readonly Uri _azureEndpoint;
        private readonly string _apiKey;

        public AzureOpenAiProvider(string azureEndpoint, string apiKey)
        {
            if (string.IsNullOrWhiteSpace(azureEndpoint) || !Uri.TryCreate(azureEndpoint, UriKind.Absolute, out _azureEndpoint))
                throw new ArgumentException("Ongeldig Azure Endpoint URL.", nameof(azureEndpoint));

            if (string.IsNullOrWhiteSpace(apiKey))
                throw new ArgumentException("API key voor Azure OpenAI mag niet leeg zijn.", nameof(apiKey));

            _apiKey = apiKey;
        }

        public async Task<string> GetTextCompletionAsync(string prompt, string modelName, int maxTokens, float temperature, CancellationToken cancellationToken)
        {
            // === Validatie ===
            if (string.IsNullOrWhiteSpace(prompt))
                throw new ArgumentException("De prompt mag niet leeg zijn.", nameof(prompt));
            if (string.IsNullOrWhiteSpace(modelName))
                throw new ArgumentException("Modelnaam mag niet leeg zijn.", nameof(modelName));
            if (maxTokens <= 0 || maxTokens > 4096)
                throw new ArgumentOutOfRangeException(nameof(maxTokens), "maxTokens moet tussen 1 en 4096 zijn.");
            if (temperature < 0 || temperature > 1)
                throw new ArgumentOutOfRangeException(nameof(temperature), "temperature moet tussen 0.0 en 1.0 zijn.");

            try
            {
                var azureClient = new AzureOpenAIClient(_azureEndpoint, new AzureKeyCredential(_apiKey));
                var chatClient = azureClient.GetChatClient(modelName);

                var messages = new List<ChatMessage>
                {
                    new UserChatMessage(prompt)
                };

                var chatCompletionOptions = new ChatCompletionOptions
                {
                    Temperature = temperature,
                    MaxOutputTokenCount = maxTokens
                };

                var completion = await chatClient.CompleteChatAsync(messages, chatCompletionOptions, cancellationToken);

                var firstContent = completion.Value.Content.FirstOrDefault();
                if (firstContent != null && !string.IsNullOrWhiteSpace(firstContent.Text))
                    return firstContent.Text.Trim();

                return null;
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (RequestFailedException ex)
            {
                Console.WriteLine($"[AzureOpenAiProvider] Azure API-fout: {ex.Message}");
                return null;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[AzureOpenAiProvider] Algemene fout: {ex.Message}");
                return null;
            }
        }
    }
}



================================================
FILE: Services/CredentialStorageService.cs
================================================
﻿// AI_FileOrganizer2/Services/CredentialStorageService.cs
using System;
using CredentialManagement; // Vereist de CredentialManagement NuGet-package
using AI_FileOrganizer2.Utils; // Voor ILogger
using Newtonsoft.Json; // Voor het serialiseren van Azure-gegevens

namespace AI_FileOrganizer2.Services
{
    public class CredentialStorageService
    {
        private readonly ILogger _logger;
        private const string AppPrefix = "AIFileOrganizer."; // Unieke prefix voor onze referenties

        public CredentialStorageService(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Slaat een API-sleutel en optioneel een Azure Endpoint op in de Windows Credential Manager.
        /// De sleutel wordt opgeslagen als een credential voor de lokale gebruiker.
        /// </summary>
        /// <param name="providerName">De naam van de provider (bijv. "Gemini (Google)", "Azure OpenAI").</param>
        /// <param name="apiKey">De API-sleutel.</param>
        /// <param name="azureEndpoint">Optioneel: Het Azure Endpoint voor Azure OpenAI.</param>
        public void SaveApiKey(string providerName, string apiKey, string azureEndpoint = null)
        {
            if (string.IsNullOrWhiteSpace(providerName))
            {
                _logger.Log("FOUT bij opslaan API-sleutel: Providernaam is leeg.");
                return;
            }
            if (string.IsNullOrWhiteSpace(apiKey))
            {
                _logger.Log($"WAARSCHUWING bij opslaan API-sleutel voor '{providerName}': API-sleutel is leeg. Verwijder bestaande.");
                DeleteApiKey(providerName); // Verwijder indien de sleutel wordt gewist
                return;
            }

            try
            {
                using (var credential = new Credential())
                {
                    credential.Target = GetCredentialTarget(providerName);
                    credential.Username = providerName; // Username kan de provider naam zijn, of leeg

                    if (!string.IsNullOrWhiteSpace(azureEndpoint))
                    {
                        // Voor Azure, combineer sleutel en endpoint in een JSON-string in het wachtwoordveld
                        var azureConfig = new { ApiKey = apiKey, Endpoint = azureEndpoint };
                        credential.Password = JsonConvert.SerializeObject(azureConfig);
                        credential.Type = CredentialType.Generic;
                    }
                    else
                    {
                        credential.Password = apiKey;
                        credential.Type = CredentialType.Generic; // Kan ook NetworkPassword zijn, maar Generic is flexibeler
                    }

                    credential.PersistanceType = PersistanceType.LocalComputer; // Alleen voor de huidige gebruiker

                    credential.Save(); // Slaat de referentie op
                    _logger.Log($"INFO: API-sleutel voor '{providerName}' succesvol opgeslagen.");
                }
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT bij opslaan API-sleutel voor '{providerName}': {ex.Message}");
            }
        }

        /// <summary>
        /// Haalt een API-sleutel en optioneel Azure Endpoint op uit de Windows Credential Manager.
        /// </summary>
        /// <param name="providerName">De naam van de provider.</param>
        /// <returns>Een tuple (APIKey, AzureEndpoint), of (null, null) indien niet gevonden of fout.</returns>
        public (string ApiKey, string AzureEndpoint) GetApiKey(string providerName)
        {
            if (string.IsNullOrWhiteSpace(providerName))
            {
                _logger.Log("FOUT bij ophalen API-sleutel: Providernaam is leeg.");
                return (null, null);
            }

            try
            {
                using (var credential = new Credential())
                {
                    credential.Target = GetCredentialTarget(providerName);
                    credential.Load(); // Laadt de referentie

                    if (credential.Type == CredentialType.Generic && credential.Password.StartsWith("{") && credential.Password.Contains("ApiKey"))
                    {
                        // Dit is waarschijnlijk een Azure-configuratie (JSON)
                        var azureConfig = JsonConvert.DeserializeAnonymousType(credential.Password, new { ApiKey = "", Endpoint = "" });
                        _logger.Log($"INFO: Azure-configuratie voor '{providerName}' succesvol geladen.");
                        return (azureConfig.ApiKey, azureConfig.Endpoint);
                    }
                    else
                    {
                        _logger.Log($"INFO: API-sleutel voor '{providerName}' succesvol geladen.");
                        return (credential.Password, null); // Retourneer alleen de sleutel
                    }
                }
            }

            catch (Exception ex)
            {
                _logger.Log($"FOUT bij ophalen API-sleutel voor '{providerName}': {ex.Message}");
                return (null, null);
            }
        }

        /// <summary>
        /// Verwijdert een opgeslagen API-sleutel uit de Windows Credential Manager.
        /// </summary>
        /// <param name="providerName">De naam van de provider.</param>
        public void DeleteApiKey(string providerName)
        {
            if (string.IsNullOrWhiteSpace(providerName)) return;

            try
            {
                using (var credential = new Credential())
                {
                    credential.Target = GetCredentialTarget(providerName);
                    credential.Delete(); // Verwijdert de referentie
                    _logger.Log($"INFO: API-sleutel voor '{providerName}' succesvol verwijderd.");
                }
            }
          //  catch (Exception ex)
        //    {
                // Al niet aanwezig, dat is prima
           //     _logger.Log($"INFO: API-sleutel voor '{providerName}' was niet aanwezig om te verwijderen.");
       //     }
            catch (Exception ex)
            {
                _logger.Log($"FOUT bij verwijderen API-sleutel voor '{providerName}': {ex.Message}");
            }
        }

        private string GetCredentialTarget(string providerName)
        {
            return AppPrefix + providerName.Replace(" ", "").Replace("(", "").Replace(")", "").Replace(".", ""); // Maak een veilige target naam
        }
    }
}


================================================
FILE: Services/DocxTextExtractor.cs
================================================
﻿// AI_FileOrganizer2/Services/DocxTextExtractor.cs
using System;
using System.IO;
using System.Linq;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;
using DocumentFormat.OpenXml; // Voor OpenXmlPackageException
using AI_FileOrganizer2.Utils; // Voor ILogger

namespace AI_FileOrganizer2.Services
{
    public class DocxTextExtractor : ITextExtractor
    {
        private readonly ILogger _logger;

        public DocxTextExtractor(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public bool CanExtract(string filePath)
        {
            return Path.GetExtension(filePath).Equals(".docx", StringComparison.OrdinalIgnoreCase);
        }

        public string Extract(string filePath)
        {
            try
            {
                if (!File.Exists(filePath))
                {
                    _logger.Log($"WAARSCHUWING: Bestand niet gevonden voor DOCX-extractie: '{Path.GetFileName(filePath)}'.");
                    return string.Empty;
                }

                using (WordprocessingDocument wordDoc = WordprocessingDocument.Open(filePath, false)) // Openen in read-only modus
                {
                    Body body = wordDoc.MainDocumentPart?.Document?.Body;
                    if (body != null)
                    {
                        // Gebruik Environment.NewLine voor consistentie en trim elke paragraaf
                        return string.Join(Environment.NewLine, body.Elements<Paragraph>().Select(p => p.InnerText.Trim())).Trim();
                    }
                }
            }
            catch (OpenXmlPackageException oxmlEx)
            {
                _logger.Log($"FOUT: Beschadigd DOCX-bestand '{Path.GetFileName(filePath)}' bij extractie: {oxmlEx.Message}");
                return string.Empty;
            }
            catch (UnauthorizedAccessException uaEx)
            {
                _logger.Log($"FOUT: Toegang geweigerd tot DOCX-bestand '{Path.GetFileName(filePath)}': {uaEx.Message}");
                return string.Empty;
            }
            catch (IOException ioEx) when ((ioEx.HResult & 0xFFFF) == 32) // ERROR_SHARING_VIOLATION
            {
                _logger.Log($"WAARSCHUWING: Bestand '{Path.GetFileName(filePath)}' is vergrendeld en kan niet worden gelezen voor DOCX-extractie.");
                return string.Empty;
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Onbekende fout bij DOCX-extractie van '{Path.GetFileName(filePath)}': {ex.Message}");
                return string.Empty;
            }
            return string.Empty; // In geval van een onverwachte codepad zonder return
        }
    }
}


================================================
FILE: Services/FileOrganizerService.cs
================================================
﻿using AI_FileOrganizer2.Models; // For ApplicationSettings
using AI_FileOrganizer2.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms; // Needed for DialogResult

namespace AI_FileOrganizer2.Services
{
    public class FileOrganizerService
    {
        private readonly ILogger _logger;
        private readonly AiClassificationService _aiService;
        private readonly TextExtractionService _textExtractionService;
        private readonly CredentialStorageService _credentialStorageService;
        private readonly HttpClient _httpClient; // Shared HttpClient for AI providers

        // Events for UI updates
        public event Action<int, int> ProgressChanged; // (currentFileIndex, totalFiles)
        public event Action<long> TokensUsedUpdated; // (totalTokensUsed)
        // Callback for interactive rename. Returns (DialogResult, newFileName, skipFile)
        public event Func<string, string, Task<(DialogResult result, string newFileName, bool skipFile)>> RequestRenameFile;

        // Note: _totalTokensUsed tracking needs to be properly implemented within IAiProvider for accurate reporting.
        // For now, it's a placeholder.
        private long _totalTokensUsed = 0;

        public FileOrganizerService(
            ILogger logger,
            AiClassificationService aiService,
            TextExtractionService textExtractionService,
            CredentialStorageService credentialStorageService,
            HttpClient httpClient)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _aiService = aiService ?? throw new ArgumentNullException(nameof(aiService));
            _textExtractionService = textExtractionService ?? throw new ArgumentNullException(nameof(textExtractionService));
            _credentialStorageService = credentialStorageService ?? throw new ArgumentNullException(nameof(credentialStorageService));
            _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
        }

        /// <summary>
        /// Orchestrates the main file organization process.
        /// </summary>
        public async Task OrganizeFilesAsync(string sourcePath, string destinationBasePath, string apiKey, string providerName, string modelName, string azureEndpoint, bool shouldRenameFiles, CancellationToken cancellationToken)
        {
            _totalTokensUsed = 0; // Reset token counter for each new run
            TokensUsedUpdated?.Invoke(_totalTokensUsed);

            IAiProvider currentAiProvider = GetAiProvider(apiKey, providerName, azureEndpoint);
            if (currentAiProvider == null) return; // Error already logged by GetAiProvider

            // Save API key using the credential storage service
            _credentialStorageService.SaveApiKey(providerName, apiKey, azureEndpoint);

            // Ensure destination base path exists
            if (!Directory.Exists(destinationBasePath))
            {
                try
                {
                    Directory.CreateDirectory(destinationBasePath);
                    _logger.Log($"[MAP] Basisdoelmap '{destinationBasePath}' aangemaakt.");
                }
                catch (Exception ex)
                {
                    _logger.Log($"FOUT: Fout bij aanmaken basisdoelmap '{destinationBasePath}': {ex.Message}");
                    return;
                }
            }

            var allFiles = Directory.EnumerateFiles(sourcePath, "*", SearchOption.AllDirectories)
                                    .Where(f => ApplicationSettings.SupportedExtensions.Contains(Path.GetExtension(f).ToLower()))
                                    .ToList();

            int processedCount = 0;
            int movedFiles = 0;
            int filesWithSubfolders = 0;
            int renamedFiles = 0;

            ProgressChanged?.Invoke(0, allFiles.Count);

            foreach (string filePath in allFiles)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    cancellationToken.ThrowIfCancellationRequested(); // Propagate cancellation
                }

                var fileInfo = new FileInfo(filePath);
                processedCount++;
                _logger.Log($"\n[BESTAND] Verwerken van: {fileInfo.Name} (locatie: {Path.GetDirectoryName(filePath)})");

                try
                {
                    var (processed, moved, hadSubfolder, renamed) = await ProcessAndMoveSingleFileInternalAsync(
                        filePath,
                        fileInfo,
                        sourcePath,
                        destinationBasePath,
                        currentAiProvider,
                        modelName,
                        shouldRenameFiles,
                        cancellationToken);

                    if (processed)
                    {
                        if (moved) movedFiles++;
                        if (hadSubfolder) filesWithSubfolders++;
                        if (renamed) renamedFiles++;
                    }
                }
                catch (OperationCanceledException)
                {
                    throw; // Important: rethrow to be caught by Form1's main try-catch
                }
                catch (Exception ex)
                {
                    _logger.Log($"FOUT: Fout bij verwerken van {fileInfo.Name}: {ex.Message}");
                }
                finally
                {
                    ProgressChanged?.Invoke(processedCount, allFiles.Count);
                }
            }

            _logger.Log($"\nTotaal aantal bestanden bekeken (met ondersteunde extensie): {processedCount}");
            _logger.Log($"Aantal bestanden succesvol verplaatst: {movedFiles}");
            _logger.Log($"Aantal bestanden geplaatst in een AI-gegenereerde submap: {filesWithSubfolders}");
            _logger.Log($"Aantal bestanden hernoemd: {renamedFiles}");
        }

        /// <summary>
        /// Handles interactive renaming of a single selected file.
        /// </summary>
        public async Task RenameSingleFileInteractiveAsync(string filePath, string apiKey, string providerName, string modelName, string azureEndpoint, CancellationToken cancellationToken)
        {
            _totalTokensUsed = 0; // Reset tokens for single operation
            TokensUsedUpdated?.Invoke(_totalTokensUsed);

            IAiProvider currentAiProvider = GetAiProvider(apiKey, providerName, azureEndpoint);
            if (currentAiProvider == null) return; // Error already logged

            _credentialStorageService.SaveApiKey(providerName, apiKey, azureEndpoint);

            if (!File.Exists(filePath))
            {
                _logger.Log($"FOUT: Bestand niet gevonden voor hernoemen: '{Path.GetFileName(filePath)}'.");
                return;
            }

            FileInfo fileInfo = new FileInfo(filePath);
            _logger.Log($"\n[BESTAND] Voorbereiden van hernoemen voor: {fileInfo.Name}");

            try
            {
                string extractedText = _textExtractionService.ExtractText(filePath);
                _logger.Log($"Extractedtext: '{extractedText}'...");
                if (string.IsNullOrWhiteSpace(extractedText))
                {
                    _logger.Log($"INFO: Geen zinvolle tekst geëxtraheerd uit {fileInfo.Name}. Gebruik bestandsnaam als context.");
                    extractedText = fileInfo.Name;
                }
                if (extractedText.Length > ApplicationSettings.MaxTextLengthForLlm)
                {
                    _logger.Log($"WAARSCHUWING: Tekstlengte voor '{fileInfo.Name}' overschrijdt {ApplicationSettings.MaxTextLengthForLlm} tekens. Tekst wordt afgekapt.");
                    extractedText = extractedText.Substring(0, ApplicationSettings.MaxTextLengthForLlm);
                }

                _logger.Log($"INFO: AI-bestandsnaam genereren voor '{fileInfo.Name}'...");
                string suggestedNewBaseName = await _aiService.SuggestFileNameAsync(
                    extractedText,
                    fileInfo.Name,
                    currentAiProvider,
                    modelName,
                    cancellationToken
                );

                // Request UI interaction for rename
                if (RequestRenameFile == null)
                {
                    _logger.Log("FOUT: UI callback voor hernoemen is niet ingesteld. Kan bestand niet interactief hernoemen.");
                    return;
                }

                var (dialogResult, returnedFileName, skipFile) = await RequestRenameFile.Invoke(fileInfo.Name, suggestedNewBaseName + fileInfo.Extension);

                if (dialogResult == DialogResult.OK)
                {
                    if (skipFile)
                    {
                        _logger.Log($"INFO: Gebruiker koos om '{fileInfo.Name}' niet te hernoemen. Geen actie ondernomen.");
                    }
                    else
                    {
                        string proposedFullName = returnedFileName;
                        string proposedBaseName = Path.GetFileNameWithoutExtension(proposedFullName);
                        string proposedExtension = Path.GetExtension(proposedFullName);

                        if (string.IsNullOrEmpty(proposedExtension))
                        {
                            proposedFullName = proposedBaseName + fileInfo.Extension;
                        }
                        else if (proposedExtension.ToLower() != fileInfo.Extension.ToLower())
                        {
                            _logger.Log($"WAARSCHUWING: Bestandsnaam '{proposedFullName}' heeft afwijkende extensie. Originele extensie '{fileInfo.Extension}' behouden.");
                            proposedFullName = proposedBaseName + fileInfo.Extension;
                        }

                        string newFileName = FileUtils.SanitizeFileName(proposedFullName);

                        string baseNameWithoutExt = Path.GetFileNameWithoutExtension(newFileName);
                        string extension = Path.GetExtension(newFileName);
                        if (baseNameWithoutExt.Length > ApplicationSettings.MaxFilenameLength)
                        {
                            baseNameWithoutExt = baseNameWithoutExt.Substring(0, ApplicationSettings.MaxFilenameLength);
                            newFileName = baseNameWithoutExt + extension;
                            _logger.Log($"WAARSCHUWING: Nieuwe bestandsnaam te lang. Afgekapt naar '{newFileName}'.");
                        }

                        if (newFileName != fileInfo.Name)
                        {
                            string destinationFilePath = Path.Combine(Path.GetDirectoryName(filePath), newFileName);

                            if (File.Exists(destinationFilePath))
                            {
                                string baseNameConflict = Path.GetFileNameWithoutExtension(newFileName);
                                string extensionConflict = Path.GetExtension(newFileName);
                                int counter = 1;
                                string uniqueDestinationFilePath = destinationFilePath;
                                while (File.Exists(uniqueDestinationFilePath))
                                {
                                    uniqueDestinationFilePath = Path.Combine(Path.GetDirectoryName(filePath), $"{baseNameConflict}_{counter}{extensionConflict}");
                                    counter++;
                                }
                                _logger.Log($"INFO: Bestand '{newFileName}' bestaat al. Hernoemd naar '{Path.GetFileName(uniqueDestinationFilePath)}' om conflict te voorkomen.");
                                destinationFilePath = uniqueDestinationFilePath;
                            }

                            File.Move(filePath, destinationFilePath);
                            _logger.Log($"OK: '{fileInfo.Name}' hernoemd naar '{Path.GetFileName(destinationFilePath)}'.");
                        }
                        else
                        {
                            _logger.Log($"INFO: AI-suggestie was gelijk aan origineel of ongeldig na opschonen. '{fileInfo.Name}' niet hernoemd.");
                        }
                    }
                }
                else
                {
                    _logger.Log($"INFO: Hernoem-actie voor '{fileInfo.Name}' geannuleerd door gebruiker. Geen actie ondernomen.");
                }
            }
            catch (OperationCanceledException)
            {
                _logger.Log("Hernoem-actie geannuleerd.");
                throw; // Propagate cancellation
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Fout bij hernoemen van {fileInfo.Name}: {ex.Message}");
            }
            finally
            {
                _logger.Log("\nEnkel bestand hernoemen voltooid.");
            }
        }


        /// <summary>
        /// Helper method to process a single file: extract, classify, suggest subfolder/filename, and move.
        /// Returns (wasProcessed, wasMoved, hadSubfolder, wasRenamed)
        /// </summary>
        private async Task<(bool processed, bool moved, bool hadSubfolder, bool renamed)> ProcessAndMoveSingleFileInternalAsync(
            string filePath,
            FileInfo fileInfo,
            string sourcePath,
            string destinationBasePath,
            IAiProvider currentAiProvider,
            string modelName,
            bool shouldRenameFiles,
            CancellationToken cancellationToken)
        {
            string extractedText = _textExtractionService.ExtractText(filePath);

            if (string.IsNullOrWhiteSpace(extractedText))
            {
                _logger.Log($"INFO: Geen zinvolle tekst geëxtraheerd uit {fileInfo.Name}. Bestand wordt behandeld met bestandsnaam context (als fallback).");
                extractedText = fileInfo.Name; // Use filename as minimal context
            }

            if (extractedText.Length > ApplicationSettings.MaxTextLengthForLlm)
            {
                _logger.Log($"WAARSCHUWING: Tekstlengte voor '{fileInfo.Name}' overschrijdt {ApplicationSettings.MaxTextLengthForLlm} tekens. Tekst wordt afgekapt.");
                extractedText = extractedText.Substring(0, ApplicationSettings.MaxTextLengthForLlm);
            }

            string llmCategoryChoice = await _aiService.ClassifyCategoryAsync(
                extractedText,
                filePath,
                ApplicationSettings.FolderCategories.Keys.ToList(),
                currentAiProvider,
                modelName,
                cancellationToken
            );

            if (string.IsNullOrWhiteSpace(llmCategoryChoice))
            {
                _logger.Log($"WAARSCHUWING: Kon '{fileInfo.Name}' niet classificeren met AI (retourneerde leeg of None). Bestand wordt niet verplaatst.");
                return (false, false, false, false);
            }

            string targetCategoryFolderName = ApplicationSettings.FolderCategories.ContainsKey(llmCategoryChoice)
                ? ApplicationSettings.FolderCategories[llmCategoryChoice]
                : ApplicationSettings.FallbackFolderName;
            string targetCategoryFolderPath = Path.Combine(destinationBasePath, targetCategoryFolderName);
            Directory.CreateDirectory(targetCategoryFolderPath); // Ensure the category folder exists

            string aiSuggestedSubfolderName = null;
            bool hadSubfolder = false;

            _logger.Log($"INFO: Poging tot genereren submapnaam voor '{fileInfo.Name}'...");
            string subfolderNameSuggestion = await _aiService.SuggestSubfolderNameAsync(
                extractedText,
                fileInfo.Name,
                currentAiProvider,
                modelName,
                cancellationToken
            );

            if (!string.IsNullOrWhiteSpace(subfolderNameSuggestion))
            {
                subfolderNameSuggestion = FileUtils.SanitizeFolderOrFileName(subfolderNameSuggestion);
                if (subfolderNameSuggestion.Length < ApplicationSettings.MinSubfolderNameLength || subfolderNameSuggestion.Length > ApplicationSettings.MaxSubfolderNameLength)
                {
                    _logger.Log($"WAARSCHUWING: AI-gegenereerde submapnaam '{subfolderNameSuggestion}' is ongeldig (lengte). Wordt niet gebruikt.");
                    subfolderNameSuggestion = null; // Set to null if invalid to trigger fallback
                }
            }

            if (!string.IsNullOrWhiteSpace(subfolderNameSuggestion))
            {
                aiSuggestedSubfolderName = subfolderNameSuggestion; // Store the validated AI-suggested name
                _logger.Log($"INFO: AI suggereerde submap: '{aiSuggestedSubfolderName}'");
                hadSubfolder = true;
            }
            else
            {
                _logger.Log($"INFO: Geen geschikte submapnaam gegenereerd. Bestand komt direct in categorie '{targetCategoryFolderName}' of in originele submap structuur.");
            }

            string finalTargetDirectory;

            // AANGEPAST: Bepaal het uiteindelijke doelpad
            if (hadSubfolder)
            {
                // Als er een AI-gesuggereerde submap is, plaats het bestand DIRECT daarin.
                finalTargetDirectory = Path.Combine(targetCategoryFolderPath, aiSuggestedSubfolderName);
            }
            else
            {
                // Als er GEEN AI-gesuggereerde submap is, behoud dan de originele relatieve mapstructuur onder de categorie.
                string relativePathFromSource = FileUtils.GetRelativePath(sourcePath, Path.GetDirectoryName(filePath));
                finalTargetDirectory = Path.Combine(targetCategoryFolderPath, relativePathFromSource);
            }
            Directory.CreateDirectory(finalTargetDirectory); // Ensure the full target directory structure exists


            string newFileName = fileInfo.Name;
            bool wasRenamed = false;

            if (shouldRenameFiles)
            {
                _logger.Log($"INFO: AI-bestandsnaam genereren voor '{fileInfo.Name}'...");
                string suggestedNewBaseName = await _aiService.SuggestFileNameAsync(
                    extractedText,
                    fileInfo.Name,
                    currentAiProvider,
                    modelName,
                    cancellationToken
                );

                if (RequestRenameFile == null)
                {
                    _logger.Log("WAARSCHUWING: UI callback voor hernoemen is niet ingesteld. Kan bestand niet interactief hernoemen. Gebruik AI suggestie direct.");
                    newFileName = FileUtils.SanitizeFileName(suggestedNewBaseName + fileInfo.Extension);
                    string baseNameWithoutExt = Path.GetFileNameWithoutExtension(newFileName);
                    string extension = Path.GetExtension(newFileName);
                    if (baseNameWithoutExt.Length > ApplicationSettings.MaxFilenameLength)
                    {
                        baseNameWithoutExt = baseNameWithoutExt.Substring(0, ApplicationSettings.MaxFilenameLength);
                        newFileName = baseNameWithoutExt + extension;
                        _logger.Log($"WAARSCHUWING: Nieuwe bestandsnaam te lang. Afgekapt naar '{newFileName}'.");
                    }
                    if (newFileName != fileInfo.Name) wasRenamed = true;
                }
                else
                {
                    // Call the UI callback to show the rename form
                    var (dialogResult, returnedFileName, skipFile) = await RequestRenameFile.Invoke(fileInfo.Name, suggestedNewBaseName + fileInfo.Extension);

                    if (dialogResult == DialogResult.OK)
                    {
                        if (skipFile)
                        {
                            _logger.Log($"INFO: Gebruiker koos om '{fileInfo.Name}' niet te hernoemen. Bestand wordt verplaatst met originele naam.");
                            // newFileName remains the original name
                        }
                        else
                        {
                            string proposedFullName = returnedFileName;
                            string proposedBaseName = Path.GetFileNameWithoutExtension(proposedFullName);
                            string proposedExtension = Path.GetExtension(proposedFullName);

                            // Ensure extension is preserved or handled correctly
                            if (string.IsNullOrEmpty(proposedExtension))
                            {
                                proposedFullName = proposedBaseName + fileInfo.Extension;
                            }
                            else if (proposedExtension.ToLower() != fileInfo.Extension.ToLower())
                            {
                                _logger.Log($"WAARSCHUWING: Bestandsnaam '{proposedFullName}' heeft afwijkende extensie. Originele extensie '{fileInfo.Extension}' wordt behouden.");
                                proposedFullName = proposedBaseName + fileInfo.Extension; // Force original extension
                            }

                            newFileName = FileUtils.SanitizeFileName(proposedFullName); // Sanitize the confirmed new name

                            // Apply max length constraint
                            string baseNameWithoutExt = Path.GetFileNameWithoutExtension(newFileName);
                            string extension = Path.GetExtension(newFileName);
                            if (baseNameWithoutExt.Length > ApplicationSettings.MaxFilenameLength)
                            {
                                baseNameWithoutExt = baseNameWithoutExt.Substring(0, ApplicationSettings.MaxFilenameLength);
                                newFileName = baseNameWithoutExt + extension;
                                _logger.Log($"WAARSCHUWING: Nieuwe bestandsnaam te lang. Afgekapt naar '{newFileName}'.");
                            }

                            if (newFileName != fileInfo.Name)
                            {
                                _logger.Log($"INFO: '{fileInfo.Name}' wordt hernoemd naar '{newFileName}'.");
                                wasRenamed = true;
                            }
                            else
                            {
                                _logger.Log($"INFO: AI-suggestie voor '{fileInfo.Name}' was gelijk aan origineel of ongeldig na opschonen, niet hernoemd.");
                            }
                        }
                    }
                    else
                    {
                        // User cancelled the rename dialog, means skip this file for now
                        _logger.Log($"INFO: Hernoem-actie voor '{fileInfo.Name}' geannuleerd door gebruiker. Bestand wordt overgeslagen.");
                        return (false, false, false, false); // Return false for processed, so it's not counted as moved/renamed
                    }
                }
            }

            string destinationFilePath = Path.Combine(finalTargetDirectory, newFileName);

            // Handle existing file names in target directory
            if (File.Exists(destinationFilePath))
            {
                string baseName = Path.GetFileNameWithoutExtension(newFileName);
                string extension = Path.GetExtension(newFileName);
                int counter = 1;
                string uniqueDestinationFilePath = destinationFilePath;
                while (File.Exists(uniqueDestinationFilePath))
                {
                    uniqueDestinationFilePath = Path.Combine(finalTargetDirectory, $"{baseName}_{counter}{extension}");
                    counter++;
                }
                _logger.Log($"INFO: Bestand '{newFileName}' bestaat al op doel. Hernoemd naar '{Path.GetFileName(uniqueDestinationFilePath)}' om conflict te voorkomen.");
                destinationFilePath = uniqueDestinationFilePath;
            }

            File.Move(filePath, destinationFilePath);

            _logger.Log($"OK: '{fileInfo.Name}' verplaatst naar '{FileUtils.GetRelativePath(destinationBasePath, destinationFilePath)}'");
            return (true, true, hadSubfolder, wasRenamed);
        }

        /// <summary>
        /// Factory method to get the correct AI provider based on selection.
        /// </summary>
        private IAiProvider GetAiProvider(string apiKey, string providerName, string azureEndpoint)
        {
            try
            {
                switch (providerName)
                {
                    case "Gemini (Google)":
                        return new GeminiAiProvider(apiKey, _httpClient);
                    case "OpenAI (openai.com)":
                        return new OpenAiProvider(apiKey);
                    case "Azure OpenAI":
                        return new AzureOpenAiProvider(azureEndpoint, apiKey);
                    default:
                        _logger.Log($"FOUT: Onbekende AI-provider geselecteerd: {providerName}. Kan actie niet uitvoeren.");
                        return null;
                }
            }
            catch (ArgumentException ex) // Catch specific exceptions from provider constructors (e.g., invalid Azure endpoint)
            {
                _logger.Log($"FOUT: Configuratieprobleem voor AI-provider '{providerName}': {ex.Message}. Kan actie niet uitvoeren.");
                return null;
            }
        }
    }
}


================================================
FILE: Services/GeminiAiProvider.cs
================================================
﻿// AI_FileOrganizer2/Services/GeminiAiProvider.cs
using System;
using System.Net.Http;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;

namespace AI_FileOrganizer2.Services
{
    public class GeminiAiProvider : IAiProvider
    {
        private const string GEMINI_BASE_URL = "https://generativelanguage.googleapis.com/v1beta/models/";
        private readonly HttpClient _httpClient;
        private readonly string _apiKey;

        public GeminiAiProvider(string apiKey, HttpClient httpClient)
        {
            if (string.IsNullOrWhiteSpace(apiKey))
                throw new ArgumentException("De Gemini API key mag niet leeg zijn.", nameof(apiKey));

            _apiKey = apiKey;
            _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
        }

        public async Task<string> GetTextCompletionAsync(string prompt, string modelName, int maxTokens, float temperature, CancellationToken cancellationToken)
        {
            // === Validatie ===
            if (string.IsNullOrWhiteSpace(prompt))
                throw new ArgumentException("De prompt voor Gemini mag niet leeg zijn.", nameof(prompt));
            if (string.IsNullOrWhiteSpace(modelName))
                throw new ArgumentException("Modelnaam mag niet leeg zijn.", nameof(modelName));
            if (maxTokens <= 0 || maxTokens > 2048)
                throw new ArgumentOutOfRangeException(nameof(maxTokens), "maxTokens moet tussen 1 en 2048 zijn.");
            if (temperature < 0 || temperature > 1)
                throw new ArgumentOutOfRangeException(nameof(temperature), "temperature moet tussen 0.0 en 1.0 zijn.");

            var requestBody = new
            {
                contents = new[]
                {
                    new { parts = new[] { new { text = prompt } } }
                },
                generationConfig = new
                {
                    maxOutputTokens = maxTokens,
                    temperature = temperature
                }
            };

            string jsonRequest = JsonConvert.SerializeObject(requestBody);
            string endpoint = $"{GEMINI_BASE_URL}{modelName}:generateContent?key={_apiKey}";

            try
            {
                var httpContent = new StringContent(jsonRequest, Encoding.UTF8, "application/json");
                var response = await _httpClient.PostAsync(endpoint, httpContent, cancellationToken);

                response.EnsureSuccessStatusCode(); // Gooi een exception als het geen succesvolle statuscode is

                string jsonResponse = await response.Content.ReadAsStringAsync();
                dynamic result = JsonConvert.DeserializeObject(jsonResponse);

                string resultText = result?.candidates?[0]?.content?.parts?[0]?.text;
                if (!string.IsNullOrWhiteSpace(resultText))
                    return resultText.Trim();

                return null;
            }
            catch (HttpRequestException httpEx)
            {
                Console.WriteLine($"[GeminiAiProvider] HTTP-fout: {httpEx.Message}");
                return null;
            }
            catch (JsonException jsonEx)
            {
                Console.WriteLine($"[GeminiAiProvider] JSON-fout: {jsonEx.Message}");
                return null;
            }
            catch (OperationCanceledException)
            {
                throw; // Belangrijk: propagatie van annulering
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[GeminiAiProvider] Onbekende fout: {ex.Message}");
                return null;
            }
        }
    }
}



================================================
FILE: Services/IaProvider.cs
================================================
﻿// AI_FileOrganizer2/Services/IAiProvider.cs
using System.Threading;
using System.Threading.Tasks;

namespace AI_FileOrganizer2.Services
{
    public interface IAiProvider
    {
        /// <summary>
        /// Roept de AI-API aan om tekstaanvulling te genereren.
        /// </summary>
        /// <param name="prompt">De prompt voor de AI.</param>
        /// <param name="modelName">De naam van het te gebruiken AI-model.</param>
        /// <param name="maxTokens">Het maximale aantal tokens om te genereren.</param>
        /// <param name="temperature">De creativiteit van de generatie (0.0 tot 1.0).</param>
        /// <param name="cancellationToken">Token voor annulering van de operatie.</param>
        /// <returns>De gegenereerde tekst of null bij falen.</returns>
        Task<string> GetTextCompletionAsync(string prompt, string modelName, int maxTokens, float temperature, CancellationToken cancellationToken);
    }
}


================================================
FILE: Services/ITextExtractor.cs
================================================
﻿// AI_FileOrganizer2/Services/ITextExtractor.cs
using System.IO;

namespace AI_FileOrganizer2.Services
{
    public interface ITextExtractor
    {
        /// <summary>
        /// Bepaalt of deze extractor de opgegeven bestandsextensie kan verwerken.
        /// </summary>
        /// <param name="filePath">Het pad naar het bestand.</param>
        /// <returns>True als de extractor het bestand kan verwerken, anders False.</returns>
        bool CanExtract(string filePath);

        /// <summary>
        /// Extrahert tekst uit het opgegeven bestand.
        /// </summary>
        /// <param name="filePath">Het volledige pad naar het bestand.</param>
        /// <returns>De geëxtraheerde tekst, of een lege string bij fouten of geen tekst.</returns>
        string Extract(string filePath);
    }
}


================================================
FILE: Services/OpenAiProvider.cs
================================================
﻿// AI_FileOrganizer2/Services/OpenAiProvider.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using OpenAI;
using OpenAI.Chat;

namespace AI_FileOrganizer2.Services
{
    public class OpenAiProvider : IAiProvider
    {
        private readonly string _apiKey;

        public OpenAiProvider(string apiKey)
        {
            if (string.IsNullOrWhiteSpace(apiKey))
                throw new ArgumentException("OpenAI API key mag niet leeg zijn.", nameof(apiKey));

            _apiKey = apiKey;
        }

        public async Task<string> GetTextCompletionAsync(string prompt, string modelName, int maxTokens, float temperature, CancellationToken cancellationToken)
        {
            if (string.IsNullOrWhiteSpace(prompt))
                throw new ArgumentException("De prompt mag niet leeg zijn.", nameof(prompt));
            if (string.IsNullOrWhiteSpace(modelName))
                throw new ArgumentException("Modelnaam mag niet leeg zijn.", nameof(modelName));
            if (maxTokens <= 0 || maxTokens > 4096)
                throw new ArgumentOutOfRangeException(nameof(maxTokens), "maxTokens moet tussen 1 en 4096 zijn.");
            if (temperature < 0 || temperature > 1)
                throw new ArgumentOutOfRangeException(nameof(temperature), "temperature moet tussen 0.0 en 1.0 zijn.");

            try
            {
                var client = new ChatClient(model: modelName, apiKey: _apiKey);
                var messages = new List<ChatMessage>
                {
                    new UserChatMessage(prompt)
                };

                var chatCompletionOptions = new ChatCompletionOptions
                {
                    Temperature = temperature,
                    MaxOutputTokenCount = maxTokens
                };

                var completionResult = await client.CompleteChatAsync(messages, chatCompletionOptions, cancellationToken);
                var chatCompletion = completionResult.Value;

                var firstContent = chatCompletion.Content.FirstOrDefault();
                if (!string.IsNullOrWhiteSpace(firstContent?.Text))
                    return firstContent.Text.Trim();

                return null;
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[OpenAiProvider] Fout: {ex.Message}");
                return null;
            }
        }
    }
}



================================================
FILE: Services/PdfTextExtractor.cs
================================================
﻿// AI_FileOrganizer2/Services/PdfTextExtractor.cs
using System;
using System.IO;
using System.Linq;
using System.Text; // Voor StringBuilder
using UglyToad.PdfPig;
using UglyToad.PdfPig.DocumentLayoutAnalysis.PageSegmenter; // Voor DocstrumBoundingBoxes
using UglyToad.PdfPig.DocumentLayoutAnalysis.ReadingOrderDetector; // Voor UnsupervisedReadingOrderDetector
using UglyToad.PdfPig.DocumentLayoutAnalysis.WordExtractor; // Voor NearestNeighbourWordExtractor
using UglyToad.PdfPig.Core;

using AI_FileOrganizer2.Utils; // Voor ILogger

namespace AI_FileOrganizer2.Services
{
    public class PdfTextExtractor : ITextExtractor
    {
        private readonly ILogger _logger;

        public PdfTextExtractor(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public bool CanExtract(string filePath)
        {
            return Path.GetExtension(filePath).Equals(".pdf", StringComparison.OrdinalIgnoreCase);
        }

        public string Extract(string filePath)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(filePath) || !File.Exists(filePath))
                {
                    _logger.Log($"WAARSCHUWING: Bestand niet gevonden voor PDF-extractie: '{filePath}'.");
                    return string.Empty;
                }

                // ReaderOptions instellen voor lenient parsing
                var options = new ParsingOptions { UseLenientParsing = true };

                using (var document = PdfDocument.Open(filePath, options))
                {
                    if (document.NumberOfPages == 0)
                    {
                        _logger.Log($"WAARSCHUWING: PDF-bestand '{filePath}' bevat geen pagina's.");
                        return string.Empty;
                    }

                    var fullText = new StringBuilder();

                    foreach (var page in document.GetPages())
                    {
                        var letters = page.Letters;
                        if (letters == null || !letters.Any())
                        {
                            _logger.Log($"INFO: Geen letters op pagina {page.Number} van '{filePath}'. Val terug op page.Text.");
                            fullText.AppendLine(page.Text?.Trim());
                            continue;
                        }

                        // Woordextractie
                        var wordExtractor = NearestNeighbourWordExtractor.Instance;
                        var words = wordExtractor.GetWords(letters);

                        if (words == null || !words.Any())
                        {
                            _logger.Log($"INFO: Geen woorden op pagina {page.Number} van '{filePath}'. Val terug op page.Text.");
                            fullText.AppendLine(page.Text?.Trim());
                            continue;
                        }

                        // Paginasegmentatie
                        var pageSegmenter = DocstrumBoundingBoxes.Instance;
                        var textBlocks = pageSegmenter.GetBlocks(words);

                        if (textBlocks == null || !textBlocks.Any())
                        {
                            _logger.Log($"INFO: Geen tekstblokken op pagina {page.Number} van '{filePath}'. Val terug op page.Text.");
                            fullText.AppendLine(page.Text?.Trim());
                            continue;
                        }

                        // Leesvolgorde bepalen
                        var readingOrderDetector = UnsupervisedReadingOrderDetector.Instance;
                        var orderedTextBlocks = readingOrderDetector.Get(textBlocks);

                        if (orderedTextBlocks == null || !orderedTextBlocks.Any())
                        {
                            _logger.Log($"INFO: Geen leesvolgorde gevonden op pagina {page.Number} van '{filePath}'. Val terug op page.Text.");
                            fullText.AppendLine(page.Text?.Trim());
                            continue;
                        }

                        foreach (var block in orderedTextBlocks)
                        {
                            if (!string.IsNullOrWhiteSpace(block.Text))
                                fullText.AppendLine(block.Text.Trim());
                        }
                    }

                    var result = fullText.ToString().Trim();
                    if (string.IsNullOrEmpty(result))
                        _logger.Log($"WAARSCHUWING: Geen tekst geëxtraheerd uit '{filePath}'.");
                    return result;
                }
            }
            catch (PdfDocumentFormatException pdfEx)
            {
                _logger.Log($"FOUT: Beschadigd PDF-bestand '{Path.GetFileName(filePath)}': {pdfEx.Message}");
                return string.Empty;
            }

         
            catch (UnauthorizedAccessException uaEx)
            {
                _logger.Log($"FOUT: Geen toegang tot PDF-bestand '{filePath}': {uaEx.Message}");
                return string.Empty;
            }
            catch (IOException ioEx) when ((ioEx.HResult & 0xFFFF) == 32) // ERROR_SHARING_VIOLATION
            {
                _logger.Log($"WAARSCHUWING: Bestand '{filePath}' is vergrendeld.");
                return string.Empty;
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Onbekende fout bij extractie van '{filePath}': {ex.Message}");
                return string.Empty;
            }
        }

    }
}


================================================
FILE: Services/PlainTextExtractor.cs
================================================
﻿// AI_FileOrganizer2/Services/PlainTextExtractor.cs
using System;
using System.IO;
using AI_FileOrganizer2.Utils; // Voor ILogger

namespace AI_FileOrganizer2.Services
{
    public class PlainTextExtractor : ITextExtractor
    {
        private readonly ILogger _logger;

        public PlainTextExtractor(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public bool CanExtract(string filePath)
        {
            string extension = Path.GetExtension(filePath).ToLower();
            return extension == ".txt" || extension == ".md";
        }

        public string Extract(string filePath)
        {
            try
            {
                if (!File.Exists(filePath))
                {
                    _logger.Log($"WAARSCHUWING: Bestand niet gevonden voor TXT/MD-extractie: '{Path.GetFileName(filePath)}'.");
                    return string.Empty;
                }
                return File.ReadAllText(filePath).Trim();
            }
            catch (UnauthorizedAccessException uaEx)
            {
                _logger.Log($"FOUT: Toegang geweigerd tot TXT/MD-bestand '{Path.GetFileName(filePath)}': {uaEx.Message}");
                return string.Empty;
            }
            catch (IOException ioEx) when ((ioEx.HResult & 0xFFFF) == 32) // ERROR_SHARING_VIOLATION
            {
                _logger.Log($"WAARSCHUWING: Bestand '{Path.GetFileName(filePath)}' is vergrendeld en kan niet worden gelezen voor TXT/MD-extractie.");
                return string.Empty;
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Onbekende fout bij TXT/MD-extractie van '{Path.GetFileName(filePath)}': {ex.Message}");
                return string.Empty;
            }
        }
    }
}


================================================
FILE: Services/TextExtractionService.cs
================================================
﻿using AI_FileOrganizer2.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace AI_FileOrganizer2.Services
{
    public class TextExtractionService
    {
        private readonly ILogger _logger;
        private readonly List<ITextExtractor> _extractors; // Collection of specific extractors

        public TextExtractionService(ILogger logger, IEnumerable<ITextExtractor> extractors)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _extractors = extractors?.ToList() ?? throw new ArgumentNullException(nameof(extractors));

            if (!_extractors.Any())
            {
                _logger.Log("WAARSCHUWING: TextExtractionService geïnitialiseerd zonder ITextExtractors.");
            }
        }

        public string ExtractText(string filePath)
        {
            if (string.IsNullOrWhiteSpace(filePath))
            {
                _logger.Log("WAARSCHUWING: Geen bestandspad opgegeven voor tekstextractie.");
                return string.Empty;
            }

            if (!File.Exists(filePath))
            {
                _logger.Log($"WAARSCHUWING: Bestand niet gevonden voor tekstextractie: '{Path.GetFileName(filePath)}'.");
                return string.Empty;
            }

            // Find the correct extractor for the file extension
            foreach (var extractor in _extractors)
            {
                if (extractor.CanExtract(filePath))
                {
                    _logger.Log($"INFO: Extraheren van tekst uit '{Path.GetFileName(filePath)}' met {extractor.GetType().Name}.");
                    return extractor.Extract(filePath);
                }
            }

            _logger.Log($"WAARSCHUWING: Geen geschikte tekstextractor gevonden voor '{Path.GetFileName(filePath)}'.");
            return string.Empty;
        }

        // The previous LogMessage method was unnecessary as _logger is directly available.
    }
}


================================================
FILE: Utils/FileLogger.cs
================================================
﻿using System;
using System.IO;

namespace AI_FileOrganizer2.Utils
{
    /// <summary>
    /// Logger die logt naar een tekstbestand. Werkt thread-safe.
    /// </summary>
    public class FileLogger : ILogger
    {
        private readonly string _filePath;
        private readonly object _lockObj = new object();

        public FileLogger(string filePath)
        {
            _filePath = filePath;
        }

        public void Log(string message)
        {
            string logLine = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}";
            lock (_lockObj)
            {
                File.AppendAllText(_filePath, logLine + Environment.NewLine);
            }
        }
    }
}



================================================
FILE: Utils/FileUtil.cs
================================================
﻿using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace AI_FileOrganizer2.Utils
{
    public static class FileUtils
    {
        public static string SanitizeFileName(string proposedFullName)
        {
            if (string.IsNullOrWhiteSpace(proposedFullName)) return "";
            // Remove invalid characters for file names
            string name = Regex.Replace(proposedFullName, @"[<>:""/\\|?*\x00-\x1F]", "_");
            // Trim spaces and dots at the beginning/end
            name = name.Trim('.', ' ');
            // Replace multiple spaces/underscores with a single one
            name = Regex.Replace(name, @"\s+", " ").Trim();
            name = Regex.Replace(name, @"_+", "_").Trim('_');
            // Max length should ideally come from ApplicationSettings, but keeping it consistent with original Form1 constant for now.
            if (name.Length > 100) name = name.Substring(0, 100);

            // Ensure the name doesn't become empty or just underscores/spaces after sanitization
            if (string.IsNullOrWhiteSpace(name.Replace("_", "").Replace(" ", "")))
                return "OngeldigeNaam"; // Provide a fallback if it becomes totally unreadable

            return name;
        }

        public static string SanitizeFolderOrFileName(string naam)
        {
            if (string.IsNullOrWhiteSpace(naam)) return "";
            var invalidChars = Path.GetInvalidFileNameChars(); // Also covers some path chars
            // Union with invalid path chars for robustness for folders
            var invalidPathChars = Path.GetInvalidPathChars().Union(invalidChars).Distinct().ToArray();
            var clean = new string(naam.Where(c => !invalidPathChars.Contains(c)).ToArray());
            clean = clean.Replace(".", "").Replace(",", "").Trim(); // Remove common punctuation
            // Replace multiple spaces with single space, then trim again
            clean = Regex.Replace(clean, @"\s+", " ").Trim();
            // Remove trailing spaces, periods, or other common problematic characters for paths
            clean = clean.TrimEnd('.', ' ');

            if (string.IsNullOrWhiteSpace(clean))
                return "OngeldigeMapnaam";

            return clean;
        }

        /// <summary>
        /// Calculates the relative path of a full path relative to a base path.
        /// </summary>
        public static string GetRelativePath(string basePath, string fullPath)
        {
            string baseWithSeparator = AppendDirectorySeparatorChar(basePath);
            Uri baseUri = new Uri(baseWithSeparator);
            Uri fullUri = new Uri(fullPath);

            Uri relativeUri = baseUri.MakeRelativeUri(fullUri);

            return Uri.UnescapeDataString(relativeUri.ToString().Replace('/', Path.DirectorySeparatorChar));
        }

        /// <summary>
        /// Ensures a path ends with a directory separator character.
        /// </summary>
        public static string AppendDirectorySeparatorChar(string path)
        {
            if (!string.IsNullOrEmpty(path) && !path.EndsWith(Path.DirectorySeparatorChar.ToString()))
                return path + Path.DirectorySeparatorChar;
            return path;
        }

        public static string FallbackFolderNameFromFilename(string filename)
        {
            filename = filename.ToLowerInvariant();

            if (filename.Contains("factuur")) return "Factuur";
            if (filename.Contains("offerte")) return "Offerte";
            if (filename.Contains("polis") || filename.Contains("verzekering")) return "Polis";
            if (filename.Contains("cv") || filename.Contains("curriculum")) return "CV";
            if (filename.Contains("notulen")) return "Notulen";
            if (filename.Contains("handleiding") || filename.Contains("manual")) return "Handleiding";
            if (filename.Contains("rapport") || filename.Contains("report")) return "Rapport";
            if (filename.Contains("budget") || filename.Contains("begroting")) return "Budget";
            if (filename.Contains("jaaropgave") || filename.Contains("jaaroverzicht")) return "Jaaropgave";

            return null;
        }
     
    }
}


================================================
FILE: Utils/ILogger.cs
================================================
﻿using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AI_FileOrganizer2.Utils
{
    /// <summary>
    /// Een eenvoudige logging interface zodat je makkelijk van logger kunt wisselen.
    /// </summary>
    public interface ILogger
    {
        void Log(string message);
    }
}





================================================
FILE: Utils/UiLogger.cs
================================================
﻿using System.Windows.Forms;

namespace AI_FileOrganizer2.Utils
{
    /// <summary>
    /// Logger die logt naar een RichTextBox in een WinForms UI.
    /// </summary>
    public class UiLogger : ILogger
    {
        private readonly RichTextBox _logBox;

        public UiLogger(RichTextBox logBox)
        {
            _logBox = logBox;
        }

        public void Log(string message)
        {
            // Zorg dat je op de juiste thread zit voor UI-updates
            if (_logBox.InvokeRequired)
            {
                _logBox.BeginInvoke(new MethodInvoker(() => Log(message)));
            }
            else
            {
                _logBox.AppendText(message + System.Environment.NewLine);
                _logBox.ScrollToCaret();
            }
        }
    }
}


