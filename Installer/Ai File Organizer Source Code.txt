Directory structure:
‚îî‚îÄ‚îÄ remseymailjard-ai-fileorganizer/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ AI-FileOrganizer.csproj
    ‚îú‚îÄ‚îÄ AI-FileOrganizer.sln
    ‚îú‚îÄ‚îÄ App.config
    ‚îú‚îÄ‚îÄ appsettings.json
    ‚îú‚îÄ‚îÄ FormRenameFile.cs
    ‚îú‚îÄ‚îÄ FormRenameFile.Designer.cs
    ‚îú‚îÄ‚îÄ FormRenameFile.resx
    ‚îú‚îÄ‚îÄ MainWindow.cs
    ‚îú‚îÄ‚îÄ MainWindow.Designer.cs
    ‚îú‚îÄ‚îÄ MainWindow.resx
    ‚îú‚îÄ‚îÄ packages.config
    ‚îú‚îÄ‚îÄ Program.cs
    ‚îú‚îÄ‚îÄ ILLink/
    ‚îÇ   ‚îî‚îÄ‚îÄ ILLink.Descriptors.LibraryBuild.xml
    ‚îú‚îÄ‚îÄ Installer/
    ‚îÇ   ‚îú‚îÄ‚îÄ AI-applicatie.txt
    ‚îÇ   ‚îú‚îÄ‚îÄ AI-FolderInno.iss
    ‚îÇ   ‚îú‚îÄ‚îÄ installatie-informatie.txt
    ‚îÇ   ‚îú‚îÄ‚îÄ MIT License (MIT-licentie).txt
    ‚îÇ   ‚îú‚îÄ‚îÄ na-installatie-informatie.txt
    ‚îÇ   ‚îî‚îÄ‚îÄ archief/
    ‚îÇ       ‚îî‚îÄ‚îÄ README_AI_File_Organizer.md
    ‚îú‚îÄ‚îÄ Media/
    ‚îú‚îÄ‚îÄ Models/
    ‚îÇ   ‚îî‚îÄ‚îÄ ApplicationSettings.cs
    ‚îú‚îÄ‚îÄ PersoonlijkeMappenGenerator/
    ‚îÇ   ‚îú‚îÄ‚îÄ README.md
    ‚îÇ   ‚îú‚îÄ‚îÄ map_structuur.txt
    ‚îÇ   ‚îú‚îÄ‚îÄ Persoonlijke Administratie.zip
    ‚îÇ   ‚îú‚îÄ‚îÄ PersoonlijkeMappenStructuurGenerator.bat
    ‚îÇ   ‚îú‚îÄ‚îÄ test2.bat
    ‚îÇ   ‚îî‚îÄ‚îÄ .gitattributes
    ‚îú‚îÄ‚îÄ Properties/
    ‚îÇ   ‚îú‚îÄ‚îÄ AssemblyInfo.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ Resources.Designer.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ Resources.resx
    ‚îÇ   ‚îú‚îÄ‚îÄ Settings.Designer.cs
    ‚îÇ   ‚îî‚îÄ‚îÄ Settings.settings
    ‚îú‚îÄ‚îÄ Scripts/
    ‚îÇ   ‚îú‚îÄ‚îÄ ai_bestandsorganizer.py
    ‚îÇ   ‚îú‚îÄ‚îÄ ai_bestandsorganizer3.py
    ‚îÇ   ‚îú‚îÄ‚îÄ ai_bestandsorganizerGoogle.py
    ‚îÇ   ‚îî‚îÄ‚îÄ streamlit_organizer_app.py
    ‚îú‚îÄ‚îÄ Services/
    ‚îÇ   ‚îú‚îÄ‚îÄ AiClassificationService.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ AzureOpenAiProvider.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ CredentialStorageService.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ DocxTextExtractor.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ FileOrganizerService.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ GeminiAiProvider.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ IaProvider.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ ITextExtractor.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ OpenAiProvider.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ PdfTextExtractor.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ PlainTextExtractor.cs
    ‚îÇ   ‚îî‚îÄ‚îÄ TextExtractionService.cs
    ‚îî‚îÄ‚îÄ Utils/
        ‚îú‚îÄ‚îÄ BatchOrExeRunner.cs
        ‚îú‚îÄ‚îÄ FileLogger.cs
        ‚îú‚îÄ‚îÄ FileUtil.cs
        ‚îú‚îÄ‚îÄ ILogger.cs
        ‚îú‚îÄ‚îÄ PersoonlijkeMappenStructuurGenerator.cs
        ‚îî‚îÄ‚îÄ UiLogger.cs


Files Content:

(Files content cropped to 300k characters, download full ingest to see more)
================================================
FILE: README.md
================================================
# AI File Organizer üöÄ

**AI File Organizer** is een slimme Windows-applicatie die jouw documenten automatisch organiseert en hernoemt met behulp van krachtige AI-modellen (Gemini, OpenAI, Azure OpenAI).  Selecteer eenvoudig je bronmap en doelmap, kies een AI-provider, en de applicatie doet het werk voor je! 

![AI File Organizer Demo](Media/AIFileOrganizer_Demo.gif)

 

Deze applicatie scant, analyseert en organiseert je bestanden (PDF, DOCX, TXT, MD) automatisch in logische categorie√´n en submappen ‚Äì volledig op basis van de inhoud. Daarnaast doet de app slimme suggesties voor duidelijke bestandsnamen, zodat je digitale archief altijd netjes blijft.
Met AI File Organizer bespaar je tijd, houd je overzicht en regelt AI al het organiseerwerk voor je.

**Voor wie?**  
Voor iedereen die snel en moeiteloos orde wil scheppen in een grote verzameling digitale documenten ‚Äì van thuisadministratie tot kleine bedrijven en zzp‚Äôers.
> **Let op:** Zorg dat billing/tegoed geactiveerd is bij je AI-provider (Gemini, OpenAI of Azure OpenAI).



## ‚ö° Alleen een mappen generator nodig?

Wil je **niet de volledige Windows-applicatie**, maar gewoon snel een persoonlijke mappenstructuur aanmaken?  
Gebruik dan de losse **Persoonlijke Mappen Generator**:

‚û°Ô∏è **[Download PersoonlijkeMappenStructuurGenerator.exe](https://github.com/RemseyMailjard/AI-FileOrganizer/raw/master/PersoonlijkeMappenGenerator/PersoonlijkeMappenStructuurGenerator.exe)**

1. Klik op de bovenstaande link om het EXE-bestand direct te downloaden.
2. Open het gedownloade bestand en volg de instructies om je mappenstructuur te genereren op je eigen computer.

> ‚ÑπÔ∏è Geen installatie nodig ‚Äî direct starten!


## üìã Functies

- **AI-gestuurde classificatie:** Bestanden worden automatisch ingedeeld in logische (sub)categorie√´n op basis van hun inhoud.
- **AI-voorstellen voor submappen en bestandsnamen:** Ontvang slimme suggesties voor een georganiseerde mappenstructuur en duidelijke bestandsnamen.
- **Brede AI-ondersteuning:** Werkt met Gemini (Google), OpenAI, en Azure OpenAI.
- **Gebruiksvriendelijke interface:** Intu√Øtief ontwerp met drag & drop functionaliteit.
- **Transparant proces:** Live voortgangsupdates en uitgebreide logging.
- **Flexibel:** Mogelijkheid om het organisatieproces op elk moment te annuleren.

---
## üìå Vereisten

- Windows 10 of hoger
- .NET Framework 4.8 (de installer controleert dit en biedt installatie automatisch aan indien nodig)
- Een geldige API-key voor Gemini (Google), OpenAI, of Azure OpenAI
- **Billing (facturatie) moet zijn ingeschakeld** bij je gekozen AI-provider.
  > ‚ö†Ô∏è **Belangrijk:** De AI-modellen die deze tool gebruikt (Gemini, OpenAI, etc.) brengen kosten in rekening bij de providers per gebruik (tokens). Zonder actieve facturatie zal de API-toegang niet werken, zelfs niet voor eventuele 'gratis' limieten of proefperiodes.
- Actieve internetverbinding

---

## üì¶ Installatie

1.  Download de nieuwste installer uit de [`installer`](installer) map:
    [AIFileOrganizerSetup.exe](Installer/AIFileOrganizerSetup.exe)
2.  Dubbelklik op het `AIFileOrganizerSetup.exe` bestand en volg de stappen in de installatie-wizard.
3.  Start de applicatie via de snelkoppeling op je bureaublad of via het Startmenu.

> **Let op:** Tijdens de installatie kan Windows om administratorrechten vragen om de software correct te installeren.


## üóùÔ∏è API-key instellen

Voordat je kunt beginnen, moet je je AI-provider configureren:

1.  Start **AI File Organizer**.
2.  Ga naar het instellingenscherm (vaak aangegeven met een tandwiel-icoon of direct zichtbaar bij de eerste start).
3.  Vul je API-key in voor de gewenste service (Gemini, OpenAI, of Azure OpenAI).
4.  **Voor Azure OpenAI:** Vul ook het specifieke `Endpoint` en de `Deployment Name` (modelnaam) in die je in Azure hebt geconfigureerd.
5.  Selecteer het gewenste AI-model uit de lijst (indien van toepassing voor de gekozen provider).
6.  Sla de instellingen op.

> **Let op:**
> Zorg ervoor dat **billing/tegoed geactiveerd is** bij je AI-provider (zoals Google Cloud voor Gemini, of OpenAI direct). Zonder dit werken de API-calls niet.
>
> Voor gedetailleerde, stapsgewijze instructies (inclusief voorbeelden) over het verkrijgen en configureren van je API-key, raadpleeg:
> [installatie-informatie.txt](installer/installatie-informatie.txt)

---

## ‚ö° Gebruik

Organiseer je bestanden in een paar simpele stappen:

1.  **Selecteer Bronmap:** Klik op "Bladeren..." en kies de map met de bestanden die je wilt organiseren.
2.  **Kies Doelmap:** Klik op "Bladeren..." en selecteer een (lege of nieuwe) map waar de georganiseerde bestanden en mappen moeten komen.
3.  **(Optioneel) AI Hernoemen:** Vink de optie aan als je wilt dat de AI ook suggesties doet voor nieuwe bestandsnamen.
4.  Klik op **Start** en de AI File Organizer begint met het analyseren en verplaatsen van je bestanden.
5.  Volg de voortgang in het logvenster. Hier zie je welke bestanden worden verwerkt en welke mappen worden aangemaakt.
6.  Na afloop kun je het logboek opslaan als een `.txt`-bestand voor naslag.

---

## üìÇ Ondersteunde bestandstypen

Momenteel worden de volgende bestandstypen ondersteund voor inhoudsanalyse:

- PDF (`.pdf`)
- Word-documenten (`.docx`)
- Tekstbestanden (`.txt`, `.md`)

> üí° Suggesties voor ondersteuning van andere bestandstypen zijn welkom! Maak hiervoor een [Issue aan op GitHub](#-support--feedback).

---

## üóÉÔ∏è Mapcategorie√´n (Voorbeelden)

De AI analyseert de inhoud van je bestanden en stelt een logische mappenstructuur voor. Voorbeelden van hoofdmappen die automatisch kunnen worden aangemaakt zijn:

- Financi√´n (bijv. facturen, bankafschriften)
- Belastingen (bijv. aangiftes, specificaties)
- Verzekeringen (bijv. polissen, correspondentie)
- Woning (bijv. huurcontract, hypotheekdocumenten, VvE)
- Gezondheid & Medisch (bijv. doktersrekeningen, uitslagen)
- Familie & Kinderen (bijv. schoolrapporten, geboorteaktes)
- Voertuigen (bijv. kentekenbewijs, verzekering, onderhoud)
- Persoonlijke documenten (bijv. identiteitsbewijzen, diploma's)
- Hobbies & Interesses (bijv. artikelen, projectnotities)
- Carri√®re / Werk (bijv. contracten, sollicitaties, certificaten)
- Bedrijfsadministratie (indien relevant voor de documenten)
- Reizen & Vakanties (bijv. boekingen, tickets)
- Overig (voor bestanden die niet direct in een specifieke categorie passen)

De applicatie is ontworpen om **automatisch relevante submappen** te cre√´ren als de AI voldoende specifieke details in de documenten detecteert, voor een nog fijnmazigere organisatie.

---

## üìë Projectstructuur (voor ontwikkelaars)

Een overzicht van de mappen in deze repository:

- `installer/` ‚Äî Bevat de setup (AIFileOrganizerSetup.exe), licentie, en aanvullende informatiebestanden.
- `bin/Release/` ‚Äî Bevat de gecompileerde, uitvoerbare bestanden van de applicatie.
- `src/` ‚Äî Bevat de volledige C# broncode van de AI File Organizer.
- `README.md` ‚Äî Dit bestand.
- `LICENSE.txt` ‚Äî De MIT-licentietekst.

---

## üõ†Ô∏è Gebruikte componenten & technologie√´n

Deze applicatie maakt gebruik van de volgende belangrijke libraries en API's:

- **PdfPig:** Voor het extraheren van tekst uit PDF-bestanden.
- **DocumentFormat.OpenXml (Open XML SDK):** Voor het lezen van Microsoft Word (`.docx`) bestanden.
- **Microsoft.WindowsAPICodePack-Shell:** Voor moderne Windows-dialogen (zoals mapselectie).
- **AI API's:**
    - Google Gemini API Client Libraries
    - OpenAI API Client Libraries
    - Azure.AI.OpenAI Client Libraries
- **Newtonsoft.Json:** Voor het verwerken van JSON-data (vaak gebruikt in API-communicatie).
- **.NET Framework 4.8 & Windows Forms:** Voor de applicatie-interface en basisfunctionaliteit.

---

## üìû Support & Feedback

Heb je vragen, idee√´n voor nieuwe functies, of een bug gevonden? We horen het graag!

- **Maak een Issue aan op GitHub:** Dit is de beste plek voor bug reports en feature requests.
  [Ga naar de Issues Pagina](https://github.com/RemseyMailjard/PersoonlijkeMappenGenerator/issues)
- **LinkedIn:** Neem contact op met [Remsey Mailjard](https://www.linkedin.com/in/remseymailjard/)
- **Website:** Bezoek [remsey.nl](https://www.remsey.nl) voor meer projecten en informatie.

---

## üìÑ Licentie

Dit project is open source en beschikbaar onder de [MIT-licentie](installer/LICENSE.txt). Dit betekent dat je de software vrij mag gebruiken, aanpassen en verspreiden, onder de voorwaarden van de licentie.

---

Veel plezier met het organiseren van je bestanden! üéâ

Vind je deze tool handig en wil je het project ondersteunen? Overweeg een ster ‚≠ê te geven op GitHub!

¬© 2025 Remsey Mailjard | AI File Organizer



================================================
FILE: AI-FileOrganizer.csproj
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{A58EBE3F-C926-432E-B874-AD6F29494AC7}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>AI_FileOrganizer</RootNamespace>
    <AssemblyName>AI-FileOrganizer</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>C:\Users\Remse\Desktop\AI-FileOrganizer\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <TargetCulture>nl-NL</TargetCulture>
    <ProductName>AI-File Organizer %28AFO%29</ProductName>
    <PublisherName>Remsey Mailjard</PublisherName>
    <ApplicationRevision>3</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <PublishWizardCompleted>true</PublishWizardCompleted>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ManifestCertificateThumbprint>6F5EC5C02B4F1B3306729060BCE598E3CEF7AC6E</ManifestCertificateThumbprint>
  </PropertyGroup>
  <PropertyGroup>
    <ManifestKeyFile>AI-FileOrganizer2_TemporaryKey.pfx</ManifestKeyFile>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateManifests>true</GenerateManifests>
  </PropertyGroup>
  <PropertyGroup>
    <SignManifests>false</SignManifests>
  </PropertyGroup>
  <PropertyGroup>
    <ApplicationIcon>logo.ico</ApplicationIcon>
  </PropertyGroup>
  <PropertyGroup>
    <StartupObject>AI_FileOrganizer.Program</StartupObject>
  </PropertyGroup>
  <PropertyGroup>
    <SignAssembly>false</SignAssembly>
  </PropertyGroup>
  <PropertyGroup>
    <AssemblyOriginatorKeyFile>AIFileOrganizerKey.snk.pfx</AssemblyOriginatorKeyFile>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Azure.AI.OpenAI, Version=2.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8, processorArchitecture=MSIL">
      <HintPath>packages\Azure.AI.OpenAI.2.1.0\lib\netstandard2.0\Azure.AI.OpenAI.dll</HintPath>
    </Reference>
    <Reference Include="Azure.Core, Version=1.44.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8, processorArchitecture=MSIL">
      <HintPath>packages\Azure.Core.1.44.1\lib\net472\Azure.Core.dll</HintPath>
    </Reference>
    <Reference Include="CredentialManagement, Version=1.0.2.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>packages\CredentialManagement.1.0.2\lib\net35\CredentialManagement.dll</HintPath>
    </Reference>
    <Reference Include="CustomMarshalers" />
    <Reference Include="DocumentFormat.OpenXml, Version=3.3.0.0, Culture=neutral, PublicKeyToken=8fb06cb64d019a17, processorArchitecture=MSIL">
      <HintPath>packages\DocumentFormat.OpenXml.3.3.0\lib\net46\DocumentFormat.OpenXml.dll</HintPath>
    </Reference>
    <Reference Include="DocumentFormat.OpenXml.Framework, Version=3.3.0.0, Culture=neutral, PublicKeyToken=8fb06cb64d019a17, processorArchitecture=MSIL">
      <HintPath>packages\DocumentFormat.OpenXml.Framework.3.3.0\lib\net46\DocumentFormat.OpenXml.Framework.dll</HintPath>
    </Reference>
    <Reference Include="GenerativeAI, Version=2.5.10.0, Culture=neutral, PublicKeyToken=125a6b2231c8ea71, processorArchitecture=MSIL">
      <HintPath>packages\Google_GenerativeAI.2.5.10\lib\net462\GenerativeAI.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Bcl.AsyncInterfaces, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Bcl.AsyncInterfaces.9.0.3\lib\net462\Microsoft.Bcl.AsyncInterfaces.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Bcl.HashCode, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Bcl.HashCode.6.0.0\lib\net462\Microsoft.Bcl.HashCode.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.DependencyInjection, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.DependencyInjection.9.0.3\lib\net462\Microsoft.Extensions.DependencyInjection.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.DependencyInjection.Abstractions, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.DependencyInjection.Abstractions.9.0.3\lib\net462\Microsoft.Extensions.DependencyInjection.Abstractions.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Logging, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Logging.9.0.3\lib\net462\Microsoft.Extensions.Logging.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Logging.Abstractions, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Logging.Abstractions.9.0.3\lib\net462\Microsoft.Extensions.Logging.Abstractions.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Options, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Options.9.0.3\lib\net462\Microsoft.Extensions.Options.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Primitives, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Primitives.9.0.3\lib\net462\Microsoft.Extensions.Primitives.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.WindowsAPICodePack, Version=1.1.5.0, Culture=neutral, PublicKeyToken=8985beaab7ea3f04, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft-WindowsAPICodePack-Core.1.1.5\lib\net48\Microsoft.WindowsAPICodePack.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.WindowsAPICodePack.Shell, Version=1.1.5.0, Culture=neutral, PublicKeyToken=8985beaab7ea3f04, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft-WindowsAPICodePack-Shell.1.1.5\lib\net48\Microsoft.WindowsAPICodePack.Shell.dll</HintPath>
    </Reference>
    <Reference Include="Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
      <HintPath>packages\Newtonsoft.Json.13.0.3\lib\net45\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="OpenAI, Version=2.1.0.0, Culture=neutral, PublicKeyToken=b4187f3e65366280, processorArchitecture=MSIL">
      <HintPath>packages\OpenAI.2.1.0\lib\netstandard2.0\OpenAI.dll</HintPath>
    </Reference>
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="System" />
    <Reference Include="System.Buffers, Version=4.0.4.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Buffers.4.6.0\lib\net462\System.Buffers.dll</HintPath>
    </Reference>
    <Reference Include="System.ClientModel, Version=1.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8, processorArchitecture=MSIL">
      <HintPath>packages\System.ClientModel.1.2.1\lib\netstandard2.0\System.ClientModel.dll</HintPath>
    </Reference>
    <Reference Include="System.ComponentModel.Annotations, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.ComponentModel.Annotations.5.0.0\lib\net461\System.ComponentModel.Annotations.dll</HintPath>
    </Reference>
    <Reference Include="System.ComponentModel.Composition" />
    <Reference Include="System.ComponentModel.DataAnnotations" />
    <Reference Include="System.Core" />
    <Reference Include="System.Diagnostics.DiagnosticSource, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Diagnostics.DiagnosticSource.9.0.3\lib\net462\System.Diagnostics.DiagnosticSource.dll</HintPath>
    </Reference>
    <Reference Include="System.IO, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.4.3.0\lib\net462\System.IO.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.Pipelines, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.Pipelines.9.0.3\lib\net462\System.IO.Pipelines.dll</HintPath>
    </Reference>
    <Reference Include="System.Memory, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Memory.4.6.0\lib\net462\System.Memory.dll</HintPath>
    </Reference>
    <Reference Include="System.Memory.Data, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Memory.Data.6.0.0\lib\net461\System.Memory.Data.dll</HintPath>
    </Reference>
    <Reference Include="System.Net" />
    <Reference Include="System.Net.Http, Version=4.1.1.3, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Net.Http.4.3.4\lib\net46\System.Net.Http.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Numerics" />
    <Reference Include="System.Numerics.Vectors, Version=4.1.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Numerics.Vectors.4.6.0\lib\net462\System.Numerics.Vectors.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.4.3.0\lib\net462\System.Runtime.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.CompilerServices.Unsafe, Version=6.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.CompilerServices.Unsafe.6.1.0\lib\net462\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
    </Reference>
    <Reference Include="System.Security.Cryptography.Algorithms, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Algorithms.4.3.0\lib\net463\System.Security.Cryptography.Algorithms.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Encoding, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Encoding.4.3.0\lib\net46\System.Security.Cryptography.Encoding.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Primitives, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Primitives.4.3.0\lib\net46\System.Security.Cryptography.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.X509Certificates.4.3.0\lib\net461\System.Security.Cryptography.X509Certificates.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Text.Encodings.Web, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Text.Encodings.Web.9.0.3\lib\net462\System.Text.Encodings.Web.dll</HintPath>
    </Reference>
    <Reference Include="System.Text.Json, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Text.Json.9.0.3\lib\net462\System.Text.Json.dll</HintPath>
    </Reference>
    <Reference Include="System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Threading.Tasks.Extensions.4.5.4\lib\net461\System.Threading.Tasks.Extensions.dll</HintPath>
    </Reference>
    <Reference Include="System.ValueTuple, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.ValueTuple.4.5.0\lib\net47\System.ValueTuple.dll</HintPath>
    </Reference>
    <Reference Include="System.Web" />
    <Reference Include="System.Xaml" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="UglyToad.PdfPig, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Core, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Core.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.DocumentLayoutAnalysis, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.DocumentLayoutAnalysis.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Fonts, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Fonts.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Package, Version=0.1.10.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Package.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Tokenization, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Tokenization.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Tokens, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Tokens.dll</HintPath>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="WindowsFormsIntegration" />
    <Reference Include="Xceed.Document.NET, Version=5.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Document.NET.5.0.25228.6154\lib\net40\Xceed.Document.NET.dll</HintPath>
    </Reference>
    <Reference Include="Xceed.Drawing.NET, Version=1.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Drawing.NET.1.0.25228.6154\lib\net40\Xceed.Drawing.NET.dll</HintPath>
    </Reference>
    <Reference Include="Xceed.Pdf, Version=5.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Pdf.5.0.25228.6154\lib\net40\Xceed.Pdf.dll</HintPath>
    </Reference>
    <Reference Include="Xceed.Words.NET, Version=5.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Words.NET.5.0.25228.6154\lib\net40\Xceed.Words.NET.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="MainWindow.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="MainWindow.Designer.cs">
      <DependentUpon>MainWindow.cs</DependentUpon>
    </Compile>
    <Compile Include="FormRenameFile.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="FormRenameFile.Designer.cs">
      <DependentUpon>FormRenameFile.cs</DependentUpon>
    </Compile>
    <Compile Include="Models\ApplicationSettings.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Services\AiClassificationService.cs" />
    <Compile Include="Services\AzureOpenAiProvider.cs" />
    <Compile Include="Services\CredentialStorageService.cs" />
    <Compile Include="Services\DocxTextExtractor.cs" />
    <Compile Include="Services\FileOrganizerService.cs" />
    <Compile Include="Services\GeminiAiProvider.cs" />
    <Compile Include="Services\IaProvider.cs" />
    <Compile Include="Services\ITextExtractor.cs" />
    <Compile Include="Services\OpenAiProvider.cs" />
    <Compile Include="Services\PdfTextExtractor.cs" />
    <Compile Include="Services\PlainTextExtractor.cs" />
    <Compile Include="Services\TextExtractionService.cs" />
    <Compile Include="Utils\BatchOrExeRunner.cs" />
    <Compile Include="Utils\FileLogger.cs" />
    <Compile Include="Utils\FileUtil.cs" />
    <Compile Include="Utils\ILogger.cs" />
    <Compile Include="Utils\PersoonlijkeMappenStructuurGenerator.cs" />
    <Compile Include="Utils\UiLogger.cs" />
    <EmbeddedResource Include="MainWindow.resx">
      <DependentUpon>MainWindow.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="FormRenameFile.resx">
      <DependentUpon>FormRenameFile.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
      <DesignTime>True</DesignTime>
    </Compile>
    <None Include="AIFileOrganizerKey.snk.pfx" />
    <None Include="appsettings.json" />
    <None Include="packages.config" />
    <None Include="PersoonlijkeMappenGenerator\Persoonlijke Administratie.zip">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </None>
    <None Include="PersoonlijkeMappenGenerator\PersoonlijkeMappenStructuurGenerator.bat" />
    <None Include="PersoonlijkeMappenGenerator\README.md" />
    <None Include="PersoonlijkeMappenGenerator\test2.bat" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <None Include="README.md" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.8">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.8 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup />
  <ItemGroup>
    <Content Include="Installer\AI-applicatie.txt" />
    <Content Include="Installer\AI-FileOrganizerSetup.exe" />
    <Content Include="Installer\AI-fileorganizer_screenshot.png" />
    <Content Include="Installer\AI-FolderInno.iss" />
    <Content Include="Installer\installatie-informatie.txt" />
    <Content Include="Installer\MIT License %28MIT-licentie%29.txt" />
    <Content Include="Installer\na-installatie-informatie.txt" />
    <Content Include="logo.ico" />
    <Content Include="Media\AIFileOrganizer_CompleteWalkthrough.mp4" />
    <Content Include="Media\AIFileOrganizer_Demo.gif" />
    <Content Include="Media\logo.ico" />
    <Content Include="Media\logo.png" />
    <Content Include="Media\logo_4.png" />
    <Content Include="PersoonlijkeMappenGenerator\.gitattributes" />
    <Content Include="PersoonlijkeMappenGenerator\map_structuur.txt">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Content>
    <Content Include="PersoonlijkeMappenGenerator\PersoonlijkeMappenStructuurGenerator.exe">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Content>
    <Content Include="PersoonlijkeMappenGenerator\PersoonlijkeMappenStructuurGenerator.gif" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>


================================================
FILE: AI-FileOrganizer.sln
================================================
Ôªø
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34723.18
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AI-FileOrganizer", "AI-FileOrganizer.csproj", "{A58EBE3F-C926-432E-B874-AD6F29494AC7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {94165174-0940-4E0D-9C1C-FAE76A986586}
	EndGlobalSection
EndGlobal



================================================
FILE: App.config
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.1.0" newVersion="6.0.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.4.0" newVersion="4.0.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.5.0" newVersion="4.1.5.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.3" newVersion="9.0.0.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.3" newVersion="9.0.0.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.3" newVersion="9.0.0.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.ClientModel" publicKeyToken="92742159e12e44c8" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.2.1.0" newVersion="1.2.1.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>


================================================
FILE: appsettings.json
================================================
Ôªøusing System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AI_FileOrganizer
{
  class appsettings
  {
    "OpenAIKey": "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

  }
}



================================================
FILE: FormRenameFile.cs
================================================
Ôªøusing System;
using System.IO;
using System.Linq; // This using statement is explicitly needed for .Any() and .Contains()
using System.Windows.Forms;

namespace AI_FileOrganizer
{
    public partial class FormRenameFile : Form
    {
        public string NewFileName { get; private set; }
        public bool SkipFile { get; private set; } = false;

        public FormRenameFile(string originalFileName, string suggestedFileName)
        {
            InitializeComponent(); // This call links to the FormRenameFile.Designer.cs file
            lblOriginalFileName.Text = originalFileName;
            txtSuggestedFileName.Text = suggestedFileName;
            NewFileName = suggestedFileName; // Default value
        }

        private void btnSave_Click(object sender, EventArgs e)
        {
            string newName = txtSuggestedFileName.Text.Trim();
            if (string.IsNullOrWhiteSpace(newName))
            {
                MessageBox.Show("De nieuwe bestandsnaam mag niet leeg zijn.", "Ongeldige naam", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Basis validatie: verwijder ongeldige karakters voor bestandsnamen
            char[] invalidChars = Path.GetInvalidFileNameChars();
            if (newName.Any(c => invalidChars.Contains(c)))
            {
                MessageBox.Show($"De nieuwe bestandsnaam bevat ongeldige karakters. Vermijd: {string.Join("", invalidChars)}", "Ongeldige naam", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            NewFileName = newName;
            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void btnSkip_Click(object sender, EventArgs e)
        {
            SkipFile = true;
            this.DialogResult = DialogResult.OK; // Gebruik OK om aan te geven dat een beslissing is genomen (overslaan)
            this.Close();
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        private void FormRenameFile_Load(object sender, EventArgs e)
        {
            // Any specific load logic for the form
        }
    }
}


================================================
FILE: FormRenameFile.Designer.cs
================================================
Ôªøusing System.Linq; // Although not strictly needed for designer code, it was in your original.

namespace AI_FileOrganizer
{
    partial class FormRenameFile
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.lblOriginalFileName = new System.Windows.Forms.Label();
            this.txtSuggestedFileName = new System.Windows.Forms.TextBox();
            this.btnSave = new System.Windows.Forms.Button();
            this.btnSkip = new System.Windows.Forms.Button();
            this.btnCancel = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.SuspendLayout();
            //
            // lblOriginalFileName
            //
            this.lblOriginalFileName.AutoSize = true;
            this.lblOriginalFileName.Location = new System.Drawing.Point(145, 23);
            this.lblOriginalFileName.Name = "lblOriginalFileName";
            this.lblOriginalFileName.Size = new System.Drawing.Size(150, 16);
            this.lblOriginalFileName.TabIndex = 0;
            this.lblOriginalFileName.Text = "[Oorspronkelijke Naam]";
            //
            // txtSuggestedFileName
            //
            this.txtSuggestedFileName.Location = new System.Drawing.Point(148, 62);
            this.txtSuggestedFileName.Name = "txtSuggestedFileName";
            this.txtSuggestedFileName.Size = new System.Drawing.Size(300, 22);
            this.txtSuggestedFileName.TabIndex = 1;
            //
            // btnSave
            //
            this.btnSave.Location = new System.Drawing.Point(148, 105);
            this.btnSave.Name = "btnSave";
            this.btnSave.Size = new System.Drawing.Size(95, 30);
            this.btnSave.TabIndex = 2;
            this.btnSave.Text = "Opslaan";
            this.btnSave.UseVisualStyleBackColor = true;
            this.btnSave.Click += new System.EventHandler(this.btnSave_Click);
            //
            // btnSkip
            //
            this.btnSkip.Location = new System.Drawing.Point(249, 105);
            this.btnSkip.Name = "btnSkip";
            this.btnSkip.Size = new System.Drawing.Size(95, 30);
            this.btnSkip.TabIndex = 3;
            this.btnSkip.Text = "Overslaan";
            this.btnSkip.UseVisualStyleBackColor = true;
            this.btnSkip.Click += new System.EventHandler(this.btnSkip_Click);
            //
            // btnCancel
            //
            this.btnCancel.Location = new System.Drawing.Point(350, 105);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(98, 30);
            this.btnCancel.TabIndex = 4;
            this.btnCancel.Text = "Annuleren";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            //
            // label1
            //
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(22, 23);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(101, 16);
            this.label1.TabIndex = 5;
            this.label1.Text = "Originele naam:";
            //
            // label2
            //
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(22, 65);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(129, 16);
            this.label2.TabIndex = 6;
            this.label2.Text = "Voorgestelde naam:";
            //
            // FormRenameFile
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(477, 158);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnSkip);
            this.Controls.Add(this.btnSave);
            this.Controls.Add(this.txtSuggestedFileName);
            this.Controls.Add(this.lblOriginalFileName);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "FormRenameFile";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Bestandsnaam Aanpassen";
            this.Load += new System.EventHandler(this.FormRenameFile_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label lblOriginalFileName;
        private System.Windows.Forms.TextBox txtSuggestedFileName;
        private System.Windows.Forms.Button btnSave;
        private System.Windows.Forms.Button btnSkip;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
    }
}


================================================
FILE: FormRenameFile.resx
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
FILE: MainWindow.cs
================================================
Ôªøusing System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http; 
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Microsoft.WindowsAPICodePack.Dialogs; 

using AI_FileOrganizer.Services;
using AI_FileOrganizer.Utils;
using AI_FileOrganizer.Models; 
using ILogger = AI_FileOrganizer.Utils.ILogger;

namespace AI_FileOrganizer
{
    public partial class MainWindow : Form
    {
        private readonly ILogger _logger; // Logt naar UI
        private static readonly HttpClient _httpClient = new HttpClient(); // Hergebruik voor API-calls
        private long _totalTokensUsed = 0; // Voor tonen in UI
        private CancellationTokenSource _cancellationTokenSource;

        // Services voor hoofdlogica
        private readonly FileOrganizerService _fileOrganizerService;
        private readonly AiClassificationService _aiService;
        private readonly TextExtractionService _textExtractionService;
        private readonly CredentialStorageService _credentialStorageService;

        public MainWindow()
        {
            InitializeComponent();

            // Init logging en onderliggende services
            _logger = new UiLogger(rtbLog);
            _aiService = new AiClassificationService(_logger);
            _credentialStorageService = new CredentialStorageService(_logger);
            _textExtractionService = new TextExtractionService(
                _logger,
                new List<ITextExtractor>
                {
                    new PdfTextExtractor(_logger),
                    new DocxTextExtractor(_logger),
                    new PlainTextExtractor(_logger)
                }
            );

            _fileOrganizerService = new FileOrganizerService(
                _logger,
                _aiService,
                _textExtractionService,
                _credentialStorageService,
                _httpClient
            );

            // UI-progress en events koppelen aan de service
            _fileOrganizerService.ProgressChanged += (current, total) =>
            {
                if (progressBar1.InvokeRequired)
                    progressBar1.BeginInvoke(new Action(() => { progressBar1.Maximum = total; progressBar1.Value = current; }));
                else
                {
                    progressBar1.Maximum = total;
                    progressBar1.Value = current;
                }
            };
            _fileOrganizerService.TokensUsedUpdated += (tokens) =>
            {
                _totalTokensUsed += tokens;
                UpdateTokensUsedLabel();
            };

            // Callback voor interactieve rename
            _fileOrganizerService.RequestRenameFile += (originalName, suggestedName) =>
            {
                // UI-aanroep op main thread
                return Invoke((Func<Task<(DialogResult, string, bool)>>)(() =>
                {
                    using (var renameForm = new FormRenameFile(originalName, suggestedName))
                    {
                        DialogResult result = renameForm.ShowDialog();
                        return Task.FromResult((result, renameForm.NewFileName, renameForm.SkipFile));
                    }
                })) as Task<(DialogResult, string, bool)>;
            };

            _cancellationTokenSource = new CancellationTokenSource();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // Init providerselectie en standaardwaarden UI
            if (cmbProviderSelection.Items.Count == 0)
            {
                cmbProviderSelection.Items.AddRange(new object[]
                {
                    "Gemini (Google)",
                    "OpenAI (openai.com)",
                    "Azure OpenAI"
                });
            }
            cmbProviderSelection.SelectedIndexChanged -= cmbProviderSelection_SelectedIndexChanged;
            cmbProviderSelection.SelectedIndexChanged += cmbProviderSelection_SelectedIndexChanged;
            cmbProviderSelection.SelectedIndex = 0; // Zet eerste provider (triggert ook modelkeuze)

            txtApiKey.Text = "YOUR_GOOGLE_API_KEY_HERE";
            SetupApiKeyPlaceholder(txtApiKey, "YOUR_GOOGLE_API_KEY_HERE");
            txtApiKey.UseSystemPasswordChar = true;

            string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
            string documentsPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            txtSourceFolder.Text = Path.Combine(desktopPath, "AI Organizer Bronmap");
            txtDestinationFolder.Text = Path.Combine(documentsPath, "AI Organizer Resultaat");

            lblTokensUsed.Text = "Tokens gebruikt: 0";
            progressBar1.Minimum = 0;
            progressBar1.Value = 0;
            progressBar1.Style = ProgressBarStyle.Continuous;
            progressBar1.Visible = false;
            btnStopOrganization.Enabled = false;
            btnSaveLog.Enabled = false;
            chkRenameFiles.Checked = false;
            lblAzureEndpoint.Visible = false;
            txtAzureEndpoint.Visible = false;

            LoadApiKeyForSelectedProvider();
            // Toon tip voor mappenstructuur
         //   MessageBox.Show(
       //         "üîî Tip: Klik allereerst op ‚ÄòStandaardfolderstructuur‚Äô (rechts in het midden) om een mappenstructuur aan te maken. Dit werkt zelfs zonder API key",
         //       "Eerste stap: mappenstructuur maken",
          //      MessageBoxButtons.OK,
         //       MessageBoxIcon.Information
         //   );
        }

        /// <summary>
        /// Laad API-key (en evt. Azure endpoint) uit Credential Manager op basis van provider.
        /// </summary>
        /// <summary>
        /// Laad de API-key (en evt. Azure endpoint) uit Credential Manager op basis van provider en
        /// zet deze altijd correct zichtbaar in het textfield. Als er geen key is, toon je een placeholder.
        /// </summary>
        private void LoadApiKeyForSelectedProvider()
        {
            string selectedProviderName = cmbProviderSelection.SelectedItem?.ToString() ?? "";
            (string loadedApiKey, string loadedAzureEndpoint) = _credentialStorageService.GetApiKey(selectedProviderName);

            // --- API KEY TEXTBOX ---
            if (!string.IsNullOrWhiteSpace(loadedApiKey))
            {
                // Toon de gevonden key als zwarte tekst
                txtApiKey.Text = loadedApiKey;
                txtApiKey.ForeColor = System.Drawing.Color.Black;
                txtApiKey.Tag = GetDefaultApiKeyPlaceholder(selectedProviderName); // Zorg dat de Tag klopt voor placeholder logic
            }
            else
            {
                // Geen opgeslagen key? Toon placeholder in grijs
                txtApiKey.Text = GetDefaultApiKeyPlaceholder(selectedProviderName);
                txtApiKey.ForeColor = System.Drawing.Color.Gray;
                txtApiKey.Tag = GetDefaultApiKeyPlaceholder(selectedProviderName);
            }

            // --- AZURE ENDPOINT TEXTBOX (alleen voor Azure OpenAI) ---
            if (selectedProviderName == "Azure OpenAI")
            {
                if (!string.IsNullOrWhiteSpace(loadedAzureEndpoint))
                {
                    txtAzureEndpoint.Text = loadedAzureEndpoint;
                    txtAzureEndpoint.ForeColor = System.Drawing.Color.Black;
                    txtAzureEndpoint.Tag = "YOUR_AZURE_ENDPOINT_HERE";
                }
                else
                {
                    txtAzureEndpoint.Text = "YOUR_AZURE_ENDPOINT_HERE";
                    txtAzureEndpoint.ForeColor = System.Drawing.Color.Gray;
                    txtAzureEndpoint.Tag = "YOUR_AZURE_ENDPOINT_HERE";
                }
            }
            else
            {
                txtAzureEndpoint.Text = "YOUR_AZURE_ENDPOINT_HERE";
                txtAzureEndpoint.ForeColor = System.Drawing.Color.Gray;
                txtAzureEndpoint.Tag = "YOUR_AZURE_ENDPOINT_HERE";
            }
        }

        private string GetDefaultApiKeyPlaceholder(string providerName)
        {
            if (providerName.Contains("Gemini")) return "YOUR_GOOGLE_API_KEY_HERE";
            if (providerName.Contains("OpenAI (openai.com)")) return "YOUR_OPENAI_API_KEY_HERE";
            if (providerName.Contains("Azure OpenAI")) return "YOUR_AZURE_ENDPOINT_HERE";
            return "YOUR_API_KEY_HERE";
        }

        /// <summary>
        /// Update modellenlijst en API-key veld bij wisselen van provider.
        /// </summary>
        private void cmbProviderSelection_SelectedIndexChanged(object sender, EventArgs e)
        {
            cmbModelSelection.Items.Clear();
            string provider = cmbProviderSelection.SelectedItem?.ToString() ?? "";
            if (provider == "Gemini (Google)")
            {
                cmbModelSelection.Items.AddRange(new object[] { "gemini-1.5-pro-latest", "gemini-1.5-flash-latest", "gemini-1.0-pro-latest", "gemini-pro", "gemini-2.5-pro-preview-05-06", "gemini-2.5-flash-preview-04-17", "gemini-2.0-flash-001", "gemini-2.0-flash-lite-001" });
                lblApiKey.Text = "Google API Key:";
                lblAzureEndpoint.Visible = false;
                txtAzureEndpoint.Visible = false;
            }
            else if (provider == "OpenAI (openai.com)")
            {
                cmbModelSelection.Items.AddRange(new object[] { "gpt-4o", "gpt-4-turbo", "gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-0125", "gpt-3.5-turbo-0613" });
                lblApiKey.Text = "OpenAI API Key:";
                lblAzureEndpoint.Visible = false;
                txtAzureEndpoint.Visible = false;
            }
            else if (provider == "Azure OpenAI")
            {
                cmbModelSelection.Items.AddRange(new object[] { "YOUR-AZURE-DEPLOYMENT-NAME" });
                lblApiKey.Text = "Azure OpenAI API Key:";
                lblAzureEndpoint.Visible = true;
                txtAzureEndpoint.Visible = true;
            }
            cmbModelSelection.SelectedIndex = 0;
            LoadApiKeyForSelectedProvider();
        }

        /// <summary>
        /// Plaatst placeholder text in een TextBox en regelt kleur.
        /// </summary>
        private void SetupApiKeyPlaceholder(TextBox textBox, string placeholderText)
        {
            textBox.GotFocus -= RemoveApiKeyPlaceholderInternal;
            textBox.LostFocus -= AddApiKeyPlaceholderInternal;
            textBox.Tag = placeholderText;

            if (string.IsNullOrWhiteSpace(textBox.Text) || textBox.Text == placeholderText)
            {
                textBox.Text = placeholderText;
                textBox.ForeColor = System.Drawing.Color.Gray;
            }
            else
            {
                textBox.ForeColor = System.Drawing.Color.Black;
            }

            textBox.GotFocus += RemoveApiKeyPlaceholderInternal;
            textBox.LostFocus += AddApiKeyPlaceholderInternal;
        }

        private void RemoveApiKeyPlaceholderInternal(object sender, EventArgs e)
        {
            TextBox textBox = sender as TextBox;
            string placeholderText = textBox.Tag?.ToString();
            if (textBox.Text == placeholderText)
            {
                textBox.Text = "";
                textBox.ForeColor = System.Drawing.Color.Black;
            }
        }

        private void AddApiKeyPlaceholderInternal(object sender, EventArgs e)
        {
            TextBox textBox = sender as TextBox;
            string placeholderText = textBox.Tag?.ToString();
            if (string.IsNullOrWhiteSpace(textBox.Text))
            {
                textBox.Text = placeholderText;
                textBox.ForeColor = System.Drawing.Color.Gray;
            }
        }

        /// <summary>
        /// Moderne folderdialog voor bronmap selectie.
        /// </summary>
        private void btnSelectSourceFolder_Click(object sender, EventArgs e)
        {
            using (var dialog = new CommonOpenFileDialog())
            {
                dialog.IsFolderPicker = true;
                dialog.Title = "Selecteer de bronmap met bestanden (inclusief submappen)";
                dialog.InitialDirectory = Directory.Exists(txtSourceFolder.Text) ? txtSourceFolder.Text : Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
                dialog.RestoreDirectory = true;
                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    txtSourceFolder.Text = dialog.FileName;
                }
            }
        }

        /// <summary>
        /// Moderne folderdialog voor doelmap selectie.
        /// </summary>
        private void btnSelectDestinationFolder_Click(object sender, EventArgs e)
        {
            using (var dialog = new CommonOpenFileDialog())
            {
                dialog.IsFolderPicker = true;
                dialog.Title = "Selecteer de doelmap voor geordende bestanden";
                dialog.EnsurePathExists = true;
                dialog.InitialDirectory = Directory.Exists(txtDestinationFolder.Text) ? txtDestinationFolder.Text : Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                dialog.RestoreDirectory = true;
                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    txtDestinationFolder.Text = dialog.FileName;
                }
            }
        }

        /// <summary>
        /// Start bestandsorganisatieproces.
        /// </summary>
        private async void btnStartOrganization_Click(object sender, EventArgs e)
        {
            rtbLog.Clear();
            SetUiEnabled(false);
            btnStopOrganization.Enabled = true;
            btnSaveLog.Enabled = false;
            progressBar1.Visible = true;

            string apiKey = txtApiKey.Text;
            string currentApiKeyPlaceholder = txtApiKey.Tag?.ToString();
            if (string.IsNullOrWhiteSpace(apiKey) || apiKey == currentApiKeyPlaceholder)
            {
                _logger.Log("FOUT: Gelieve een geldige API Key in te vullen.");
                SetUiEnabled(true); btnStopOrganization.Enabled = false; progressBar1.Visible = false; return;
            }

            string providerName = cmbProviderSelection.SelectedItem?.ToString() ?? "";
            string azureEndpoint = txtAzureEndpoint.Text;
            string selectedModel = cmbModelSelection.SelectedItem?.ToString() ?? "gemini-1.5-pro-latest";

            if (!Directory.Exists(txtSourceFolder.Text))
            {
                _logger.Log($"FOUT: Bronmap '{txtSourceFolder.Text}' niet gevonden.");
                SetUiEnabled(true); btnStopOrganization.Enabled = false; progressBar1.Visible = false; return;
            }

            _logger.Log($"Starten met organiseren van bestanden uit: {txtSourceFolder.Text} (inclusief submappen)");
            _logger.Log($"Gebruikt model: {selectedModel}");
            if (chkRenameFiles.Checked)
            {
                _logger.Log("Bestandsnamen worden hernoemd met AI-suggesties.");
            }

            _totalTokensUsed = 0;
            UpdateTokensUsedLabel();
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = new CancellationTokenSource();

            try
            {
                await _fileOrganizerService.OrganizeFilesAsync(
                    txtSourceFolder.Text,
                    txtDestinationFolder.Text,
                    apiKey,
                    providerName,
                    selectedModel,
                    azureEndpoint,
                    chkRenameFiles.Checked,
                    _cancellationTokenSource.Token
                );
            }
            catch (OperationCanceledException)
            {
                _logger.Log("\nOrganisatie geannuleerd door gebruiker.");
            }
            catch (Exception ex)
            {
                _logger.Log($"KRITIEKE FOUT tijdens organisatie: {ex.Message}");
            }
            finally
            {
                _logger.Log("\nOrganisatie voltooid!");
                SetUiEnabled(true);
                btnStopOrganization.Enabled = false;
                btnSaveLog.Enabled = true;
                progressBar1.Visible = false;
                _cancellationTokenSource.Dispose();
                _cancellationTokenSource = null;
            }
        }

        /// <summary>
        /// Annuleert huidig organisatieproces.
        /// </summary>
        private void btnStopOrganization_Click(object sender, EventArgs e)
        {
            _cancellationTokenSource?.Cancel();
            _logger.Log("Annulering aangevraagd...");
            btnStopOrganization.Enabled = false;
        }

        /// <summary>
        /// Sla logbestand op via moderne dialoog.
        /// </summary>
        private void btnSaveLog_Click(object sender, EventArgs e)
        {
            using (var dialog = new CommonSaveFileDialog())
            {
                dialog.Filters.Add(new CommonFileDialogFilter("Tekstbestanden", "*.txt"));
                dialog.DefaultExtension = "txt";
                dialog.Title = "Sla logbestand op";
                dialog.DefaultFileName = $"AI_Organizer_Log_{DateTime.Now:yyyyMMdd_HHmmss}.txt";
                dialog.InitialDirectory = Directory.Exists(txtDestinationFolder.Text) ? txtDestinationFolder.Text : Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                dialog.RestoreDirectory = true;

                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    try
                    {
                        File.WriteAllText(dialog.FileName, rtbLog.Text);
                        MessageBox.Show("Logbestand succesvol opgeslagen.", "Succes", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Fout bij opslaan: {ex.Message}", "Fout", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        /// <summary>
        /// Schakelt UI-elementen in/uit.
        /// </summary>
        private void SetUiEnabled(bool enabled)
        {
            txtApiKey.Enabled = enabled;
            txtSourceFolder.Enabled = enabled;
            btnSelectSourceFolder.Enabled = enabled;
            txtDestinationFolder.Enabled = enabled;
            btnSelectDestinationFolder.Enabled = enabled;
            cmbModelSelection.Enabled = enabled;
            cmbProviderSelection.Enabled = enabled;
            txtAzureEndpoint.Enabled = enabled;
            btnStartOrganization.Enabled = enabled;
            btnRenameSingleFile.Enabled = enabled;
            linkLabelAuthor.Enabled = enabled;
            chkRenameFiles.Enabled = enabled;
        }

        /// <summary>
        /// Update token label (UI-thread safe).
        /// </summary>
        private void UpdateTokensUsedLabel()
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(UpdateTokensUsedLabel));
                return;
            }
            lblTokensUsed.Text = $"Tokens gebruikt: {_totalTokensUsed}";
        }

        /// <summary>
        /// Open LinkedIn van auteur.
        /// </summary>
        private void linkLabelAuthor_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            try
            {
                string url = "https://www.linkedin.com/in/remseymailjard/";
                Process.Start(new ProcessStartInfo
                {
                    FileName = url,
                    UseShellExecute = true
                });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Kan link niet openen: {ex.Message}", "Fout", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        /// <summary>
        /// Hernaam √©√©n bestand via AI met moderne file-dialog.
        /// </summary>
        private async void btnRenameSingleFile_Click(object sender, EventArgs e)
        {
            rtbLog.Clear();
            SetUiEnabled(false);
            btnStopOrganization.Enabled = false;
            btnSaveLog.Enabled = false;
            progressBar1.Visible = false;

            string apiKey = txtApiKey.Text;
            if (string.IsNullOrWhiteSpace(apiKey) || (txtApiKey.Tag != null && apiKey == txtApiKey.Tag.ToString()))
            {
                _logger.Log("FOUT: Gelieve een geldige API Key in te vullen.");
                SetUiEnabled(true); return;
            }

            string selectedModel = cmbModelSelection.SelectedItem?.ToString() ?? "gemini-1.5-pro-latest";
            string providerName = cmbProviderSelection.SelectedItem?.ToString() ?? "Gemini (Google)";
            string azureEndpoint = txtAzureEndpoint?.Text;

            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = new CancellationTokenSource();

            using (var dialog = new CommonOpenFileDialog())
            {
                dialog.IsFolderPicker = false;
                dialog.EnsureFileExists = true;
                dialog.Multiselect = false;
                dialog.Title = "Selecteer een bestand om te hernoemen";
                dialog.Filters.Add(new CommonFileDialogFilter("Ondersteunde bestanden", "*.pdf;*.docx;*.txt;*.md"));
                dialog.Filters.Add(new CommonFileDialogFilter("PDF Bestanden", "*.pdf"));
                dialog.Filters.Add(new CommonFileDialogFilter("Word Documenten", "*.docx"));
                dialog.Filters.Add(new CommonFileDialogFilter("Tekst Bestanden", "*.txt;*.md"));
                dialog.Filters.Add(new CommonFileDialogFilter("Alle Bestanden", "*.*"));
                dialog.InitialDirectory = txtSourceFolder.Text;
                dialog.RestoreDirectory = true;

                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    string filePath = dialog.FileName;
                    try
                    {
                        await _fileOrganizerService.RenameSingleFileInteractiveAsync(
                            filePath,
                            apiKey,
                            providerName,
                            selectedModel,
                            azureEndpoint,
                            _cancellationTokenSource.Token
                        );
                    }
                    catch (OperationCanceledException)
                    {
                        _logger.Log("Hernoem-actie geannuleerd door gebruiker.");
                    }
                    catch (Exception ex)
                    {
                        _logger.Log($"KRITIEKE FOUT tijdens enkel bestand hernoemen: {ex.Message}");
                    }
                }
                else
                {
                    _logger.Log("Bestandselectie geannuleerd. Geen bestand hernoemd.");
                }
            }
            SetUiEnabled(true);
            btnSaveLog.Enabled = true;
            _cancellationTokenSource.Dispose();
            _cancellationTokenSource = null;
        }

        private void btnGenerateStandardFolders_Click(object sender, EventArgs e)
        {
            try
            {
                var generator = new AI_FileOrganizer.Utils.PersoonlijkeMappenStructuurGenerator();
                generator.Start();
            }
            catch (Exception ex)
            {
                MessageBox.Show("Er is een fout opgetreden bij het aanmaken van de mappenstructuur:\n\n" + ex.Message, "Fout", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

    }
}



================================================
FILE: MainWindow.Designer.cs
================================================
Ôªønamespace AI_FileOrganizer
{
    partial class MainWindow
    {
        private System.ComponentModel.IContainer components = null;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainWindow));
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.lblProvider = new System.Windows.Forms.Label();
            this.cmbProviderSelection = new System.Windows.Forms.ComboBox();
            this.lblApiKey = new System.Windows.Forms.Label();
            this.txtApiKey = new System.Windows.Forms.TextBox();
            this.lblAzureEndpoint = new System.Windows.Forms.Label();
            this.txtAzureEndpoint = new System.Windows.Forms.TextBox();
            this.lblSourceFolder = new System.Windows.Forms.Label();
            this.txtSourceFolder = new System.Windows.Forms.TextBox();
            this.btnSelectSourceFolder = new System.Windows.Forms.Button();
            this.lblDestinationFolder = new System.Windows.Forms.Label();
            this.txtDestinationFolder = new System.Windows.Forms.TextBox();
            this.btnSelectDestinationFolder = new System.Windows.Forms.Button();
            this.lblModel = new System.Windows.Forms.Label();
            this.cmbModelSelection = new System.Windows.Forms.ComboBox();
            this.chkRenameFiles = new System.Windows.Forms.CheckBox();
            this.btnStartOrganization = new System.Windows.Forms.Button();
            this.btnStopOrganization = new System.Windows.Forms.Button();
            this.btnSaveLog = new System.Windows.Forms.Button();
            this.btnRenameSingleFile = new System.Windows.Forms.Button();
            this.btnGenerateStandardFolders = new System.Windows.Forms.Button();
            this.progressBar1 = new System.Windows.Forms.ProgressBar();
            this.lblTokensUsed = new System.Windows.Forms.Label();
            this.rtbLog = new System.Windows.Forms.RichTextBox();
            this.linkLabelAuthor = new System.Windows.Forms.LinkLabel();
            this.tableLayoutPanel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // tableLayoutPanel1
            // 
            this.tableLayoutPanel1.ColumnCount = 3;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 20F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 60F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 20F));
            this.tableLayoutPanel1.Controls.Add(this.lblProvider, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.cmbProviderSelection, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.lblApiKey, 0, 1);
            this.tableLayoutPanel1.Controls.Add(this.txtApiKey, 1, 1);
            this.tableLayoutPanel1.Controls.Add(this.lblAzureEndpoint, 0, 2);
            this.tableLayoutPanel1.Controls.Add(this.txtAzureEndpoint, 1, 2);
            this.tableLayoutPanel1.Controls.Add(this.lblSourceFolder, 0, 3);
            this.tableLayoutPanel1.Controls.Add(this.txtSourceFolder, 1, 3);
            this.tableLayoutPanel1.Controls.Add(this.btnSelectSourceFolder, 2, 3);
            this.tableLayoutPanel1.Controls.Add(this.lblDestinationFolder, 0, 4);
            this.tableLayoutPanel1.Controls.Add(this.txtDestinationFolder, 1, 4);
            this.tableLayoutPanel1.Controls.Add(this.btnSelectDestinationFolder, 2, 4);
            this.tableLayoutPanel1.Controls.Add(this.lblModel, 0, 5);
            this.tableLayoutPanel1.Controls.Add(this.cmbModelSelection, 1, 5);
            this.tableLayoutPanel1.Controls.Add(this.chkRenameFiles, 0, 6);
            this.tableLayoutPanel1.Controls.Add(this.btnStartOrganization, 0, 7);
            this.tableLayoutPanel1.Controls.Add(this.btnStopOrganization, 1, 7);
            this.tableLayoutPanel1.Controls.Add(this.btnSaveLog, 2, 7);
            this.tableLayoutPanel1.Controls.Add(this.btnRenameSingleFile, 0, 8);
            this.tableLayoutPanel1.Controls.Add(this.btnGenerateStandardFolders, 2, 8);
            this.tableLayoutPanel1.Controls.Add(this.progressBar1, 0, 9);
            this.tableLayoutPanel1.Controls.Add(this.lblTokensUsed, 2, 9);
            this.tableLayoutPanel1.Controls.Add(this.rtbLog, 0, 10);
            this.tableLayoutPanel1.Controls.Add(this.linkLabelAuthor, 0, 11);
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.RowCount = 13;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 25F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 36F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 36F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 22F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 26F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 2F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(850, 480);
            this.tableLayoutPanel1.TabIndex = 0;
            // 
            // lblProvider
            // 
            this.lblProvider.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblProvider.AutoSize = true;
            this.lblProvider.Location = new System.Drawing.Point(3, 5);
            this.lblProvider.Name = "lblProvider";
            this.lblProvider.Size = new System.Drawing.Size(65, 17);
            this.lblProvider.TabIndex = 0;
            this.lblProvider.Text = "Provider:";
            // 
            // cmbProviderSelection
            // 
            this.cmbProviderSelection.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.cmbProviderSelection, 2);
            this.cmbProviderSelection.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbProviderSelection.Items.AddRange(new object[] {
            "Gemini (Google)",
            "OpenAI (openai.com)",
            "Azure OpenAI"});
            this.cmbProviderSelection.Location = new System.Drawing.Point(173, 3);
            this.cmbProviderSelection.Name = "cmbProviderSelection";
            this.cmbProviderSelection.Size = new System.Drawing.Size(674, 24);
            this.cmbProviderSelection.TabIndex = 1;
            this.cmbProviderSelection.SelectedIndexChanged += new System.EventHandler(this.cmbProviderSelection_SelectedIndexChanged);
            // 
            // lblApiKey
            // 
            this.lblApiKey.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblApiKey.AutoSize = true;
            this.lblApiKey.Location = new System.Drawing.Point(3, 33);
            this.lblApiKey.Name = "lblApiKey";
            this.lblApiKey.Size = new System.Drawing.Size(111, 17);
            this.lblApiKey.TabIndex = 2;
            this.lblApiKey.Text = "Google API Key:";
            // 
            // txtApiKey
            // 
            this.txtApiKey.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.txtApiKey, 2);
            this.txtApiKey.Location = new System.Drawing.Point(173, 31);
            this.txtApiKey.Name = "txtApiKey";
            this.txtApiKey.Size = new System.Drawing.Size(674, 22);
            this.txtApiKey.TabIndex = 3;
            this.txtApiKey.UseSystemPasswordChar = true;
            // 
            // lblAzureEndpoint
            // 
            this.lblAzureEndpoint.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblAzureEndpoint.AutoSize = true;
            this.lblAzureEndpoint.Location = new System.Drawing.Point(3, 61);
            this.lblAzureEndpoint.Name = "lblAzureEndpoint";
            this.lblAzureEndpoint.Size = new System.Drawing.Size(109, 17);
            this.lblAzureEndpoint.TabIndex = 4;
            this.lblAzureEndpoint.Text = "Azure Endpoint:";
            this.lblAzureEndpoint.Visible = false;
            // 
            // txtAzureEndpoint
            // 
            this.txtAzureEndpoint.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.txtAzureEndpoint, 2);
            this.txtAzureEndpoint.Location = new System.Drawing.Point(173, 59);
            this.txtAzureEndpoint.Name = "txtAzureEndpoint";
            this.txtAzureEndpoint.Size = new System.Drawing.Size(674, 22);
            this.txtAzureEndpoint.TabIndex = 5;
            this.txtAzureEndpoint.Visible = false;
            // 
            // lblSourceFolder
            // 
            this.lblSourceFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblSourceFolder.AutoSize = true;
            this.lblSourceFolder.Location = new System.Drawing.Point(3, 89);
            this.lblSourceFolder.Name = "lblSourceFolder";
            this.lblSourceFolder.Size = new System.Drawing.Size(101, 17);
            this.lblSourceFolder.TabIndex = 6;
            this.lblSourceFolder.Text = "Source Folder:";
            // 
            // txtSourceFolder
            // 
            this.txtSourceFolder.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.txtSourceFolder.Location = new System.Drawing.Point(173, 87);
            this.txtSourceFolder.Name = "txtSourceFolder";
            this.txtSourceFolder.ReadOnly = false;
            this.txtSourceFolder.Size = new System.Drawing.Size(504, 22);
            this.txtSourceFolder.TabIndex = 7;
            // 
            // btnSelectSourceFolder
            // 
            this.btnSelectSourceFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.btnSelectSourceFolder.Location = new System.Drawing.Point(683, 87);
            this.btnSelectSourceFolder.Name = "btnSelectSourceFolder";
            this.btnSelectSourceFolder.Size = new System.Drawing.Size(75, 22);
            this.btnSelectSourceFolder.TabIndex = 8;
            this.btnSelectSourceFolder.Text = "Select Source";
            this.btnSelectSourceFolder.Click += new System.EventHandler(this.btnSelectSourceFolder_Click);
            // 
            // lblDestinationFolder
            // 
            this.lblDestinationFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblDestinationFolder.AutoSize = true;
            this.lblDestinationFolder.Location = new System.Drawing.Point(3, 117);
            this.lblDestinationFolder.Name = "lblDestinationFolder";
            this.lblDestinationFolder.Size = new System.Drawing.Size(127, 17);
            this.lblDestinationFolder.TabIndex = 9;
            this.lblDestinationFolder.Text = "Destination Folder:";
            // 
            // txtDestinationFolder
            // 
            this.txtDestinationFolder.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.txtDestinationFolder.Location = new System.Drawing.Point(173, 115);
            this.txtDestinationFolder.Name = "txtDestinationFolder";
            this.txtDestinationFolder.ReadOnly = false;
            this.txtDestinationFolder.Size = new System.Drawing.Size(504, 22);
            this.txtDestinationFolder.TabIndex = 10;
            // 
            // btnSelectDestinationFolder
            // 
            this.btnSelectDestinationFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.btnSelectDestinationFolder.Location = new System.Drawing.Point(683, 115);
            this.btnSelectDestinationFolder.Name = "btnSelectDestinationFolder";
            this.btnSelectDestinationFolder.Size = new System.Drawing.Size(75, 22);
            this.btnSelectDestinationFolder.TabIndex = 11;
            this.btnSelectDestinationFolder.Text = "Select Destination";
            this.btnSelectDestinationFolder.Click += new System.EventHandler(this.btnSelectDestinationFolder_Click);
            // 
            // lblModel
            // 
            this.lblModel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblModel.AutoSize = true;
            this.lblModel.Location = new System.Drawing.Point(3, 145);
            this.lblModel.Name = "lblModel";
            this.lblModel.Size = new System.Drawing.Size(50, 17);
            this.lblModel.TabIndex = 12;
            this.lblModel.Text = "Model:";
            // 
            // cmbModelSelection
            // 
            this.cmbModelSelection.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.cmbModelSelection, 2);
            this.cmbModelSelection.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbModelSelection.Location = new System.Drawing.Point(173, 143);
            this.cmbModelSelection.Name = "cmbModelSelection";
            this.cmbModelSelection.Size = new System.Drawing.Size(674, 24);
            this.cmbModelSelection.TabIndex = 13;
            // 
            // chkRenameFiles
            // 
            this.chkRenameFiles.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.chkRenameFiles.AutoSize = true;
            this.tableLayoutPanel1.SetColumnSpan(this.chkRenameFiles, 3);
            this.chkRenameFiles.Location = new System.Drawing.Point(3, 171);
            this.chkRenameFiles.Name = "chkRenameFiles";
            this.chkRenameFiles.Size = new System.Drawing.Size(224, 19);
            this.chkRenameFiles.TabIndex = 14;
            this.chkRenameFiles.Text = "Bestandsnamen AI hernoemen";
            // 
            // btnStartOrganization
            // 
            this.btnStartOrganization.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnStartOrganization.Location = new System.Drawing.Point(3, 196);
            this.btnStartOrganization.Name = "btnStartOrganization";
            this.btnStartOrganization.Size = new System.Drawing.Size(164, 30);
            this.btnStartOrganization.TabIndex = 15;
            this.btnStartOrganization.Text = "Start Organisatie";
            this.btnStartOrganization.Click += new System.EventHandler(this.btnStartOrganization_Click);
            // 
            // btnStopOrganization
            // 
            this.btnStopOrganization.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnStopOrganization.Location = new System.Drawing.Point(173, 196);
            this.btnStopOrganization.Name = "btnStopOrganization";
            this.btnStopOrganization.Size = new System.Drawing.Size(504, 30);
            this.btnStopOrganization.TabIndex = 16;
            this.btnStopOrganization.Text = "Stop Organisatie";
            this.btnStopOrganization.Click += new System.EventHandler(this.btnStopOrganization_Click);
            // 
            // btnSaveLog
            // 
            this.btnSaveLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnSaveLog.Location = new System.Drawing.Point(683, 196);
            this.btnSaveLog.Name = "btnSaveLog";
            this.btnSaveLog.Size = new System.Drawing.Size(164, 30);
            this.btnSaveLog.TabIndex = 17;
            this.btnSaveLog.Text = "Log Opslaan";
            this.btnSaveLog.Click += new System.EventHandler(this.btnSaveLog_Click);
            // 
            // btnRenameSingleFile
            // 
            this.tableLayoutPanel1.SetColumnSpan(this.btnRenameSingleFile, 2);
            this.btnRenameSingleFile.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnRenameSingleFile.Location = new System.Drawing.Point(3, 232);
            this.btnRenameSingleFile.Name = "btnRenameSingleFile";
            this.btnRenameSingleFile.Size = new System.Drawing.Size(674, 30);
            this.btnRenameSingleFile.TabIndex = 18;
            this.btnRenameSingleFile.Text = "Hernoem Enkel Bestand met AI";
            this.btnRenameSingleFile.UseVisualStyleBackColor = true;
            this.btnRenameSingleFile.Click += new System.EventHandler(this.btnRenameSingleFile_Click);
            // 
            // btnGenerateStandardFolders
            // 
            this.btnGenerateStandardFolders.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnGenerateStandardFolders.Location = new System.Drawing.Point(683, 232);
            this.btnGenerateStandardFolders.Name = "btnGenerateStandardFolders";
            this.btnGenerateStandardFolders.Size = new System.Drawing.Size(164, 30);
            this.btnGenerateStandardFolders.TabIndex = 23;
            this.btnGenerateStandardFolders.Text = "Maak folders";
            this.btnGenerateStandardFolders.UseVisualStyleBackColor = true;
            this.btnGenerateStandardFolders.Click += new System.EventHandler(this.btnGenerateStandardFolders_Click);
            // 
            // progressBar1
            // 
            this.progressBar1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.progressBar1, 2);
            this.progressBar1.Location = new System.Drawing.Point(3, 268);
            this.progressBar1.Name = "progressBar1";
            this.progressBar1.Size = new System.Drawing.Size(674, 16);
            this.progressBar1.TabIndex = 19;
            this.progressBar1.Visible = false;
            // 
            // lblTokensUsed
            // 
            this.lblTokensUsed.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.lblTokensUsed.AutoSize = true;
            this.lblTokensUsed.Location = new System.Drawing.Point(721, 267);
            this.lblTokensUsed.Name = "lblTokensUsed";
            this.lblTokensUsed.Size = new System.Drawing.Size(126, 17);
            this.lblTokensUsed.TabIndex = 20;
            this.lblTokensUsed.Text = "Tokens gebruikt: 0";
            // 
            // rtbLog
            // 
            this.tableLayoutPanel1.SetColumnSpan(this.rtbLog, 3);
            this.rtbLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.rtbLog.Location = new System.Drawing.Point(3, 290);
            this.rtbLog.Name = "rtbLog";
            this.rtbLog.ReadOnly = true;
            this.rtbLog.Size = new System.Drawing.Size(844, 159);
            this.rtbLog.TabIndex = 21;
            this.rtbLog.Text = "";
            // 
            // linkLabelAuthor
            // 
            this.linkLabelAuthor.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.linkLabelAuthor.AutoSize = true;
            this.tableLayoutPanel1.SetColumnSpan(this.linkLabelAuthor, 3);
            this.linkLabelAuthor.Location = new System.Drawing.Point(677, 461);
            this.linkLabelAuthor.Name = "linkLabelAuthor";
            this.linkLabelAuthor.Size = new System.Drawing.Size(170, 17);
            this.linkLabelAuthor.TabIndex = 22;
            this.linkLabelAuthor.TabStop = true;
            this.linkLabelAuthor.Text = "Made by Remsey Mailjard";
            this.linkLabelAuthor.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.linkLabelAuthor.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabelAuthor_LinkClicked);
            // 
            // MainWindow
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(850, 480);
            this.Controls.Add(this.tableLayoutPanel1);
            this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
            this.Name = "MainWindow";
            this.Text = "AI File Organizer - Remsey Mailjard";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.tableLayoutPanel1.ResumeLayout(false);
            this.tableLayoutPanel1.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private System.Windows.Forms.Label lblProvider;
        private System.Windows.Forms.ComboBox cmbProviderSelection;
        private System.Windows.Forms.Label lblApiKey;
        private System.Windows.Forms.TextBox txtApiKey;
        private System.Windows.Forms.Label lblAzureEndpoint;
        private System.Windows.Forms.TextBox txtAzureEndpoint;
        private System.Windows.Forms.Label lblSourceFolder;
        private System.Windows.Forms.TextBox txtSourceFolder;
        private System.Windows.Forms.Button btnSelectSourceFolder;
        private System.Windows.Forms.Label lblDestinationFolder;
        private System.Windows.Forms.TextBox txtDestinationFolder;
        private System.Windows.Forms.Button btnSelectDestinationFolder;
        private System.Windows.Forms.Label lblModel;
        private System.Windows.Forms.ComboBox cmbModelSelection;
        private System.Windows.Forms.CheckBox chkRenameFiles;
        private System.Windows.Forms.Button btnStartOrganization;
        private System.Windows.Forms.Button btnStopOrganization;
        private System.Windows.Forms.Button btnSaveLog;
        private System.Windows.Forms.Button btnRenameSingleFile;
        private System.Windows.Forms.Button btnGenerateStandardFolders; // TOEGEVOEGD!
        private System.Windows.Forms.ProgressBar progressBar1;
        private System.Windows.Forms.Label lblTokensUsed;
        private System.Windows.Forms.RichTextBox rtbLog;
        private System.Windows.Forms.LinkLabel linkLabelAuthor;
    }
}



================================================
FILE: MainWindow.resx
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<root>
  <!--
    Microsoft ResX Schema 

    Version 2.0

    The primary goals of this format is to allow a simple XML format
    that is mostly human readable. The generation and parsing of the
    various data types are done through the TypeConverter classes
    associated with the data types.

    Example:

    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>

    There are any number of "resheader" rows that contain simple
    name/value pairs.

    Each data row contains a name, and value. The row also contains a
    type or mimetype. Type corresponds to a .NET class that support
    text/value conversion through the TypeConverter architecture.
    Classes that don't support this are serialized and stored with the
    mimetype set.

    The mimetype is used for serialized objects, and tells the
    ResXResourceReader how to depersist the object. This is currently not
    extensible. For a given mimetype the value must be set accordingly:

    Note - application/x-microsoft.net.object.binary.base64 is the format
    that the ResXResourceWriter will generate, however the reader can
    read any of the formats listed below.

    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <assembly alias="System.Drawing" name="System.Drawing, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a" />
  <data name="$this.Icon" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
    <value>
        AAABAAEAICAAAAEAIACoEAAAFgAAACgAAAAgAAAAQAAAAAEAIAAAAAAAABAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACkkYj/k2tY/5RqVv+Ualb/lGpW/5RqVv+Ualb/lGpW/5Rq
        Vv+Ualb/lGpW/5RqVv+Ualb/lGpW/5RqVv+Ualb/lGpW/5RqVv+Ualb/lGpW/5NrWP+jkYj/AAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAApJGI/7JOIP/hXSH/4V4h/+FeIf/hXiH/4V4h/+Fe
        If/hXiH/4V4h/+FeIf/hXiH/4V4h/+FeIf/hXiH/4V4h/+FeIf/hXiH/4V4h/+FeIf/hXiH/4V0h/7JO
        IP+kkYj/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACTa1f/4V0h/+xjJf/rYyX/62Ml/+tj
        Jf/rYyX/62Ml/+tjJf/rYyX/62Ml/+tjJf/rYyX/62Ml/+tjJf/rYyX/62Ml/+tjJf/rYyX/62Ml/+tj
        Jf/sYyX/4V0h/5NrWP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJRqVf/hXiH/62Ml/+tj
        Jf/rYyX/62Ml/+tjJf/rYyX/62Ml/+xjJf/sYyX/7GMl/+xjJf/sYyX/7GMl/+tjJf/rYyX/62Ml/+tj
        Jf/rYyX/62Ml/+tjJf/hXiH/lGpV/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlGpW/+Fe
        If/rYyX/62Ml/+tjJf/rYyX/62Ml/+xjJf/jXyP/1Fkh/9NZIf/TWSH/01kh/9NZIf/UWSH/418j/+xj
        Jf/rYyX/62Ml/+tjJf/rYyX/62Ml/+FeIf+Ualb/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AACUalb/4V4h/+tjJf/rYyX/62Ml/+tjJf/rYyX/418j/6RlR/+vmI3/spuQ/7KbkP+ym5D/spuQ/6+Y
        jf+kZUf/418j/+tjJf/rYyX/62Ml/+tjJf/rYyX/4V4h/5RqVv8AAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAJRqVv/hXiH/62Ml/+tjJf/rYyX/62Ml/+xjJf/UWSH/r5iM/wAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAK+YjP/UWSH/7GMl/+tjJf/rYyX/62Ml/+tjJf/hXiH/lGpW/wAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAlGpW/+FeIf/rYyX/62Ml/+tjJf/rYyX/7GMl/9NZIf+ym4//AAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAspuP/9NZIf/sYyX/62Ml/+tjJf/rYyX/62Ml/+FeIf+Ualb/AAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACUalb/4V4h/+tjJf/rYyX/62Ml/+tjJf/sYyX/01kh/7Kb
        j/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACym4//01kh/+xjJf/rYyX/62Ml/+tjJf/rYyX/4V4h/5Rq
        Vv8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJRqVv/hXiH/62Ml/+tjJf/rYyX/62Ml/+xj
        Jf/UWSH/r5iM/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK+YjP/UWSH/7GMl/+tjJf/rYyX/62Ml/+tj
        Jf/hXiH/lGpW/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAlGpW/+FeIf/rYyX/62Ml/+tj
        Jf/rYyX/62Ml/+NfI/+kZUf/r5iM/7Kbj/+ynJD/spyQ/7Kbj/+vmIz/pGVH/+NfI//rYyX/62Ml/+tj
        Jf/rYyX/62Ml/+FeIf+Ualb/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACUalb/4V4h/+tj
        Jf/rYyX/62Ml/+tjJf/rYyX/7GMl/+NfI//UWSH/01kh/9NZIf/TWSH/01kh/9RZIf/jXyP/7GMl/+tj
        Jf/rYyX/62Ml/+tjJf/rYyX/4V4h/5RqVv8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJRq
        Vf/hXiH/62Ml/+tjJf/rYyX/62Ml/+tjJf/rYyX/62Ml/+xjJf/sYyX/7GMl/+xjJf/sYyX/7GMl/+tj
        Jf/rYyX/62Il/+tiJf/rYyX/62Ml/+ljJf/hXiH/lGpV/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAk2tX/+FdIf/sYyX/62Ml/+tjJf/rYyX/62Ml/+tjJf/rYiX/62Il/+tjJf/sYyX/7WUm/+1m
        J//uZyj/72kp//BrK//xbi3/8nEv//N0Mf/tdDL/rVMm/9pbIf+Ua1j/AAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAACkkoj/tFEj/+RgJf/oYyX/7GUm/+xmJ//taCn/7msq/+9tLP/wcC7/8nQx/+lx
        MP/TaC3/1Gsv/9VtMP/VbzL/1nAy/9ZxM//WcTP/13I0/8ZrMv+GRCH/q0wf/6SRiP8AAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACLWj3/1mww/+p2NP/zezb/9X44//V/Of/2gTr/9oI7//eC
        O//wfzn/mF05/3hjVf97ZVf/e2VX/3tkV/97ZFf/e2RW/3tkVv97ZFb/d2JV/3xkV/+kkYj/AAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKBkPv/7hDv/+oQ8//mEPP/5hDz/+YQ7//mD
        O//5gzv/9oE6/6lhNf+xp6L/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAj2tV/7VjMf+5ZjP/uWYz/7lm
        M/+5ZjP/uWYz/7pmM/+kXTH/oZGG/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
        AAAAAAAAAAAAAAAAAAAAAAAA///////////////////////////////////////////4AAAf8AAAD/AA
        AA/wAAAP8AAAD/AAAA/wB+AP8AfgD/AH4A/wB+AP8AAAD/AAAA/wAAAP8AAAD/AAAA/4AAAf+AD///gB
        //////////////////////////////////8=
</value>
  </data>
</root>


================================================
FILE: packages.config
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Azure.AI.OpenAI" version="2.1.0" targetFramework="net48" />
  <package id="Azure.Core" version="1.44.1" targetFramework="net48" />
  <package id="CredentialManagement" version="1.0.2" targetFramework="net48" />
  <package id="DocumentFormat.OpenXml" version="3.3.0" targetFramework="net48" />
  <package id="DocumentFormat.OpenXml.Framework" version="3.3.0" targetFramework="net48" />
  <package id="Google_GenerativeAI" version="2.5.10" targetFramework="net48" />
  <package id="Microsoft.Bcl.AsyncInterfaces" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Bcl.HashCode" version="6.0.0" targetFramework="net48" />
  <package id="Microsoft.Extensions.DependencyInjection" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.DependencyInjection.Abstractions" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Logging" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Logging.Abstractions" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Options" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Primitives" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft-WindowsAPICodePack-Core" version="1.1.5" targetFramework="net48" />
  <package id="Microsoft-WindowsAPICodePack-Shell" version="1.1.5" targetFramework="net48" />
  <package id="Newtonsoft.Json" version="13.0.3" targetFramework="net48" />
  <package id="OpenAI" version="2.1.0" targetFramework="net48" />
  <package id="PdfPig" version="0.1.10" targetFramework="net48" />
  <package id="System.Buffers" version="4.6.0" targetFramework="net48" />
  <package id="System.ClientModel" version="1.2.1" targetFramework="net48" />
  <package id="System.ComponentModel.Annotations" version="5.0.0" targetFramework="net48" />
  <package id="System.Diagnostics.DiagnosticSource" version="9.0.3" targetFramework="net48" />
  <package id="System.IO" version="4.3.0" targetFramework="net48" />
  <package id="System.IO.Pipelines" version="9.0.3" targetFramework="net48" />
  <package id="System.Memory" version="4.6.0" targetFramework="net48" />
  <package id="System.Memory.Data" version="6.0.0" targetFramework="net48" />
  <package id="System.Net.Http" version="4.3.4" targetFramework="net48" />
  <package id="System.Numerics.Vectors" version="4.6.0" targetFramework="net48" />
  <package id="System.Runtime" version="4.3.0" targetFramework="net48" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.1.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Algorithms" version="4.3.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Encoding" version="4.3.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Primitives" version="4.3.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.X509Certificates" version="4.3.0" targetFramework="net48" />
  <package id="System.Text.Encodings.Web" version="9.0.3" targetFramework="net48" />
  <package id="System.Text.Json" version="9.0.3" targetFramework="net48" />
  <package id="System.Threading.Tasks.Extensions" version="4.5.4" targetFramework="net48" />
  <package id="System.ValueTuple" version="4.5.0" targetFramework="net48" />
  <package id="Xceed.Document.NET" version="5.0.25228.6154" targetFramework="net48" />
  <package id="Xceed.Drawing.NET" version="1.0.25228.6154" targetFramework="net48" />
  <package id="Xceed.Pdf" version="5.0.25228.6154" targetFramework="net48" />
  <package id="Xceed.Words.NET" version="5.0.25228.6154" targetFramework="net48" />
</packages>


================================================
FILE: Program.cs
================================================
Ôªøusing System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AI_FileOrganizer
{
    internal static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainWindow());
        }
    }
}



================================================
FILE: ILLink/ILLink.Descriptors.LibraryBuild.xml
================================================
Ôªø<linker>
  <assembly fullname="System.Diagnostics.DiagnosticSource">
    <type fullname="System.Diagnostics.Metrics.MetricsEventSource">
      <!-- Used by System.Private.CoreLib via reflection to init the EventSource -->
      <method name="GetInstance" />
    </type>
  </assembly>
</linker>



================================================
FILE: Installer/AI-applicatie.txt
================================================
Directory structure:
‚îî‚îÄ‚îÄ remseymailjard-ai-fileorganizer2/
    ‚îú‚îÄ‚îÄ README.md
    ‚îú‚îÄ‚îÄ AI-FileOrganizer2.csproj
    ‚îú‚îÄ‚îÄ AI-FileOrganizer2.sln
    ‚îú‚îÄ‚îÄ AIFileOrganizerLinkedIn.zip
    ‚îú‚îÄ‚îÄ App.config
    ‚îú‚îÄ‚îÄ appsettings.json
    ‚îú‚îÄ‚îÄ Form1.cs
    ‚îú‚îÄ‚îÄ Form1.Designer.cs
    ‚îú‚îÄ‚îÄ Form1.resx
    ‚îú‚îÄ‚îÄ FormRenameFile.cs
    ‚îú‚îÄ‚îÄ FormRenameFile.Designer.cs
    ‚îú‚îÄ‚îÄ FormRenameFile.resx
    ‚îú‚îÄ‚îÄ packages.config
    ‚îú‚îÄ‚îÄ Program.cs
    ‚îú‚îÄ‚îÄ README_AI_File_Organizer.md
    ‚îú‚îÄ‚îÄ Models/
    ‚îÇ   ‚îî‚îÄ‚îÄ ApplicationSettings.cs
    ‚îú‚îÄ‚îÄ Properties/
    ‚îÇ   ‚îú‚îÄ‚îÄ AssemblyInfo.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ Resources.Designer.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ Resources.resx
    ‚îÇ   ‚îú‚îÄ‚îÄ Settings.Designer.cs
    ‚îÇ   ‚îî‚îÄ‚îÄ Settings.settings
    ‚îú‚îÄ‚îÄ Services/
    ‚îÇ   ‚îú‚îÄ‚îÄ AiClassificationService.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ AzureOpenAiProvider.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ CredentialStorageService.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ DocxTextExtractor.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ FileOrganizerService.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ GeminiAiProvider.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ IaProvider.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ ITextExtractor.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ OpenAiProvider.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ PdfTextExtractor.cs
    ‚îÇ   ‚îú‚îÄ‚îÄ PlainTextExtractor.cs
    ‚îÇ   ‚îî‚îÄ‚îÄ TextExtractionService.cs
    ‚îî‚îÄ‚îÄ Utils/
        ‚îú‚îÄ‚îÄ FileLogger.cs
        ‚îú‚îÄ‚îÄ FileUtil.cs
        ‚îú‚îÄ‚îÄ ILogger.cs
        ‚îî‚îÄ‚îÄ UiLogger.cs


Files Content:

================================================
FILE: README.md
================================================
Ôªø# AI File Organizer

![AI File Organizer Screenshot (voorbeeld - plaats hier een screenshot van je applicatie)](https://via.placeholder.com/800x450?text=Plaats+hier+een+screenshot+van+de+UI)

Dit project is een Windows Forms-applicatie (.NET Framework 4.8) die is ontworpen om uw digitale documenten automatisch te organiseren met behulp van kunstmatige intelligentie. Het analyseert de inhoud van uw bestanden (PDF, DOCX, TXT, MD) en verplaatst ze naar vooraf gedefinieerde, logische categoriefolders, inclusief de mogelijkheid om AI-gegenereerde submappen en bestandsnamen voor te stellen.

## Inhoudsopgave

*   [Functies](#functies)
*   [Vereisten](#vereisten)
*   [Installatie](#installatie)
*   [API-sleutel instellen](#api-sleutel-instellen)
    *   [Google Gemini API-sleutel](#google-gemini-api-sleutel)
    *   [OpenAI API-sleutel](#openai-api-sleutel)
    *   [Azure OpenAI API-sleutel](#azure-openai-api-sleutel)
*   [Gebruik](#gebruik)
    *   [Stap 1: Applicatie starten](#stap-1-applicatie-starten)
    *   [Stap 2: API-provider en -model selecteren](#stap-2-api-provider-en--model-selecteren)
    *   [Stap 3: Mappen configureren](#stap-3-mappen-configureren)
    *   [Stap 4: Bestanden hernoemen (optioneel)](#stap-4-bestanden-hernoemen-optioneel)
    *   [Stap 5: Organisatie starten](#stap-5-organisatie-starten)
    *   [Stap 6: Voortgang en logboek](#stap-6-voortgang-en-logboek)
*   [Ondersteunde bestandstypen](#ondersteunde-bestandstypen)
*   [Voorgedefinieerde mapcategorie√´n](#voorgedefinieerde-mapcategorie√´n)
*   [Projectstructuur](#projectstructuur)
*   [Credits](#credits)

## Functies

*   **AI-gestuurde classificatie**: Automatische categorisatie van documenten in vooraf gedefinieerde mappen.
*   **Intelligente submap-suggesties**: De AI stelt beschrijvende submapnamen voor op basis van de inhoud.
*   **AI-gegenereerde bestandsnamen**: Mogelijkheid om bestandsnamen te hernoemen met AI-suggesties (met gebruikersbevestiging).
*   **Ondersteuning voor meerdere AI-providers**: Kies tussen Google Gemini, OpenAI (via openai.com) en Azure OpenAI.
*   **Robuuste tekstextractie**: Extraheert tekst uit PDF-, DOCX-, TXT- en MD-bestanden, inclusief verbeterde lay-outanalyse voor PDF's.
*   **Moderne UI-dialoogvensters**: Gebruikt moderne Windows-dialoogvensters voor map- en bestandsselectie/opslaan.
*   **Uitgebreide logging**: Gedetailleerde logboeken van het organisatieproces, direct zichtbaar in de UI en opslaanbaar naar een bestand.
*   **Annulering van processen**: Mogelijkheid om een lopend organisatieproces te stoppen.

## Vereisten

*   **Besturingssysteem**: Windows 10 of nieuwer.
*   **.NET Framework**: .NET Framework 4.8 Runtime ge√Ønstalleerd.
*   **Internetverbinding**: Vereist voor communicatie met de AI-API's.
*   **API-sleutel**: Een geldige API-sleutel voor de gekozen AI-provider (Google Gemini, OpenAI of Azure OpenAI). Zie [API-sleutel instellen](#api-sleutel-instellen) voor instructies.

## Installatie

Dit project is een Visual Studio-oplossing. Volg deze stappen om het te installeren en te draaien:

1.  **Kloon de repository**:
    ```bash
    git clone https://github.com/remseymailjard/remseymailjard-ai-fileorganizer2.git
    cd remseymailjard-ai-fileorganizer2
    ```
2.  **Open in Visual Studio**: Open het `AI-FileOrganizer2.sln` bestand in Visual Studio (Visual Studio 2019 of nieuwer wordt aanbevolen voor .NET Framework 4.8 projecten).
3.  **Herstel NuGet-pakketten**: Visual Studio zou automatisch de benodigde NuGet-pakketten moeten herstellen bij het openen van de oplossing. Als dit niet gebeurt, klik dan met de rechtermuisknop op de oplossing in Solution Explorer en kies "Restore NuGet Packages".
    *   **Belangrijke NuGet-pakketten**: Dit project maakt gebruik van:
        *   `PdfPig` (voor PDF-extractie)
        *   `DocumentFormat.OpenXml` (voor DOCX-extractie)
        *   `Microsoft.WindowsAPICodePack.Shell` en `Microsoft.WindowsAPICodePack.Core` (voor moderne dialoogvensters)
        *   `Google.GenerativeAI` (voor Gemini API)
        *   `OpenAI` (voor OpenAI API)
        *   `Azure.AI.OpenAI` (voor Azure OpenAI API)
        *   `Newtonsoft.Json` (voor JSON-serialisatie/deserialisatie)
4.  **Bouw de oplossing**: Klik in Visual Studio op "Build" > "Build Solution" (of druk op `F6`).
5.  **Start de applicatie**: Nadat de build is voltooid, kunt u de applicatie starten door op `F5` te drukken of door te navigeren naar de `bin\Debug` (of `bin\Release`) map in uw projectdirectory en `AI-FileOrganizer2.exe` uit te voeren.

## API-sleutel instellen

U hebt een API-sleutel nodig van de door u gekozen AI-provider om de applicatie te kunnen gebruiken. De applicatie ondersteunt Google Gemini, OpenAI en Azure OpenAI.

**Beveiligingstip**: Bewaar uw API-sleutels altijd veilig en deel ze nooit met anderen.

### Google Gemini API-sleutel

1.  **Ga naar Google AI Studio**: Open uw webbrowser en ga naar [https://aistudio.google.com/](https://aistudio.google.com/).
2.  **Log in**: Log in met uw Google-account.
3.  **Navigeer naar API-sleutels**: Klik in het linkernavigatiemenu op "Get API key" (of "API keys" als u er al een heeft).
4.  **Maak een nieuwe API-sleutel aan**: Klik op "Create API key in new project" of "Create API key".
5.  **Kopieer de sleutel**: Kopieer de gegenereerde API-sleutel en plak deze in het `Google API Key:` veld in de applicatie.

### OpenAI API-sleutel

1.  **Ga naar het OpenAI-platform**: Open uw webbrowser en ga naar [https://platform.openai.com/](https://platform.openai.com/).
2.  **Log in**: Log in met uw OpenAI-account.
3.  **Navigeer naar API-sleutels**: Klik op uw profielpictogram (rechtsboven) en selecteer "View API keys".
4.  **Maak een nieuwe sleutel aan**: Klik op "Create new secret key". Geef de sleutel eventueel een naam voor herkenbaarheid.
5.  **Kopieer de sleutel**: Kopieer de **geheime** sleutel die wordt weergegeven. Deze wordt slechts √©√©n keer getoond. Plak deze in het `OpenAI API Key:` veld in de applicatie.

### Azure OpenAI API-sleutel

Azure OpenAI vereist een Azure-abonnement en de implementatie van een OpenAI-model in uw Azure-resource.

1.  **Meld u aan bij Azure Portal**: Ga naar [https://portal.azure.com/](https://portal.azure.com/) en log in.
2.  **Maak een Azure OpenAI Service-resource aan**:
    *   Zoek in de zoekbalk naar "Azure OpenAI".
    *   Klik op "Create Azure OpenAI".
    *   Volg de stappen om een nieuwe resource te maken (kies een abonnement, resourcegroep, regio en naam).
    *   Zorg ervoor dat u aanvraagt voor toegang tot de Azure OpenAI service, aangezien deze beperkt is.
3.  **Implementeer een model**:
    *   Navigeer naar uw zojuist gemaakte Azure OpenAI resource.
    *   Klik in het linkernavigatiemenu onder "Resource Management" op "Model deployments".
    *   Klik op "Manage deployments" om naar Azure OpenAI Studio te gaan.
    *   Klik in Azure OpenAI Studio op "Deployments" > "Create new deployment".
    *   Kies een model (bijv. `gpt-4o`, `gpt-35-turbo`) en geef het een "Deployment name" (bijv. `my-gpt4o-deployment`). Dit is de naam die u in de applicatie als "Model" selecteert.
4.  **Verzamel de API-sleutel en Endpoint**:
    *   Ga terug naar uw Azure OpenAI resource in Azure Portal.
    *   Klik in het linkernavigatiemenu onder "Resource Management" op "Keys and Endpoint".
    *   U ziet hier twee sleutels (KEY 1, KEY 2) en een Endpoint.
    *   **Kopieer √©√©n van de sleutels** (bijv. KEY 1) en plak deze in het `Azure OpenAI API Key:` veld in de applicatie.
    *   **Kopieer de Endpoint URL** en plak deze in het `Azure Endpoint:` veld in de applicatie.
    *   **Onthoud de "Deployment name"** die u heeft gekozen in stap 3. Dit is de waarde die u in het `Model:` dropdown-menu in de applicatie kiest wanneer u "Azure OpenAI" als provider selecteert.

## Gebruik

### Stap 1: Applicatie starten

Start `AI-FileOrganizer2.exe` vanuit de `bin\Debug` of `bin\Release` map.

### Stap 2: API-provider en -model selecteren

1.  **Provider selecteren**: Kies uw AI-provider uit het `Provider:` dropdown-menu (Gemini (Google), OpenAI (openai.com), of Azure OpenAI).
2.  **API Key en Endpoint (indien van toepassing)**: Vul uw API-sleutel in het `API Key:` veld. Als u Azure OpenAI hebt geselecteerd, vul dan ook de `Azure Endpoint:` URL in.
3.  **Model selecteren**: Kies het specifieke AI-model dat u wilt gebruiken uit het `Model:` dropdown-menu.

### Stap 3: Mappen configureren

1.  **Bronmap (`Source Folder`)**: Klik op "Select Source" om de map te kiezen die de bestanden bevat die u wilt organiseren. De applicatie scant alle submappen in deze bronmap.
2.  **Doelmap (`Destination Folder`)**: Klik op "Select Destination" om de map te kiezen waar de georganiseerde bestanden naartoe moeten worden verplaatst. De applicatie cre√´ert hierin de categoriefolders en, indien gewenst, submappen.

### Stap 4: Bestanden hernoemen (optioneel)

*   Schakel het selectievakje `Bestandsnamen AI hernoemen` in als u wilt dat de AI suggesties doet voor nieuwe, meer beschrijvende bestandsnamen. Wanneer dit is ingeschakeld, krijgt u voor elk bestand een pop-up waarin u de AI-suggestie kunt accepteren, bewerken of overslaan.

### Stap 5: Organisatie starten

*   Klik op de knop **"Start"** om het organisatieproces te starten.

### Stap 6: Voortgang en logboek

*   **Voortgangsbalk**: Monitor de voortgang onderaan het venster.
*   **Logboek (`rtbLog`)**: Gedetailleerde informatie over elke stap van het proces (extractie, classificatie, verplaatsing, hernoeming) wordt in realtime weergegeven.
*   **"Stop" knop**: U kunt het proces op elk moment onderbreken door op de "Stop" knop te klikken.
*   **"Log Opslaan" knop**: Na voltooiing (of annulering) van het proces, kunt u het volledige logboek opslaan naar een tekstbestand via de "Log Opslaan" knop.

## Ondersteunde bestandstypen

De AI File Organizer kan tekst extraheren uit de volgende bestandstypen:

*   `.pdf` (Portable Document Format)
*   `.docx` (Microsoft Word Document)
*   `.txt` (Plain Text File)
*   `.md` (Markdown File)

## Voorgedefinieerde mapcategorie√´n

De applicatie probeert bestanden in een van de volgende hoofdcategorie√´n te plaatsen. Als geen duidelijke match wordt gevonden, wordt het bestand in de 'Overig' map geplaatst.

*   1. Financi√´n
*   2. Belastingen
*   3. Verzekeringen
*   4. Woning
*   5. Gezondheid en Medisch
*   6. Familie en Kinderen
*   7. Voertuigen
*   8. Persoonlijke Documenten
*   9. Hobbies en interesses
*   10. Carri√®re en Professionele Ontwikkeling
*   11. Bedrijfsadministratie
*   12. Reizen en vakanties
*   0. Overig (Fallback-categorie)

## Projectstructuur


================================================
FILE: AI-FileOrganizer2.csproj
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Import Project="$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props" Condition="Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')" />
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{A58EBE3F-C926-432E-B874-AD6F29494AC7}</ProjectGuid>
    <OutputType>WinExe</OutputType>
    <RootNamespace>AI_FileOrganizer</RootNamespace>
    <AssemblyName>AI-FileOrganizer2</AssemblyName>
    <TargetFrameworkVersion>v4.8</TargetFrameworkVersion>
    <FileAlignment>512</FileAlignment>
    <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
    <Deterministic>true</Deterministic>
    <IsWebBootstrapper>false</IsWebBootstrapper>
    <PublishUrl>C:\Users\Remse\Desktop\AIFileOrganizerLinkedIn\</PublishUrl>
    <Install>true</Install>
    <InstallFrom>Disk</InstallFrom>
    <UpdateEnabled>false</UpdateEnabled>
    <UpdateMode>Foreground</UpdateMode>
    <UpdateInterval>7</UpdateInterval>
    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
    <UpdatePeriodically>false</UpdatePeriodically>
    <UpdateRequired>false</UpdateRequired>
    <MapFileExtensions>true</MapFileExtensions>
    <ApplicationRevision>2</ApplicationRevision>
    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
    <UseApplicationTrust>false</UseApplicationTrust>
    <PublishWizardCompleted>true</PublishWizardCompleted>
    <BootstrapperEnabled>true</BootstrapperEnabled>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <PlatformTarget>AnyCPU</PlatformTarget>
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup>
    <ManifestCertificateThumbprint>6F5EC5C02B4F1B3306729060BCE598E3CEF7AC6E</ManifestCertificateThumbprint>
  </PropertyGroup>
  <PropertyGroup>
    <ManifestKeyFile>AI-FileOrganizer2_TemporaryKey.pfx</ManifestKeyFile>
  </PropertyGroup>
  <PropertyGroup>
    <GenerateManifests>true</GenerateManifests>
  </PropertyGroup>
  <PropertyGroup>
    <SignManifests>false</SignManifests>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="Azure.AI.OpenAI, Version=2.1.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8, processorArchitecture=MSIL">
      <HintPath>packages\Azure.AI.OpenAI.2.1.0\lib\netstandard2.0\Azure.AI.OpenAI.dll</HintPath>
    </Reference>
    <Reference Include="Azure.Core, Version=1.44.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8, processorArchitecture=MSIL">
      <HintPath>packages\Azure.Core.1.44.1\lib\net472\Azure.Core.dll</HintPath>
    </Reference>
    <Reference Include="CredentialManagement, Version=1.0.2.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>packages\CredentialManagement.1.0.2\lib\net35\CredentialManagement.dll</HintPath>
    </Reference>
    <Reference Include="CustomMarshalers" />
    <Reference Include="DocumentFormat.OpenXml, Version=3.3.0.0, Culture=neutral, PublicKeyToken=8fb06cb64d019a17, processorArchitecture=MSIL">
      <HintPath>packages\DocumentFormat.OpenXml.3.3.0\lib\net46\DocumentFormat.OpenXml.dll</HintPath>
    </Reference>
    <Reference Include="DocumentFormat.OpenXml.Framework, Version=3.3.0.0, Culture=neutral, PublicKeyToken=8fb06cb64d019a17, processorArchitecture=MSIL">
      <HintPath>packages\DocumentFormat.OpenXml.Framework.3.3.0\lib\net46\DocumentFormat.OpenXml.Framework.dll</HintPath>
    </Reference>
    <Reference Include="GenerativeAI, Version=2.5.10.0, Culture=neutral, PublicKeyToken=125a6b2231c8ea71, processorArchitecture=MSIL">
      <HintPath>packages\Google_GenerativeAI.2.5.10\lib\net462\GenerativeAI.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Bcl.AsyncInterfaces, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Bcl.AsyncInterfaces.9.0.3\lib\net462\Microsoft.Bcl.AsyncInterfaces.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Bcl.HashCode, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Bcl.HashCode.6.0.0\lib\net462\Microsoft.Bcl.HashCode.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.DependencyInjection, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.DependencyInjection.9.0.3\lib\net462\Microsoft.Extensions.DependencyInjection.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.DependencyInjection.Abstractions, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.DependencyInjection.Abstractions.9.0.3\lib\net462\Microsoft.Extensions.DependencyInjection.Abstractions.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Logging, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Logging.9.0.3\lib\net462\Microsoft.Extensions.Logging.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Logging.Abstractions, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Logging.Abstractions.9.0.3\lib\net462\Microsoft.Extensions.Logging.Abstractions.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Options, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Options.9.0.3\lib\net462\Microsoft.Extensions.Options.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.Extensions.Primitives, Version=9.0.0.3, Culture=neutral, PublicKeyToken=adb9793829ddae60, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft.Extensions.Primitives.9.0.3\lib\net462\Microsoft.Extensions.Primitives.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.WindowsAPICodePack, Version=1.1.5.0, Culture=neutral, PublicKeyToken=8985beaab7ea3f04, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft-WindowsAPICodePack-Core.1.1.5\lib\net48\Microsoft.WindowsAPICodePack.dll</HintPath>
    </Reference>
    <Reference Include="Microsoft.WindowsAPICodePack.Shell, Version=1.1.5.0, Culture=neutral, PublicKeyToken=8985beaab7ea3f04, processorArchitecture=MSIL">
      <HintPath>packages\Microsoft-WindowsAPICodePack-Shell.1.1.5\lib\net48\Microsoft.WindowsAPICodePack.Shell.dll</HintPath>
    </Reference>
    <Reference Include="Newtonsoft.Json, Version=13.0.0.0, Culture=neutral, PublicKeyToken=30ad4fe6b2a6aeed, processorArchitecture=MSIL">
      <HintPath>packages\Newtonsoft.Json.13.0.3\lib\net45\Newtonsoft.Json.dll</HintPath>
    </Reference>
    <Reference Include="OpenAI, Version=2.1.0.0, Culture=neutral, PublicKeyToken=b4187f3e65366280, processorArchitecture=MSIL">
      <HintPath>packages\OpenAI.2.1.0\lib\netstandard2.0\OpenAI.dll</HintPath>
    </Reference>
    <Reference Include="PresentationCore" />
    <Reference Include="PresentationFramework" />
    <Reference Include="System" />
    <Reference Include="System.Buffers, Version=4.0.4.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Buffers.4.6.0\lib\net462\System.Buffers.dll</HintPath>
    </Reference>
    <Reference Include="System.ClientModel, Version=1.2.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8, processorArchitecture=MSIL">
      <HintPath>packages\System.ClientModel.1.2.1\lib\netstandard2.0\System.ClientModel.dll</HintPath>
    </Reference>
    <Reference Include="System.ComponentModel.Annotations, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.ComponentModel.Annotations.5.0.0\lib\net461\System.ComponentModel.Annotations.dll</HintPath>
    </Reference>
    <Reference Include="System.ComponentModel.Composition" />
    <Reference Include="System.ComponentModel.DataAnnotations" />
    <Reference Include="System.Core" />
    <Reference Include="System.Diagnostics.DiagnosticSource, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Diagnostics.DiagnosticSource.9.0.3\lib\net462\System.Diagnostics.DiagnosticSource.dll</HintPath>
    </Reference>
    <Reference Include="System.IO, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.4.3.0\lib\net462\System.IO.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.IO.Pipelines, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.IO.Pipelines.9.0.3\lib\net462\System.IO.Pipelines.dll</HintPath>
    </Reference>
    <Reference Include="System.Memory, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Memory.4.6.0\lib\net462\System.Memory.dll</HintPath>
    </Reference>
    <Reference Include="System.Memory.Data, Version=6.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Memory.Data.6.0.0\lib\net461\System.Memory.Data.dll</HintPath>
    </Reference>
    <Reference Include="System.Net" />
    <Reference Include="System.Net.Http, Version=4.1.1.3, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Net.Http.4.3.4\lib\net46\System.Net.Http.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Numerics" />
    <Reference Include="System.Numerics.Vectors, Version=4.1.5.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Numerics.Vectors.4.6.0\lib\net462\System.Numerics.Vectors.dll</HintPath>
    </Reference>
    <Reference Include="System.Runtime, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.4.3.0\lib\net462\System.Runtime.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Runtime.CompilerServices.Unsafe, Version=6.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Runtime.CompilerServices.Unsafe.6.1.0\lib\net462\System.Runtime.CompilerServices.Unsafe.dll</HintPath>
    </Reference>
    <Reference Include="System.Security.Cryptography.Algorithms, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Algorithms.4.3.0\lib\net463\System.Security.Cryptography.Algorithms.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Encoding, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Encoding.4.3.0\lib\net46\System.Security.Cryptography.Encoding.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.Primitives, Version=4.0.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.Primitives.4.3.0\lib\net46\System.Security.Cryptography.Primitives.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Security.Cryptography.X509Certificates, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=MSIL">
      <HintPath>packages\System.Security.Cryptography.X509Certificates.4.3.0\lib\net461\System.Security.Cryptography.X509Certificates.dll</HintPath>
      <Private>True</Private>
      <Private>True</Private>
    </Reference>
    <Reference Include="System.Text.Encodings.Web, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Text.Encodings.Web.9.0.3\lib\net462\System.Text.Encodings.Web.dll</HintPath>
    </Reference>
    <Reference Include="System.Text.Json, Version=9.0.0.3, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Text.Json.9.0.3\lib\net462\System.Text.Json.dll</HintPath>
    </Reference>
    <Reference Include="System.Threading.Tasks.Extensions, Version=4.2.0.1, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.Threading.Tasks.Extensions.4.5.4\lib\net461\System.Threading.Tasks.Extensions.dll</HintPath>
    </Reference>
    <Reference Include="System.ValueTuple, Version=4.0.3.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51, processorArchitecture=MSIL">
      <HintPath>packages\System.ValueTuple.4.5.0\lib\net47\System.ValueTuple.dll</HintPath>
    </Reference>
    <Reference Include="System.Web" />
    <Reference Include="System.Xaml" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Deployment" />
    <Reference Include="System.Drawing" />
    <Reference Include="System.Windows.Forms" />
    <Reference Include="System.Xml" />
    <Reference Include="UglyToad.PdfPig, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Core, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Core.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.DocumentLayoutAnalysis, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.DocumentLayoutAnalysis.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Fonts, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Fonts.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Package, Version=0.1.10.0, Culture=neutral, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Package.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Tokenization, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Tokenization.dll</HintPath>
    </Reference>
    <Reference Include="UglyToad.PdfPig.Tokens, Version=0.1.10.0, Culture=neutral, PublicKeyToken=605d367334e74123, processorArchitecture=MSIL">
      <HintPath>packages\PdfPig.0.1.10\lib\net471\UglyToad.PdfPig.Tokens.dll</HintPath>
    </Reference>
    <Reference Include="WindowsBase" />
    <Reference Include="WindowsFormsIntegration" />
    <Reference Include="Xceed.Document.NET, Version=5.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Document.NET.5.0.25228.6154\lib\net40\Xceed.Document.NET.dll</HintPath>
    </Reference>
    <Reference Include="Xceed.Drawing.NET, Version=1.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Drawing.NET.1.0.25228.6154\lib\net40\Xceed.Drawing.NET.dll</HintPath>
    </Reference>
    <Reference Include="Xceed.Pdf, Version=5.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Pdf.5.0.25228.6154\lib\net40\Xceed.Pdf.dll</HintPath>
    </Reference>
    <Reference Include="Xceed.Words.NET, Version=5.0.25228.6154, Culture=neutral, PublicKeyToken=ba83ff368b7563c6, processorArchitecture=MSIL">
      <HintPath>packages\Xceed.Words.NET.5.0.25228.6154\lib\net40\Xceed.Words.NET.dll</HintPath>
    </Reference>
  </ItemGroup>
  <ItemGroup>
    <Compile Include="Form1.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="Form1.Designer.cs">
      <DependentUpon>Form1.cs</DependentUpon>
    </Compile>
    <Compile Include="FormRenameFile.cs">
      <SubType>Form</SubType>
    </Compile>
    <Compile Include="FormRenameFile.Designer.cs">
      <DependentUpon>FormRenameFile.cs</DependentUpon>
    </Compile>
    <Compile Include="Models\ApplicationSettings.cs" />
    <Compile Include="Program.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
    <Compile Include="Services\AiClassificationService.cs" />
    <Compile Include="Services\AzureOpenAiProvider.cs" />
    <Compile Include="Services\CredentialStorageService.cs" />
    <Compile Include="Services\DocxTextExtractor.cs" />
    <Compile Include="Services\FileOrganizerService.cs" />
    <Compile Include="Services\GeminiAiProvider.cs" />
    <Compile Include="Services\IaProvider.cs" />
    <Compile Include="Services\ITextExtractor.cs" />
    <Compile Include="Services\OpenAiProvider.cs" />
    <Compile Include="Services\PdfTextExtractor.cs" />
    <Compile Include="Services\PlainTextExtractor.cs" />
    <Compile Include="Services\TextExtractionService.cs" />
    <Compile Include="Utils\FileLogger.cs" />
    <Compile Include="Utils\FileUtil.cs" />
    <Compile Include="Utils\ILogger.cs" />
    <Compile Include="Utils\UiLogger.cs" />
    <EmbeddedResource Include="Form1.resx">
      <DependentUpon>Form1.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="FormRenameFile.resx">
      <DependentUpon>FormRenameFile.cs</DependentUpon>
    </EmbeddedResource>
    <EmbeddedResource Include="Properties\Resources.resx">
      <Generator>ResXFileCodeGenerator</Generator>
      <LastGenOutput>Resources.Designer.cs</LastGenOutput>
      <SubType>Designer</SubType>
    </EmbeddedResource>
    <Compile Include="Properties\Resources.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Resources.resx</DependentUpon>
    </Compile>
    <None Include="appsettings.json" />
    <None Include="packages.config" />
    <None Include="Properties\Settings.settings">
      <Generator>SettingsSingleFileGenerator</Generator>
      <LastGenOutput>Settings.Designer.cs</LastGenOutput>
    </None>
    <Compile Include="Properties\Settings.Designer.cs">
      <AutoGen>True</AutoGen>
      <DependentUpon>Settings.settings</DependentUpon>
      <DesignTimeSharedInput>True</DesignTimeSharedInput>
    </Compile>
    <None Include="README.md" />
  </ItemGroup>
  <ItemGroup>
    <None Include="App.config" />
  </ItemGroup>
  <ItemGroup>
    <BootstrapperPackage Include=".NETFramework,Version=v4.8">
      <Visible>False</Visible>
      <ProductName>Microsoft .NET Framework 4.8 %28x86 and x64%29</ProductName>
      <Install>true</Install>
    </BootstrapperPackage>
    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
      <Visible>False</Visible>
      <ProductName>.NET Framework 3.5 SP1</ProductName>
      <Install>false</Install>
    </BootstrapperPackage>
  </ItemGroup>
  <ItemGroup />
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>


================================================
FILE: AI-FileOrganizer2.sln
================================================
Ôªø
Microsoft Visual Studio Solution File, Format Version 12.00
# Visual Studio Version 17
VisualStudioVersion = 17.9.34723.18
MinimumVisualStudioVersion = 10.0.40219.1
Project("{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}") = "AI-FileOrganizer2", "AI-FileOrganizer2.csproj", "{A58EBE3F-C926-432E-B874-AD6F29494AC7}"
EndProject
Global
	GlobalSection(SolutionConfigurationPlatforms) = preSolution
		Debug|Any CPU = Debug|Any CPU
		Release|Any CPU = Release|Any CPU
	EndGlobalSection
	GlobalSection(ProjectConfigurationPlatforms) = postSolution
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Debug|Any CPU.Build.0 = Debug|Any CPU
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Release|Any CPU.ActiveCfg = Release|Any CPU
		{A58EBE3F-C926-432E-B874-AD6F29494AC7}.Release|Any CPU.Build.0 = Release|Any CPU
	EndGlobalSection
	GlobalSection(SolutionProperties) = preSolution
		HideSolutionNode = FALSE
	EndGlobalSection
	GlobalSection(ExtensibilityGlobals) = postSolution
		SolutionGuid = {94165174-0940-4E0D-9C1C-FAE76A986586}
	EndGlobalSection
EndGlobal



================================================
FILE: AIFileOrganizerLinkedIn.zip
================================================
[Non-text file]


================================================
FILE: App.config
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
    </startup>
  <runtime>
    <assemblyBinding xmlns="urn:schemas-microsoft-com:asm.v1">
      <dependentAssembly>
        <assemblyIdentity name="System.Runtime.CompilerServices.Unsafe" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-6.0.1.0" newVersion="6.0.1.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Memory" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.2.0" newVersion="4.0.2.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Buffers" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.0.4.0" newVersion="4.0.4.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Numerics.Vectors" publicKeyToken="b03f5f7f11d50a3a" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-4.1.5.0" newVersion="4.1.5.0" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Text.Json" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.3" newVersion="9.0.0.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="Microsoft.Bcl.AsyncInterfaces" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.3" newVersion="9.0.0.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.Diagnostics.DiagnosticSource" publicKeyToken="cc7b13ffcd2ddd51" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-9.0.0.3" newVersion="9.0.0.3" />
      </dependentAssembly>
      <dependentAssembly>
        <assemblyIdentity name="System.ClientModel" publicKeyToken="92742159e12e44c8" culture="neutral" />
        <bindingRedirect oldVersion="0.0.0.0-1.2.1.0" newVersion="1.2.1.0" />
      </dependentAssembly>
    </assemblyBinding>
  </runtime>
</configuration>


================================================
FILE: appsettings.json
================================================
Ôªøusing System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace AI_FileOrganizer
{
  class appsettings
  {
    "OpenAIKey": "sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"

  }
}



================================================
FILE: Form1.cs
================================================
Ôªøusing System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http; 
using System.Diagnostics;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;
using Microsoft.WindowsAPICodePack.Dialogs; 

using AI_FileOrganizer.Services;
using AI_FileOrganizer.Utils;
using AI_FileOrganizer.Models; 
using ILogger = AI_FileOrganizer.Utils.ILogger;

namespace AI_FileOrganizer
{
    public partial class Form1 : Form
    {
        private readonly ILogger _logger; // Logt naar UI
        private static readonly HttpClient _httpClient = new HttpClient(); // Hergebruik voor API-calls
        private long _totalTokensUsed = 0; // Voor tonen in UI
        private CancellationTokenSource _cancellationTokenSource;

        // Services voor hoofdlogica
        private readonly FileOrganizerService _fileOrganizerService;
        private readonly AiClassificationService _aiService;
        private readonly TextExtractionService _textExtractionService;
        private readonly CredentialStorageService _credentialStorageService;

        public Form1()
        {
            InitializeComponent();

            // Init logging en onderliggende services
            _logger = new UiLogger(rtbLog);
            _aiService = new AiClassificationService(_logger);
            _credentialStorageService = new CredentialStorageService(_logger);
            _textExtractionService = new TextExtractionService(
                _logger,
                new List<ITextExtractor>
                {
                    new PdfTextExtractor(_logger),
                    new DocxTextExtractor(_logger),
                    new PlainTextExtractor(_logger)
                }
            );

            _fileOrganizerService = new FileOrganizerService(
                _logger,
                _aiService,
                _textExtractionService,
                _credentialStorageService,
                _httpClient
            );

            // UI-progress en events koppelen aan de service
            _fileOrganizerService.ProgressChanged += (current, total) =>
            {
                if (progressBar1.InvokeRequired)
                    progressBar1.BeginInvoke(new Action(() => { progressBar1.Maximum = total; progressBar1.Value = current; }));
                else
                {
                    progressBar1.Maximum = total;
                    progressBar1.Value = current;
                }
            };
            _fileOrganizerService.TokensUsedUpdated += (tokens) =>
            {
                _totalTokensUsed = tokens;
                UpdateTokensUsedLabel();
            };

            // Callback voor interactieve rename
            _fileOrganizerService.RequestRenameFile += (originalName, suggestedName) =>
            {
                // UI-aanroep op main thread
                return Invoke((Func<Task<(DialogResult, string, bool)>>)(() =>
                {
                    using (var renameForm = new FormRenameFile(originalName, suggestedName))
                    {
                        DialogResult result = renameForm.ShowDialog();
                        return Task.FromResult((result, renameForm.NewFileName, renameForm.SkipFile));
                    }
                })) as Task<(DialogResult, string, bool)>;
            };

            _cancellationTokenSource = new CancellationTokenSource();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // Init providerselectie en standaardwaarden UI
            if (cmbProviderSelection.Items.Count == 0)
            {
                cmbProviderSelection.Items.AddRange(new object[]
                {
                    "Gemini (Google)",
                    "OpenAI (openai.com)",
                    "Azure OpenAI"
                });
            }
            cmbProviderSelection.SelectedIndexChanged -= cmbProviderSelection_SelectedIndexChanged;
            cmbProviderSelection.SelectedIndexChanged += cmbProviderSelection_SelectedIndexChanged;
            cmbProviderSelection.SelectedIndex = 0; // Zet eerste provider (triggert ook modelkeuze)

            txtApiKey.Text = "YOUR_GOOGLE_API_KEY_HERE";
            SetupApiKeyPlaceholder(txtApiKey, "YOUR_GOOGLE_API_KEY_HERE");
            txtApiKey.UseSystemPasswordChar = true;

            string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
            string documentsPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            txtSourceFolder.Text = Path.Combine(desktopPath, "AI Organizer Bronmap");
            txtDestinationFolder.Text = Path.Combine(documentsPath, "AI Organizer Resultaat");

            lblTokensUsed.Text = "Tokens gebruikt: 0";
            progressBar1.Minimum = 0;
            progressBar1.Value = 0;
            progressBar1.Style = ProgressBarStyle.Continuous;
            progressBar1.Visible = false;
            btnStopOrganization.Enabled = false;
            btnSaveLog.Enabled = false;
            chkRenameFiles.Checked = false;
            lblAzureEndpoint.Visible = false;
            txtAzureEndpoint.Visible = false;

            LoadApiKeyForSelectedProvider();
        }

        /// <summary>
        /// Laad API-key (en evt. Azure endpoint) uit Credential Manager op basis van provider.
        /// </summary>
        /// <summary>
        /// Laad de API-key (en evt. Azure endpoint) uit Credential Manager op basis van provider en
        /// zet deze altijd correct zichtbaar in het textfield. Als er geen key is, toon je een placeholder.
        /// </summary>
        private void LoadApiKeyForSelectedProvider()
        {
            string selectedProviderName = cmbProviderSelection.SelectedItem?.ToString() ?? "";
            (string loadedApiKey, string loadedAzureEndpoint) = _credentialStorageService.GetApiKey(selectedProviderName);

            // --- API KEY TEXTBOX ---
            if (!string.IsNullOrWhiteSpace(loadedApiKey))
            {
                // Toon de gevonden key als zwarte tekst
                txtApiKey.Text = loadedApiKey;
                txtApiKey.ForeColor = System.Drawing.Color.Black;
                txtApiKey.Tag = GetDefaultApiKeyPlaceholder(selectedProviderName); // Zorg dat de Tag klopt voor placeholder logic
            }
            else
            {
                // Geen opgeslagen key? Toon placeholder in grijs
                txtApiKey.Text = GetDefaultApiKeyPlaceholder(selectedProviderName);
                txtApiKey.ForeColor = System.Drawing.Color.Gray;
                txtApiKey.Tag = GetDefaultApiKeyPlaceholder(selectedProviderName);
            }

            // --- AZURE ENDPOINT TEXTBOX (alleen voor Azure OpenAI) ---
            if (selectedProviderName == "Azure OpenAI")
            {
                if (!string.IsNullOrWhiteSpace(loadedAzureEndpoint))
                {
                    txtAzureEndpoint.Text = loadedAzureEndpoint;
                    txtAzureEndpoint.ForeColor = System.Drawing.Color.Black;
                    txtAzureEndpoint.Tag = "YOUR_AZURE_ENDPOINT_HERE";
                }
                else
                {
                    txtAzureEndpoint.Text = "YOUR_AZURE_ENDPOINT_HERE";
                    txtAzureEndpoint.ForeColor = System.Drawing.Color.Gray;
                    txtAzureEndpoint.Tag = "YOUR_AZURE_ENDPOINT_HERE";
                }
            }
            else
            {
                txtAzureEndpoint.Text = "YOUR_AZURE_ENDPOINT_HERE";
                txtAzureEndpoint.ForeColor = System.Drawing.Color.Gray;
                txtAzureEndpoint.Tag = "YOUR_AZURE_ENDPOINT_HERE";
            }
        }

        private string GetDefaultApiKeyPlaceholder(string providerName)
        {
            if (providerName.Contains("Gemini")) return "YOUR_GOOGLE_API_KEY_HERE";
            if (providerName.Contains("OpenAI (openai.com)")) return "YOUR_OPENAI_API_KEY_HERE";
            if (providerName.Contains("Azure OpenAI")) return "YOUR_AZURE_ENDPOINT_HERE";
            return "YOUR_API_KEY_HERE";
        }

        /// <summary>
        /// Update modellenlijst en API-key veld bij wisselen van provider.
        /// </summary>
        private void cmbProviderSelection_SelectedIndexChanged(object sender, EventArgs e)
        {
            cmbModelSelection.Items.Clear();
            string provider = cmbProviderSelection.SelectedItem?.ToString() ?? "";
            if (provider == "Gemini (Google)")
            {
                cmbModelSelection.Items.AddRange(new object[] { "gemini-1.5-pro-latest", "gemini-1.5-flash-latest", "gemini-1.0-pro-latest", "gemini-pro", "gemini-2.5-pro-preview-05-06", "gemini-2.5-flash-preview-04-17", "gemini-2.0-flash-001", "gemini-2.0-flash-lite-001" });
                lblApiKey.Text = "Google API Key:";
                lblAzureEndpoint.Visible = false;
                txtAzureEndpoint.Visible = false;
            }
            else if (provider == "OpenAI (openai.com)")
            {
                cmbModelSelection.Items.AddRange(new object[] { "gpt-4o", "gpt-4-turbo", "gpt-4", "gpt-3.5-turbo", "gpt-3.5-turbo-0125", "gpt-3.5-turbo-0613" });
                lblApiKey.Text = "OpenAI API Key:";
                lblAzureEndpoint.Visible = false;
                txtAzureEndpoint.Visible = false;
            }
            else if (provider == "Azure OpenAI")
            {
                cmbModelSelection.Items.AddRange(new object[] { "YOUR-AZURE-DEPLOYMENT-NAME" });
                lblApiKey.Text = "Azure OpenAI API Key:";
                lblAzureEndpoint.Visible = true;
                txtAzureEndpoint.Visible = true;
            }
            cmbModelSelection.SelectedIndex = 0;
            LoadApiKeyForSelectedProvider();
        }

        /// <summary>
        /// Plaatst placeholder text in een TextBox en regelt kleur.
        /// </summary>
        private void SetupApiKeyPlaceholder(TextBox textBox, string placeholderText)
        {
            textBox.GotFocus -= RemoveApiKeyPlaceholderInternal;
            textBox.LostFocus -= AddApiKeyPlaceholderInternal;
            textBox.Tag = placeholderText;

            if (string.IsNullOrWhiteSpace(textBox.Text) || textBox.Text == placeholderText)
            {
                textBox.Text = placeholderText;
                textBox.ForeColor = System.Drawing.Color.Gray;
            }
            else
            {
                textBox.ForeColor = System.Drawing.Color.Black;
            }

            textBox.GotFocus += RemoveApiKeyPlaceholderInternal;
            textBox.LostFocus += AddApiKeyPlaceholderInternal;
        }

        private void RemoveApiKeyPlaceholderInternal(object sender, EventArgs e)
        {
            TextBox textBox = sender as TextBox;
            string placeholderText = textBox.Tag?.ToString();
            if (textBox.Text == placeholderText)
            {
                textBox.Text = "";
                textBox.ForeColor = System.Drawing.Color.Black;
            }
        }

        private void AddApiKeyPlaceholderInternal(object sender, EventArgs e)
        {
            TextBox textBox = sender as TextBox;
            string placeholderText = textBox.Tag?.ToString();
            if (string.IsNullOrWhiteSpace(textBox.Text))
            {
                textBox.Text = placeholderText;
                textBox.ForeColor = System.Drawing.Color.Gray;
            }
        }

        /// <summary>
        /// Moderne folderdialog voor bronmap selectie.
        /// </summary>
        private void btnSelectSourceFolder_Click(object sender, EventArgs e)
        {
            using (var dialog = new CommonOpenFileDialog())
            {
                dialog.IsFolderPicker = true;
                dialog.Title = "Selecteer de bronmap met bestanden (inclusief submappen)";
                dialog.InitialDirectory = Directory.Exists(txtSourceFolder.Text) ? txtSourceFolder.Text : Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
                dialog.RestoreDirectory = true;
                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    txtSourceFolder.Text = dialog.FileName;
                }
            }
        }

        /// <summary>
        /// Moderne folderdialog voor doelmap selectie.
        /// </summary>
        private void btnSelectDestinationFolder_Click(object sender, EventArgs e)
        {
            using (var dialog = new CommonOpenFileDialog())
            {
                dialog.IsFolderPicker = true;
                dialog.Title = "Selecteer de doelmap voor geordende bestanden";
                dialog.EnsurePathExists = true;
                dialog.InitialDirectory = Directory.Exists(txtDestinationFolder.Text) ? txtDestinationFolder.Text : Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                dialog.RestoreDirectory = true;
                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    txtDestinationFolder.Text = dialog.FileName;
                }
            }
        }

        /// <summary>
        /// Start bestandsorganisatieproces.
        /// </summary>
        private async void btnStartOrganization_Click(object sender, EventArgs e)
        {
            rtbLog.Clear();
            SetUiEnabled(false);
            btnStopOrganization.Enabled = true;
            btnSaveLog.Enabled = false;
            progressBar1.Visible = true;

            string apiKey = txtApiKey.Text;
            string currentApiKeyPlaceholder = txtApiKey.Tag?.ToString();
            if (string.IsNullOrWhiteSpace(apiKey) || apiKey == currentApiKeyPlaceholder)
            {
                _logger.Log("FOUT: Gelieve een geldige API Key in te vullen.");
                SetUiEnabled(true); btnStopOrganization.Enabled = false; progressBar1.Visible = false; return;
            }

            string providerName = cmbProviderSelection.SelectedItem?.ToString() ?? "";
            string azureEndpoint = txtAzureEndpoint.Text;
            string selectedModel = cmbModelSelection.SelectedItem?.ToString() ?? "gemini-1.5-pro-latest";

            if (!Directory.Exists(txtSourceFolder.Text))
            {
                _logger.Log($"FOUT: Bronmap '{txtSourceFolder.Text}' niet gevonden.");
                SetUiEnabled(true); btnStopOrganization.Enabled = false; progressBar1.Visible = false; return;
            }

            _logger.Log($"Starten met organiseren van bestanden uit: {txtSourceFolder.Text} (inclusief submappen)");
            _logger.Log($"Gebruikt model: {selectedModel}");
            if (chkRenameFiles.Checked)
            {
                _logger.Log("Bestandsnamen worden hernoemd met AI-suggesties.");
            }

            _totalTokensUsed = 0;
            UpdateTokensUsedLabel();
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = new CancellationTokenSource();

            try
            {
                await _fileOrganizerService.OrganizeFilesAsync(
                    txtSourceFolder.Text,
                    txtDestinationFolder.Text,
                    apiKey,
                    providerName,
                    selectedModel,
                    azureEndpoint,
                    chkRenameFiles.Checked,
                    _cancellationTokenSource.Token
                );
            }
            catch (OperationCanceledException)
            {
                _logger.Log("\nOrganisatie geannuleerd door gebruiker.");
            }
            catch (Exception ex)
            {
                _logger.Log($"KRITIEKE FOUT tijdens organisatie: {ex.Message}");
            }
            finally
            {
                _logger.Log("\nOrganisatie voltooid!");
                SetUiEnabled(true);
                btnStopOrganization.Enabled = false;
                btnSaveLog.Enabled = true;
                progressBar1.Visible = false;
                _cancellationTokenSource.Dispose();
                _cancellationTokenSource = null;
            }
        }

        /// <summary>
        /// Annuleert huidig organisatieproces.
        /// </summary>
        private void btnStopOrganization_Click(object sender, EventArgs e)
        {
            _cancellationTokenSource?.Cancel();
            _logger.Log("Annulering aangevraagd...");
            btnStopOrganization.Enabled = false;
        }

        /// <summary>
        /// Sla logbestand op via moderne dialoog.
        /// </summary>
        private void btnSaveLog_Click(object sender, EventArgs e)
        {
            using (var dialog = new CommonSaveFileDialog())
            {
                dialog.Filters.Add(new CommonFileDialogFilter("Tekstbestanden", "*.txt"));
                dialog.DefaultExtension = "txt";
                dialog.Title = "Sla logbestand op";
                dialog.DefaultFileName = $"AI_Organizer_Log_{DateTime.Now:yyyyMMdd_HHmmss}.txt";
                dialog.InitialDirectory = Directory.Exists(txtDestinationFolder.Text) ? txtDestinationFolder.Text : Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                dialog.RestoreDirectory = true;

                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    try
                    {
                        File.WriteAllText(dialog.FileName, rtbLog.Text);
                        MessageBox.Show("Logbestand succesvol opgeslagen.", "Succes", MessageBoxButtons.OK, MessageBoxIcon.Information);
                    }
                    catch (Exception ex)
                    {
                        MessageBox.Show($"Fout bij opslaan: {ex.Message}", "Fout", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    }
                }
            }
        }

        /// <summary>
        /// Schakelt UI-elementen in/uit.
        /// </summary>
        private void SetUiEnabled(bool enabled)
        {
            txtApiKey.Enabled = enabled;
            txtSourceFolder.Enabled = enabled;
            btnSelectSourceFolder.Enabled = enabled;
            txtDestinationFolder.Enabled = enabled;
            btnSelectDestinationFolder.Enabled = enabled;
            cmbModelSelection.Enabled = enabled;
            cmbProviderSelection.Enabled = enabled;
            txtAzureEndpoint.Enabled = enabled;
            btnStartOrganization.Enabled = enabled;
            btnRenameSingleFile.Enabled = enabled;
            linkLabelAuthor.Enabled = enabled;
            chkRenameFiles.Enabled = enabled;
        }

        /// <summary>
        /// Update token label (UI-thread safe).
        /// </summary>
        private void UpdateTokensUsedLabel()
        {
            if (InvokeRequired)
            {
                BeginInvoke(new Action(UpdateTokensUsedLabel));
                return;
            }
            lblTokensUsed.Text = $"Tokens gebruikt: {_totalTokensUsed}";
        }

        /// <summary>
        /// Open LinkedIn van auteur.
        /// </summary>
        private void linkLabelAuthor_LinkClicked(object sender, LinkLabelLinkClickedEventArgs e)
        {
            try
            {
                string url = "https://www.linkedin.com/in/remseymailjard/";
                Process.Start(new ProcessStartInfo
                {
                    FileName = url,
                    UseShellExecute = true
                });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"Kan link niet openen: {ex.Message}", "Fout", MessageBoxButtons.OK, MessageBoxIcon.Error);
            }
        }

        /// <summary>
        /// Hernaam √©√©n bestand via AI met moderne file-dialog.
        /// </summary>
        private async void btnRenameSingleFile_Click(object sender, EventArgs e)
        {
            rtbLog.Clear();
            SetUiEnabled(false);
            btnStopOrganization.Enabled = false;
            btnSaveLog.Enabled = false;
            progressBar1.Visible = false;

            string apiKey = txtApiKey.Text;
            if (string.IsNullOrWhiteSpace(apiKey) || (txtApiKey.Tag != null && apiKey == txtApiKey.Tag.ToString()))
            {
                _logger.Log("FOUT: Gelieve een geldige API Key in te vullen.");
                SetUiEnabled(true); return;
            }

            string selectedModel = cmbModelSelection.SelectedItem?.ToString() ?? "gemini-1.5-pro-latest";
            string providerName = cmbProviderSelection.SelectedItem?.ToString() ?? "Gemini (Google)";
            string azureEndpoint = txtAzureEndpoint?.Text;

            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = new CancellationTokenSource();

            using (var dialog = new CommonOpenFileDialog())
            {
                dialog.IsFolderPicker = false;
                dialog.EnsureFileExists = true;
                dialog.Multiselect = false;
                dialog.Title = "Selecteer een bestand om te hernoemen";
                dialog.Filters.Add(new CommonFileDialogFilter("Ondersteunde bestanden", "*.pdf;*.docx;*.txt;*.md"));
                dialog.Filters.Add(new CommonFileDialogFilter("PDF Bestanden", "*.pdf"));
                dialog.Filters.Add(new CommonFileDialogFilter("Word Documenten", "*.docx"));
                dialog.Filters.Add(new CommonFileDialogFilter("Tekst Bestanden", "*.txt;*.md"));
                dialog.Filters.Add(new CommonFileDialogFilter("Alle Bestanden", "*.*"));
                dialog.InitialDirectory = txtSourceFolder.Text;
                dialog.RestoreDirectory = true;

                if (dialog.ShowDialog() == CommonFileDialogResult.Ok)
                {
                    string filePath = dialog.FileName;
                    try
                    {
                        await _fileOrganizerService.RenameSingleFileInteractiveAsync(
                            filePath,
                            apiKey,
                            providerName,
                            selectedModel,
                            azureEndpoint,
                            _cancellationTokenSource.Token
                        );
                    }
                    catch (OperationCanceledException)
                    {
                        _logger.Log("Hernoem-actie geannuleerd door gebruiker.");
                    }
                    catch (Exception ex)
                    {
                        _logger.Log($"KRITIEKE FOUT tijdens enkel bestand hernoemen: {ex.Message}");
                    }
                }
                else
                {
                    _logger.Log("Bestandselectie geannuleerd. Geen bestand hernoemd.");
                }
            }
            SetUiEnabled(true);
            btnSaveLog.Enabled = true;
            _cancellationTokenSource.Dispose();
            _cancellationTokenSource = null;
        }
    }
}



================================================
FILE: Form1.Designer.cs
================================================
Ôªønamespace AI_FileOrganizer
{
    partial class Form1
    {
        private System.ComponentModel.IContainer components = null;

        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        private void InitializeComponent()
        {
            this.tableLayoutPanel1 = new System.Windows.Forms.TableLayoutPanel();
            this.lblProvider = new System.Windows.Forms.Label();
            this.cmbProviderSelection = new System.Windows.Forms.ComboBox();
            this.lblApiKey = new System.Windows.Forms.Label();
            this.txtApiKey = new System.Windows.Forms.TextBox();
            this.lblAzureEndpoint = new System.Windows.Forms.Label();
            this.txtAzureEndpoint = new System.Windows.Forms.TextBox();
            this.lblSourceFolder = new System.Windows.Forms.Label();
            this.txtSourceFolder = new System.Windows.Forms.TextBox();
            this.btnSelectSourceFolder = new System.Windows.Forms.Button();
            this.lblDestinationFolder = new System.Windows.Forms.Label();
            this.txtDestinationFolder = new System.Windows.Forms.TextBox();
            this.btnSelectDestinationFolder = new System.Windows.Forms.Button();
            this.lblModel = new System.Windows.Forms.Label();
            this.cmbModelSelection = new System.Windows.Forms.ComboBox();
            this.chkRenameFiles = new System.Windows.Forms.CheckBox();
            this.btnStartOrganization = new System.Windows.Forms.Button();
            this.btnStopOrganization = new System.Windows.Forms.Button();
            this.btnSaveLog = new System.Windows.Forms.Button();
            this.btnRenameSingleFile = new System.Windows.Forms.Button();
            this.progressBar1 = new System.Windows.Forms.ProgressBar();
            this.lblTokensUsed = new System.Windows.Forms.Label();
            this.rtbLog = new System.Windows.Forms.RichTextBox();
            this.linkLabelAuthor = new System.Windows.Forms.LinkLabel();
            this.tableLayoutPanel1.SuspendLayout();
            this.SuspendLayout();
            // 
            // tableLayoutPanel1
            // 
            this.tableLayoutPanel1.ColumnCount = 3;
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 20F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 60F));
            this.tableLayoutPanel1.ColumnStyles.Add(new System.Windows.Forms.ColumnStyle(System.Windows.Forms.SizeType.Percent, 20F));
            this.tableLayoutPanel1.Controls.Add(this.lblProvider, 0, 0);
            this.tableLayoutPanel1.Controls.Add(this.cmbProviderSelection, 1, 0);
            this.tableLayoutPanel1.Controls.Add(this.lblApiKey, 0, 1);
            this.tableLayoutPanel1.Controls.Add(this.txtApiKey, 1, 1);
            this.tableLayoutPanel1.Controls.Add(this.lblAzureEndpoint, 0, 2);
            this.tableLayoutPanel1.Controls.Add(this.txtAzureEndpoint, 1, 2);
            this.tableLayoutPanel1.Controls.Add(this.lblSourceFolder, 0, 3);
            this.tableLayoutPanel1.Controls.Add(this.txtSourceFolder, 1, 3);
            this.tableLayoutPanel1.Controls.Add(this.btnSelectSourceFolder, 2, 3);
            this.tableLayoutPanel1.Controls.Add(this.lblDestinationFolder, 0, 4);
            this.tableLayoutPanel1.Controls.Add(this.txtDestinationFolder, 1, 4);
            this.tableLayoutPanel1.Controls.Add(this.btnSelectDestinationFolder, 2, 4);
            this.tableLayoutPanel1.Controls.Add(this.lblModel, 0, 5);
            this.tableLayoutPanel1.Controls.Add(this.cmbModelSelection, 1, 5);
            this.tableLayoutPanel1.Controls.Add(this.chkRenameFiles, 0, 6);
            this.tableLayoutPanel1.Controls.Add(this.btnStartOrganization, 0, 7);
            this.tableLayoutPanel1.Controls.Add(this.btnStopOrganization, 1, 7);
            this.tableLayoutPanel1.Controls.Add(this.btnSaveLog, 2, 7);
            this.tableLayoutPanel1.Controls.Add(this.btnRenameSingleFile, 0, 8);
            this.tableLayoutPanel1.Controls.Add(this.progressBar1, 0, 9);
            this.tableLayoutPanel1.Controls.Add(this.lblTokensUsed, 2, 9);
            this.tableLayoutPanel1.Controls.Add(this.rtbLog, 0, 10);
            this.tableLayoutPanel1.Controls.Add(this.linkLabelAuthor, 0, 11);
            this.tableLayoutPanel1.Dock = System.Windows.Forms.DockStyle.Fill;
            this.tableLayoutPanel1.Location = new System.Drawing.Point(0, 0);
            this.tableLayoutPanel1.Name = "tableLayoutPanel1";
            this.tableLayoutPanel1.RowCount = 13;
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 28F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 25F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 36F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 36F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 22F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Percent, 100F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 26F));
            this.tableLayoutPanel1.RowStyles.Add(new System.Windows.Forms.RowStyle(System.Windows.Forms.SizeType.Absolute, 2F));
            this.tableLayoutPanel1.Size = new System.Drawing.Size(850, 480);
            this.tableLayoutPanel1.TabIndex = 0;
            // 
            // lblProvider
            // 
            this.lblProvider.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblProvider.AutoSize = true;
            this.lblProvider.Location = new System.Drawing.Point(3, 6);
            this.lblProvider.Name = "lblProvider";
            this.lblProvider.Size = new System.Drawing.Size(61, 16);
            this.lblProvider.TabIndex = 0;
            this.lblProvider.Text = "Provider:";
            // 
            // cmbProviderSelection
            // 
            this.cmbProviderSelection.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.cmbProviderSelection, 2);
            this.cmbProviderSelection.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbProviderSelection.Items.AddRange(new object[] {
            "Gemini (Google)",
            "OpenAI (openai.com)",
            "Azure OpenAI"});
            this.cmbProviderSelection.Location = new System.Drawing.Point(173, 3);
            this.cmbProviderSelection.Name = "cmbProviderSelection";
            this.cmbProviderSelection.Size = new System.Drawing.Size(674, 24);
            this.cmbProviderSelection.TabIndex = 1;
            this.cmbProviderSelection.SelectedIndexChanged += new System.EventHandler(this.cmbProviderSelection_SelectedIndexChanged);
            // 
            // lblApiKey
            // 
            this.lblApiKey.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblApiKey.AutoSize = true;
            this.lblApiKey.Location = new System.Drawing.Point(3, 34);
            this.lblApiKey.Name = "lblApiKey";
            this.lblApiKey.Size = new System.Drawing.Size(105, 16);
            this.lblApiKey.TabIndex = 2;
            this.lblApiKey.Text = "Google API Key:";
            // 
            // txtApiKey
            // 
            this.txtApiKey.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.txtApiKey, 2);
            this.txtApiKey.Location = new System.Drawing.Point(173, 31);
            this.txtApiKey.Name = "txtApiKey";
            this.txtApiKey.Size = new System.Drawing.Size(674, 22);
            this.txtApiKey.TabIndex = 3;
            this.txtApiKey.UseSystemPasswordChar = true;
            // 
            // lblAzureEndpoint
            // 
            this.lblAzureEndpoint.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblAzureEndpoint.AutoSize = true;
            this.lblAzureEndpoint.Location = new System.Drawing.Point(3, 62);
            this.lblAzureEndpoint.Name = "lblAzureEndpoint";
            this.lblAzureEndpoint.Size = new System.Drawing.Size(100, 16);
            this.lblAzureEndpoint.TabIndex = 4;
            this.lblAzureEndpoint.Text = "Azure Endpoint:";
            this.lblAzureEndpoint.Visible = false;
            // 
            // txtAzureEndpoint
            // 
            this.txtAzureEndpoint.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.txtAzureEndpoint, 2);
            this.txtAzureEndpoint.Location = new System.Drawing.Point(173, 59);
            this.txtAzureEndpoint.Name = "txtAzureEndpoint";
            this.txtAzureEndpoint.Size = new System.Drawing.Size(674, 22);
            this.txtAzureEndpoint.TabIndex = 5;
            this.txtAzureEndpoint.Visible = false;
            // 
            // lblSourceFolder
            // 
            this.lblSourceFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblSourceFolder.AutoSize = true;
            this.lblSourceFolder.Location = new System.Drawing.Point(3, 90);
            this.lblSourceFolder.Name = "lblSourceFolder";
            this.lblSourceFolder.Size = new System.Drawing.Size(95, 16);
            this.lblSourceFolder.TabIndex = 6;
            this.lblSourceFolder.Text = "Source Folder:";
            // 
            // txtSourceFolder
            // 
            this.txtSourceFolder.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.txtSourceFolder.Location = new System.Drawing.Point(173, 87);
            this.txtSourceFolder.Name = "txtSourceFolder";
            this.txtSourceFolder.ReadOnly = true;
            this.txtSourceFolder.Size = new System.Drawing.Size(504, 22);
            this.txtSourceFolder.TabIndex = 7;
            // 
            // btnSelectSourceFolder
            // 
            this.btnSelectSourceFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.btnSelectSourceFolder.Location = new System.Drawing.Point(683, 87);
            this.btnSelectSourceFolder.Name = "btnSelectSourceFolder";
            this.btnSelectSourceFolder.Size = new System.Drawing.Size(75, 22);
            this.btnSelectSourceFolder.TabIndex = 8;
            this.btnSelectSourceFolder.Text = "Select Source";
            this.btnSelectSourceFolder.Click += new System.EventHandler(this.btnSelectSourceFolder_Click);
            // 
            // lblDestinationFolder
            // 
            this.lblDestinationFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblDestinationFolder.AutoSize = true;
            this.lblDestinationFolder.Location = new System.Drawing.Point(3, 118);
            this.lblDestinationFolder.Name = "lblDestinationFolder";
            this.lblDestinationFolder.Size = new System.Drawing.Size(119, 16);
            this.lblDestinationFolder.TabIndex = 9;
            this.lblDestinationFolder.Text = "Destination Folder:";
            // 
            // txtDestinationFolder
            // 
            this.txtDestinationFolder.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.txtDestinationFolder.Location = new System.Drawing.Point(173, 115);
            this.txtDestinationFolder.Name = "txtDestinationFolder";
            this.txtDestinationFolder.ReadOnly = true;
            this.txtDestinationFolder.Size = new System.Drawing.Size(504, 22);
            this.txtDestinationFolder.TabIndex = 10;
            // 
            // btnSelectDestinationFolder
            // 
            this.btnSelectDestinationFolder.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.btnSelectDestinationFolder.Location = new System.Drawing.Point(683, 115);
            this.btnSelectDestinationFolder.Name = "btnSelectDestinationFolder";
            this.btnSelectDestinationFolder.Size = new System.Drawing.Size(75, 22);
            this.btnSelectDestinationFolder.TabIndex = 11;
            this.btnSelectDestinationFolder.Text = "Select Destination";
            this.btnSelectDestinationFolder.Click += new System.EventHandler(this.btnSelectDestinationFolder_Click);
            // 
            // lblModel
            // 
            this.lblModel.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.lblModel.AutoSize = true;
            this.lblModel.Location = new System.Drawing.Point(3, 146);
            this.lblModel.Name = "lblModel";
            this.lblModel.Size = new System.Drawing.Size(48, 16);
            this.lblModel.TabIndex = 12;
            this.lblModel.Text = "Model:";
            // 
            // cmbModelSelection
            // 
            this.cmbModelSelection.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.cmbModelSelection, 2);
            this.cmbModelSelection.DropDownStyle = System.Windows.Forms.ComboBoxStyle.DropDownList;
            this.cmbModelSelection.Location = new System.Drawing.Point(173, 143);
            this.cmbModelSelection.Name = "cmbModelSelection";
            this.cmbModelSelection.Size = new System.Drawing.Size(674, 24);
            this.cmbModelSelection.TabIndex = 13;
            // 
            // chkRenameFiles
            // 
            this.chkRenameFiles.Anchor = System.Windows.Forms.AnchorStyles.Left;
            this.chkRenameFiles.AutoSize = true;
            this.tableLayoutPanel1.SetColumnSpan(this.chkRenameFiles, 3);
            this.chkRenameFiles.Location = new System.Drawing.Point(3, 171);
            this.chkRenameFiles.Name = "chkRenameFiles";
            this.chkRenameFiles.Size = new System.Drawing.Size(213, 19);
            this.chkRenameFiles.TabIndex = 14;
            this.chkRenameFiles.Text = "Bestandsnamen AI hernoemen";
            // 
            // btnStartOrganization
            // 
            this.btnStartOrganization.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnStartOrganization.Location = new System.Drawing.Point(3, 196);
            this.btnStartOrganization.Name = "btnStartOrganization";
            this.btnStartOrganization.Size = new System.Drawing.Size(164, 30);
            this.btnStartOrganization.TabIndex = 15;
            this.btnStartOrganization.Text = "Start Organisatie";
            this.btnStartOrganization.Click += new System.EventHandler(this.btnStartOrganization_Click);
            // 
            // btnStopOrganization
            // 
            this.btnStopOrganization.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnStopOrganization.Location = new System.Drawing.Point(173, 196);
            this.btnStopOrganization.Name = "btnStopOrganization";
            this.btnStopOrganization.Size = new System.Drawing.Size(504, 30);
            this.btnStopOrganization.TabIndex = 16;
            this.btnStopOrganization.Text = "Stop Organisatie";
            this.btnStopOrganization.Click += new System.EventHandler(this.btnStopOrganization_Click);
            // 
            // btnSaveLog
            // 
            this.btnSaveLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnSaveLog.Location = new System.Drawing.Point(683, 196);
            this.btnSaveLog.Name = "btnSaveLog";
            this.btnSaveLog.Size = new System.Drawing.Size(164, 30);
            this.btnSaveLog.TabIndex = 17;
            this.btnSaveLog.Text = "Log Opslaan";
            this.btnSaveLog.Click += new System.EventHandler(this.btnSaveLog_Click);
            // 
            // btnRenameSingleFile
            // 
            this.tableLayoutPanel1.SetColumnSpan(this.btnRenameSingleFile, 3);
            this.btnRenameSingleFile.Dock = System.Windows.Forms.DockStyle.Fill;
            this.btnRenameSingleFile.Location = new System.Drawing.Point(3, 232);
            this.btnRenameSingleFile.Name = "btnRenameSingleFile";
            this.btnRenameSingleFile.Size = new System.Drawing.Size(844, 30);
            this.btnRenameSingleFile.TabIndex = 18;
            this.btnRenameSingleFile.Text = "Hernoem Enkel Bestand met AI";
            this.btnRenameSingleFile.UseVisualStyleBackColor = true;
            this.btnRenameSingleFile.Click += new System.EventHandler(this.btnRenameSingleFile_Click);
            // 
            // progressBar1
            // 
            this.progressBar1.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Left | System.Windows.Forms.AnchorStyles.Right)));
            this.tableLayoutPanel1.SetColumnSpan(this.progressBar1, 2);
            this.progressBar1.Location = new System.Drawing.Point(3, 268);
            this.progressBar1.Name = "progressBar1";
            this.progressBar1.Size = new System.Drawing.Size(674, 16);
            this.progressBar1.TabIndex = 19;
            this.progressBar1.Visible = false;
            // 
            // lblTokensUsed
            // 
            this.lblTokensUsed.Anchor = System.Windows.Forms.AnchorStyles.Right;
            this.lblTokensUsed.AutoSize = true;
            this.lblTokensUsed.Location = new System.Drawing.Point(730, 268);
            this.lblTokensUsed.Name = "lblTokensUsed";
            this.lblTokensUsed.Size = new System.Drawing.Size(117, 16);
            this.lblTokensUsed.TabIndex = 20;
            this.lblTokensUsed.Text = "Tokens gebruikt: 0";
            // 
            // rtbLog
            // 
            this.tableLayoutPanel1.SetColumnSpan(this.rtbLog, 3);
            this.rtbLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.rtbLog.Location = new System.Drawing.Point(3, 290);
            this.rtbLog.Name = "rtbLog";
            this.rtbLog.ReadOnly = true;
            this.rtbLog.Size = new System.Drawing.Size(844, 159);
            this.rtbLog.TabIndex = 21;
            this.rtbLog.Text = "";
            // 
            // linkLabelAuthor
            // 
            this.linkLabelAuthor.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right)));
            this.linkLabelAuthor.AutoSize = true;
            this.tableLayoutPanel1.SetColumnSpan(this.linkLabelAuthor, 3);
            this.linkLabelAuthor.Location = new System.Drawing.Point(682, 462);
            this.linkLabelAuthor.Name = "linkLabelAuthor";
            this.linkLabelAuthor.Size = new System.Drawing.Size(165, 16);
            this.linkLabelAuthor.TabIndex = 22;
            this.linkLabelAuthor.TabStop = true;
            this.linkLabelAuthor.Text = "Made by Remsey Mailjard";
            this.linkLabelAuthor.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
            this.linkLabelAuthor.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabelAuthor_LinkClicked);
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(850, 480);
            this.Controls.Add(this.tableLayoutPanel1);
            this.Name = "Form1";
            this.Text = "AI File Organizer - Remsey Mailjard";
            this.Load += new System.EventHandler(this.Form1_Load);
            this.tableLayoutPanel1.ResumeLayout(false);
            this.tableLayoutPanel1.PerformLayout();
            this.ResumeLayout(false);

        }

        #endregion

        private System.Windows.Forms.TableLayoutPanel tableLayoutPanel1;
        private System.Windows.Forms.Label lblProvider;
        private System.Windows.Forms.ComboBox cmbProviderSelection;
        private System.Windows.Forms.Label lblApiKey;
        private System.Windows.Forms.TextBox txtApiKey;
        private System.Windows.Forms.Label lblAzureEndpoint;
        private System.Windows.Forms.TextBox txtAzureEndpoint;
        private System.Windows.Forms.Label lblSourceFolder;
        private System.Windows.Forms.TextBox txtSourceFolder;
        private System.Windows.Forms.Button btnSelectSourceFolder;
        private System.Windows.Forms.Label lblDestinationFolder;
        private System.Windows.Forms.TextBox txtDestinationFolder;
        private System.Windows.Forms.Button btnSelectDestinationFolder;
        private System.Windows.Forms.Label lblModel;
        private System.Windows.Forms.ComboBox cmbModelSelection;
        private System.Windows.Forms.CheckBox chkRenameFiles;
        private System.Windows.Forms.Button btnStartOrganization;
        private System.Windows.Forms.Button btnStopOrganization;
        private System.Windows.Forms.Button btnSaveLog;
        private System.Windows.Forms.ProgressBar progressBar1;
        private System.Windows.Forms.Label lblTokensUsed;
        private System.Windows.Forms.RichTextBox rtbLog;
        private System.Windows.Forms.LinkLabel linkLabelAuthor;
        private System.Windows.Forms.Button btnRenameSingleFile;
    }
}



================================================
FILE: Form1.resx
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
FILE: FormRenameFile.cs
================================================
Ôªøusing System;
using System.IO;
using System.Linq; // This using statement is explicitly needed for .Any() and .Contains()
using System.Windows.Forms;

namespace AI_FileOrganizer
{
    public partial class FormRenameFile : Form
    {
        public string NewFileName { get; private set; }
        public bool SkipFile { get; private set; } = false;

        public FormRenameFile(string originalFileName, string suggestedFileName)
        {
            InitializeComponent(); // This call links to the FormRenameFile.Designer.cs file
            lblOriginalFileName.Text = originalFileName;
            txtSuggestedFileName.Text = suggestedFileName;
            NewFileName = suggestedFileName; // Default value
        }

        private void btnSave_Click(object sender, EventArgs e)
        {
            string newName = txtSuggestedFileName.Text.Trim();
            if (string.IsNullOrWhiteSpace(newName))
            {
                MessageBox.Show("De nieuwe bestandsnaam mag niet leeg zijn.", "Ongeldige naam", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            // Basis validatie: verwijder ongeldige karakters voor bestandsnamen
            char[] invalidChars = Path.GetInvalidFileNameChars();
            if (newName.Any(c => invalidChars.Contains(c)))
            {
                MessageBox.Show($"De nieuwe bestandsnaam bevat ongeldige karakters. Vermijd: {string.Join("", invalidChars)}", "Ongeldige naam", MessageBoxButtons.OK, MessageBoxIcon.Warning);
                return;
            }

            NewFileName = newName;
            this.DialogResult = DialogResult.OK;
            this.Close();
        }

        private void btnSkip_Click(object sender, EventArgs e)
        {
            SkipFile = true;
            this.DialogResult = DialogResult.OK; // Gebruik OK om aan te geven dat een beslissing is genomen (overslaan)
            this.Close();
        }

        private void btnCancel_Click(object sender, EventArgs e)
        {
            this.DialogResult = DialogResult.Cancel;
            this.Close();
        }

        private void FormRenameFile_Load(object sender, EventArgs e)
        {
            // Any specific load logic for the form
        }
    }
}


================================================
FILE: FormRenameFile.Designer.cs
================================================
Ôªøusing System.Linq; // Although not strictly needed for designer code, it was in your original.

namespace AI_FileOrganizer
{
    partial class FormRenameFile
    {
        /// <summary>
        /// Required designer variable.
        /// </summary>
        private System.ComponentModel.IContainer components = null;

        /// <summary>
        /// Clean up any resources being used.
        /// </summary>
        /// <param name="disposing">true if managed resources should be disposed; otherwise, false.</param>
        protected override void Dispose(bool disposing)
        {
            if (disposing && (components != null))
            {
                components.Dispose();
            }
            base.Dispose(disposing);
        }

        #region Windows Form Designer generated code

        /// <summary>
        /// Required method for Designer support - do not modify
        /// the contents of this method with the code editor.
        /// </summary>
        private void InitializeComponent()
        {
            this.lblOriginalFileName = new System.Windows.Forms.Label();
            this.txtSuggestedFileName = new System.Windows.Forms.TextBox();
            this.btnSave = new System.Windows.Forms.Button();
            this.btnSkip = new System.Windows.Forms.Button();
            this.btnCancel = new System.Windows.Forms.Button();
            this.label1 = new System.Windows.Forms.Label();
            this.label2 = new System.Windows.Forms.Label();
            this.SuspendLayout();
            //
            // lblOriginalFileName
            //
            this.lblOriginalFileName.AutoSize = true;
            this.lblOriginalFileName.Location = new System.Drawing.Point(145, 23);
            this.lblOriginalFileName.Name = "lblOriginalFileName";
            this.lblOriginalFileName.Size = new System.Drawing.Size(150, 16);
            this.lblOriginalFileName.TabIndex = 0;
            this.lblOriginalFileName.Text = "[Oorspronkelijke Naam]";
            //
            // txtSuggestedFileName
            //
            this.txtSuggestedFileName.Location = new System.Drawing.Point(148, 62);
            this.txtSuggestedFileName.Name = "txtSuggestedFileName";
            this.txtSuggestedFileName.Size = new System.Drawing.Size(300, 22);
            this.txtSuggestedFileName.TabIndex = 1;
            //
            // btnSave
            //
            this.btnSave.Location = new System.Drawing.Point(148, 105);
            this.btnSave.Name = "btnSave";
            this.btnSave.Size = new System.Drawing.Size(95, 30);
            this.btnSave.TabIndex = 2;
            this.btnSave.Text = "Opslaan";
            this.btnSave.UseVisualStyleBackColor = true;
            this.btnSave.Click += new System.EventHandler(this.btnSave_Click);
            //
            // btnSkip
            //
            this.btnSkip.Location = new System.Drawing.Point(249, 105);
            this.btnSkip.Name = "btnSkip";
            this.btnSkip.Size = new System.Drawing.Size(95, 30);
            this.btnSkip.TabIndex = 3;
            this.btnSkip.Text = "Overslaan";
            this.btnSkip.UseVisualStyleBackColor = true;
            this.btnSkip.Click += new System.EventHandler(this.btnSkip_Click);
            //
            // btnCancel
            //
            this.btnCancel.Location = new System.Drawing.Point(350, 105);
            this.btnCancel.Name = "btnCancel";
            this.btnCancel.Size = new System.Drawing.Size(98, 30);
            this.btnCancel.TabIndex = 4;
            this.btnCancel.Text = "Annuleren";
            this.btnCancel.UseVisualStyleBackColor = true;
            this.btnCancel.Click += new System.EventHandler(this.btnCancel_Click);
            //
            // label1
            //
            this.label1.AutoSize = true;
            this.label1.Location = new System.Drawing.Point(22, 23);
            this.label1.Name = "label1";
            this.label1.Size = new System.Drawing.Size(101, 16);
            this.label1.TabIndex = 5;
            this.label1.Text = "Originele naam:";
            //
            // label2
            //
            this.label2.AutoSize = true;
            this.label2.Location = new System.Drawing.Point(22, 65);
            this.label2.Name = "label2";
            this.label2.Size = new System.Drawing.Size(129, 16);
            this.label2.TabIndex = 6;
            this.label2.Text = "Voorgestelde naam:";
            //
            // FormRenameFile
            //
            this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 16F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(477, 158);
            this.Controls.Add(this.label2);
            this.Controls.Add(this.label1);
            this.Controls.Add(this.btnCancel);
            this.Controls.Add(this.btnSkip);
            this.Controls.Add(this.btnSave);
            this.Controls.Add(this.txtSuggestedFileName);
            this.Controls.Add(this.lblOriginalFileName);
            this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
            this.MaximizeBox = false;
            this.MinimizeBox = false;
            this.Name = "FormRenameFile";
            this.StartPosition = System.Windows.Forms.FormStartPosition.CenterParent;
            this.Text = "Bestandsnaam Aanpassen";
            this.Load += new System.EventHandler(this.FormRenameFile_Load);
            this.ResumeLayout(false);
            this.PerformLayout();

        }

        #endregion

        private System.Windows.Forms.Label lblOriginalFileName;
        private System.Windows.Forms.TextBox txtSuggestedFileName;
        private System.Windows.Forms.Button btnSave;
        private System.Windows.Forms.Button btnSkip;
        private System.Windows.Forms.Button btnCancel;
        private System.Windows.Forms.Label label1;
        private System.Windows.Forms.Label label2;
    }
}


================================================
FILE: FormRenameFile.resx
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
FILE: packages.config
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<packages>
  <package id="Azure.AI.OpenAI" version="2.1.0" targetFramework="net48" />
  <package id="Azure.Core" version="1.44.1" targetFramework="net48" />
  <package id="CredentialManagement" version="1.0.2" targetFramework="net48" />
  <package id="DocumentFormat.OpenXml" version="3.3.0" targetFramework="net48" />
  <package id="DocumentFormat.OpenXml.Framework" version="3.3.0" targetFramework="net48" />
  <package id="Google_GenerativeAI" version="2.5.10" targetFramework="net48" />
  <package id="Microsoft.Bcl.AsyncInterfaces" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Bcl.HashCode" version="6.0.0" targetFramework="net48" />
  <package id="Microsoft.Extensions.DependencyInjection" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.DependencyInjection.Abstractions" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Logging" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Logging.Abstractions" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Options" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft.Extensions.Primitives" version="9.0.3" targetFramework="net48" />
  <package id="Microsoft-WindowsAPICodePack-Core" version="1.1.5" targetFramework="net48" />
  <package id="Microsoft-WindowsAPICodePack-Shell" version="1.1.5" targetFramework="net48" />
  <package id="Newtonsoft.Json" version="13.0.3" targetFramework="net48" />
  <package id="OpenAI" version="2.1.0" targetFramework="net48" />
  <package id="PdfPig" version="0.1.10" targetFramework="net48" />
  <package id="System.Buffers" version="4.6.0" targetFramework="net48" />
  <package id="System.ClientModel" version="1.2.1" targetFramework="net48" />
  <package id="System.ComponentModel.Annotations" version="5.0.0" targetFramework="net48" />
  <package id="System.Diagnostics.DiagnosticSource" version="9.0.3" targetFramework="net48" />
  <package id="System.IO" version="4.3.0" targetFramework="net48" />
  <package id="System.IO.Pipelines" version="9.0.3" targetFramework="net48" />
  <package id="System.Memory" version="4.6.0" targetFramework="net48" />
  <package id="System.Memory.Data" version="6.0.0" targetFramework="net48" />
  <package id="System.Net.Http" version="4.3.4" targetFramework="net48" />
  <package id="System.Numerics.Vectors" version="4.6.0" targetFramework="net48" />
  <package id="System.Runtime" version="4.3.0" targetFramework="net48" />
  <package id="System.Runtime.CompilerServices.Unsafe" version="6.1.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Algorithms" version="4.3.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Encoding" version="4.3.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.Primitives" version="4.3.0" targetFramework="net48" />
  <package id="System.Security.Cryptography.X509Certificates" version="4.3.0" targetFramework="net48" />
  <package id="System.Text.Encodings.Web" version="9.0.3" targetFramework="net48" />
  <package id="System.Text.Json" version="9.0.3" targetFramework="net48" />
  <package id="System.Threading.Tasks.Extensions" version="4.5.4" targetFramework="net48" />
  <package id="System.ValueTuple" version="4.5.0" targetFramework="net48" />
  <package id="Xceed.Document.NET" version="5.0.25228.6154" targetFramework="net48" />
  <package id="Xceed.Drawing.NET" version="1.0.25228.6154" targetFramework="net48" />
  <package id="Xceed.Pdf" version="5.0.25228.6154" targetFramework="net48" />
  <package id="Xceed.Words.NET" version="5.0.25228.6154" targetFramework="net48" />
</packages>


================================================
FILE: Program.cs
================================================
Ôªøusing System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AI_FileOrganizer
{
    internal static class Program
    {
        /// <summary>
        /// The main entry point for the application.
        /// </summary>
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new Form1());
        }
    }
}



================================================
FILE: README_AI_File_Organizer.md
================================================

# AI File Organizer üöÄ

Een slimme en gebruiksvriendelijke applicatie voor het automatisch ordenen en hernoemen van bestanden met behulp van geavanceerde AI-modellen zoals Gemini, OpenAI en Azure OpenAI.

## üìå Vereisten

- Windows 10 of hoger
- .NET Framework 4.8 (wordt automatisch ge√Ønstalleerd indien nodig)
- Een geldige API Key voor Gemini (Google), OpenAI, of Azure OpenAI
- Zorg ervoor dat billing actief is op je AI-provider project.

## üöÄ Installatie

Volg onderstaande stappen om de applicatie te installeren:

1. **Download** het installatiebestand (`setup.exe`) vanuit deze map.
2. Dubbelklik op het bestand `setup.exe` om het installatieproces te starten.
3. Volg de instructies van de installatie-wizard.

> **Let op**: Tijdens de installatie kan het nodig zijn om administratorrechten te verlenen.

## üóùÔ∏è API Key instellen

Na installatie, volg deze stappen:

1. Open de applicatie "AI File Organizer".
2. Vul je API-sleutel in bij het daarvoor bestemde veld (Gemini, OpenAI of Azure).
3. Selecteer het gewenste AI-model.

## üìÅ Bestanden organiseren

- Selecteer een **bronmap** met bestanden die je wilt organiseren.
- Kies een **doelmap** waar bestanden automatisch worden georganiseerd.
- Optioneel: vink aan of bestanden automatisch door AI moeten worden hernoemd.
- Klik op **Start** en de applicatie doet de rest!

## üìë Logs en monitoring

Tijdens het organiseren toont de applicatie live voortgang en logs. Logs kunnen achteraf worden opgeslagen als tekstbestand.

## üõ†Ô∏è Ondersteunde bestandstypen

- PDF (`.pdf`)
- Word-documenten (`.docx`)
- Tekstbestanden (`.txt`, `.md`)

## üìû Support & Feedback

Heb je hulp nodig of idee√´n om de applicatie te verbeteren? Neem gerust contact op via:

- **LinkedIn**: [Remsey Mailjard](https://www.linkedin.com/in/remseymailjard/)
- **Website**: [remsey.nl](https://www.remsey.nl)

Veel plezier met organiseren! üéâ

---

¬© 2025 Remsey Mailjard | AI File Organizer



================================================
FILE: Models/ApplicationSettings.cs
================================================
Ôªøusing System.Collections.Generic;

namespace AI_FileOrganizer.Models
{
    public static class ApplicationSettings
    {
        public const int MaxTextLengthForLlm = 30000;
        public const int MinSubfolderNameLength = 3;
        public const int MaxSubfolderNameLength = 50;
        public const int MaxFilenameLength = 100; // Maximum length for AI-generated filename

        public static readonly string[] SupportedExtensions = { ".pdf", ".docx", ".txt", ".md" };

        public static readonly Dictionary<string, string> FolderCategories = new Dictionary<string, string>
            {
                { "Financi√´n", "1. Financieel" },
                { "Belastingen", "2. Belastingzaken" },
                { "Verzekeringen", "3. Verzekeringen en Polissen" },
                { "Woning", "4. Huis en Wonen" },
                { "Gezondheid en Medisch", "5. Gezondheid en Zorg" },
                { "Familie en Kinderen", "6. Gezin en Familie" },
                { "Voertuigen", "7. Vervoer en Voertuigen" },
                { "Persoonlijke Documenten", "8. Identiteit en Documenten" },
                { "Hobbies en interesses", "9. Vrije Tijd en Hobby's" },
                { "Carri√®re en Professionele Ontwikkeling", "10. Werk en Loopbaan" },
                { "Bedrijfsadministratie", "11. Zakelijke Administratie" },
                { "Reizen en vakanties", "12. Vakanties en Reizen" }
            };

        public const string FallbackCategoryName = "Diversen";

        public static string FallbackFolderName => $"0. {FallbackCategoryName}";
    }
}


================================================
FILE: Properties/AssemblyInfo.cs
================================================
Ôªøusing System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// General Information about an assembly is controlled through the following
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
[assembly: AssemblyTitle("AI-FileOrganizer2")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("AI-FileOrganizer2")]
[assembly: AssemblyCopyright("Copyright ¬©  2025")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// Setting ComVisible to false makes the types in this assembly not visible
// to COM components.  If you need to access a type in this assembly from
// COM, set the ComVisible attribute to true on that type.
[assembly: ComVisible(false)]

// The following GUID is for the ID of the typelib if this project is exposed to COM
[assembly: Guid("a58ebe3f-c926-432e-b874-ad6f29494ac7")]

// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Build and Revision Numbers
// by using the '*' as shown below:
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]



================================================
FILE: Properties/Resources.Designer.cs
================================================
Ôªø//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AI_FileOrganizer.Properties
{


    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class Resources
    {

        private static global::System.Resources.ResourceManager resourceMan;

        private static global::System.Globalization.CultureInfo resourceCulture;

        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal Resources()
        {
        }

        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager
        {
            get
            {
                if ((resourceMan == null))
                {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("AI_FileOrganizer.Properties.Resources", typeof(Resources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }

        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture
        {
            get
            {
                return resourceCulture;
            }
            set
            {
                resourceCulture = value;
            }
        }
    }
}



================================================
FILE: Properties/Resources.resx
================================================
Ôªø<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
</root>


================================================
FILE: Properties/Settings.Designer.cs
================================================
Ôªø//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace AI_FileOrganizer.Properties
{


    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.Editors.SettingsDesigner.SettingsSingleFileGenerator", "11.0.0.0")]
    internal sealed partial class Settings : global::System.Configuration.ApplicationSettingsBase
    {

        private static Settings defaultInstance = ((Settings)(global::System.Configuration.ApplicationSettingsBase.Synchronized(new Settings())));

        public static Settings Default
        {
            get
            {
                return defaultInstance;
            }
        }
    }
}



================================================
FILE: Properties/Settings.settings
================================================
Ôªø<?xml version='1.0' encoding='utf-8'?>
<SettingsFile xmlns="http://schemas.microsoft.com/VisualStudio/2004/01/settings" CurrentProfile="(Default)">
  <Profiles>
    <Profile Name="(Default)" />
  </Profiles>
  <Settings />
</SettingsFile>



================================================
FILE: Services/AiClassificationService.cs
================================================
Ôªøusing System;
using System.Collections.Generic;
using System.Globalization;
using System.IO; // Nodig voor Path.GetFileNameWithoutExtension
using System.Linq;
using System.Text.RegularExpressions; // NIEUW: Nodig voor Regex.Replace
using System.Threading;
using System.Threading.Tasks;

using AI_FileOrganizer.Utils; // Nodig voor FileUtils en ILogger

namespace AI_FileOrganizer.Services
{
    public class AiClassificationService
    {
        private readonly ILogger _logger;

        private const string DEFAULT_FALLBACK_CATEGORY = "Overig";

        // Nieuwe constanten voor de AI-parameters, per taak
        private const int CATEGORY_MAX_TOKENS = 50;
        private const float CATEGORY_TEMPERATURE = 0.0f; // Lager voor precieze classificatie

        private const int SUBFOLDER_MAX_TOKENS = 20;
        private const float SUBFOLDER_TEMPERATURE = 0.2f; // Iets hoger voor creativiteit, maar nog steeds gericht

        private const int FILENAME_MAX_TOKENS = 30;
        private const float FILENAME_TEMPERATURE = 0.3f; // Nog iets hoger voor creativiteit

        public AiClassificationService(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Helpt bij het voorbereiden van tekst voor de AI door te controleren op zinvolle inhoud.
        /// Geeft een fallback-tekst terug met instructies als de originele tekst niet zinvol is.
        /// </summary>
        /// <param name="extractedText">De reeds ge√´xtraheerde tekst uit het document.</param>
        /// <param name="originalFilename">De originele bestandsnaam, gebruikt voor fallback context.</param>
        /// <param name="maxLength">Maximale lengte van de tekst die naar de AI wordt gestuurd.</param>
        /// <param name="wasTextMeaningful">Output parameter die aangeeft of de originele tekst zinvol was.</param>
        /// <returns>De tekst die naar de AI moet worden gestuurd.</returns>
        private string GetRelevantTextForAI(string extractedText, string originalFilename, int maxLength, out bool wasTextMeaningful)
        {
            // Controleer of de ge√´xtraheerde tekst zinvolle karakters bevat na trimmen
            if (string.IsNullOrWhiteSpace(extractedText?.Trim()))
            {
                wasTextMeaningful = false;
                // Geef de AI een expliciete instructie dat er geen tekstinhoud is en dat de focus op de bestandsnaam moet liggen.
                return $"Dit document heeft de bestandsnaam '{Path.GetFileNameWithoutExtension(originalFilename)}'. Er kon geen inhoud uit het document worden ge√´xtraheerd, of de inhoud was leeg. Analyseer alleen de bestandsnaam en probeer daaruit de essentie te halen.";
            }
            else
            {
                wasTextMeaningful = true;
                // Retourneer een afgekorte versie van de ge√´xtraheerde tekst
                return extractedText.Substring(0, Math.Min(extractedText.Length, maxLength));
            }
        }


        // ======= Publieke AI-methodes =======

        /// <summary>
        /// Classificeert de categorie van een document op basis van de tekstinhoud of bestandsnaam.
        /// </summary>
        /// <param name="textToClassify">De ge√´xtraheerde tekstinhoud van het document.</param>
        /// <param name="originalFilename">De originele bestandsnaam van het document. BELANGRIJK: Deze parameter is NIEUW.</param>
        /// <param name="categories">Lijst van mogelijke categorie√´n.</param>
        /// <param name="aiProvider">De AI-provider om de classificatie uit te voeren.</param>
        /// <param name="modelName">De naam van het AI-model.</param>
        /// <param name="cancellationToken">Token om de operatie te annuleren.</param>
        /// <returns>De geclassificeerde categorienaam.</returns>
        public async Task<string> ClassifyCategoryAsync(
            string textToClassify,
            string originalFilename, // NIEUW: originalFilename is nu een parameter
            List<string> categories,
            IAiProvider aiProvider,
            string modelName,
            CancellationToken cancellationToken)
        {
            if (string.IsNullOrWhiteSpace(textToClassify) && string.IsNullOrWhiteSpace(originalFilename))
            {
                _logger.Log("WAARSCHUWING: Geen tekst en geen bestandsnaam om te classificeren. Retourneer fallback categorie.");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            if (aiProvider == null)
            {
                _logger.Log("FOUT: AI-provider is null voor categorieclassificatie.");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            if (string.IsNullOrWhiteSpace(modelName))
            {
                _logger.Log("FOUT: Modelnaam is leeg voor categorieclassificatie.");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            var validCategories = new List<string>(categories) { DEFAULT_FALLBACK_CATEGORY };
            var categoryListForPrompt = string.Join("\n- ", categories);

            bool wasTextMeaningful;
            string aiInputText = GetRelevantTextForAI(textToClassify, originalFilename, 8000, out wasTextMeaningful);

            string textContext = wasTextMeaningful ?
                $@"<tekst_inhoud>
{aiInputText}
</tekst_inhoud>" :
                $@"<document_zonder_inhoud>
{aiInputText}
</document_zonder_inhode>";

            // AANGEPAST: Few-shot voorbeelden genereren nu ALLEEN de categorienaam.
            var fewShotExamples = @"
Voorbeeld 1:
Tekst: 'Ik heb mijn autoverzekering aangepast bij Interpolis.'
Antwoord: Verzekeringen

Voorbeeld 2:
Tekst: 'Onze zomervakantie naar Spanje is geboekt.'
Antwoord: Reizen en vakanties

Voorbeeld 3:
Tekst: 'Ik heb mijn salaris ontvangen en overgemaakt naar mijn spaarrekening.'
Antwoord: Financi√´n

Voorbeeld 4:
Tekst: 'De belastingaangifte voor 2022 is binnen.'
Antwoord: Belastingen

Voorbeeld 5:
Bestandsnaam: huwelijksakte_familie_Jansen.pdf
Tekst: Dit document heeft de bestandsnaam 'huwelijksakte_familie_Jansen'. Er kon geen inhoud uit het document worden ge√´xtraheerd, of de inhoud was leeg. Analyseer alleen de bestandsnaam en probeer daaruit de essentie te halen.
Antwoord: Persoonlijke documenten
";

            var prompt = $@"
Je bent een AI-classificatiemodel. Je taak is om tekstfragmenten te classificeren in √©√©n van de exact opgegeven categorie√´n.
**Retourneer uitsluitend de exacte categorienaam. Absoluut GEEN andere tekst, uitleg, nummering of opmaak (zoals quotes, opsommingstekens, of inleidende zinnen).**
Gebruik de fallbackcategorie als geen enkele andere categorie duidelijk past.

Je krijgt informatie over een document. Kies exact √©√©n van de volgende categorie√´n:

<categories>
- {categoryListForPrompt}
- {DEFAULT_FALLBACK_CATEGORY} (gebruik deze als geen enkele andere categorie duidelijk past)
</categories>

Regels:
- Retourneer **ENKEL EN ALLEEN** √©√©n categorie uit bovenstaande lijst.
- **GEEN uitleg, GEEN nummering, GEEN opmaak, GEEN inleidende zinnen (zoals 'De categorie is:').**
- Als meerdere categorie√´n mogelijk zijn: kies de meest specifieke.
- Gebruik de fallbackcategorie alleen als echt niets past.
- Als het document geen leesbare inhoud heeft (<document_zonder_inhoud>), baseer je dan uitsluitend op de bestandsnaam en de context daarvan.

{fewShotExamples}

Documentinformatie:
<bestandsnaam>
{originalFilename}
</bestandsnaam>

{textContext}

Antwoord: "; // AANGEPAST: Maak de laatste promptregel consistenter met de voorbeelden

            string chosenCategory = null;

            try
            {
                chosenCategory = await aiProvider.GetTextCompletionAsync(
                    prompt,
                    modelName,
                    CATEGORY_MAX_TOKENS,
                    CATEGORY_TEMPERATURE,
                    cancellationToken
                );
            }
            catch (OperationCanceledException)
            {
                _logger.Log("INFO: Categorieclassificatie geannuleerd.");
                throw;
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Fout bij classificatie AI-aanroep: {ex.Message}");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            _logger.Log($"DEBUG: Ruwe AI-antwoord voor categorie: '{chosenCategory?.Replace("\n", "\\n")}'.");

            // GECORRIGEERD: Gebruik Regex.Replace voor case-insensitive vervanging
            if (!string.IsNullOrWhiteSpace(chosenCategory))
            {
                // Verwijder specifieke prefixes die de AI mogelijk nog toevoegt
                chosenCategory = Regex.Replace(chosenCategory, "Antwoord:", "", RegexOptions.IgnoreCase).Trim();
                chosenCategory = Regex.Replace(chosenCategory, "Categorie:", "", RegexOptions.IgnoreCase).Trim();
                // Verwijder eventuele quotes als de AI deze onverhoopt toevoegt
                chosenCategory = chosenCategory.Trim('\'', '\"');
            }


            if (string.IsNullOrWhiteSpace(chosenCategory))
            {
                _logger.Log("WAARSCHUWING: AI retourneerde geen bruikbare categorie (leeg of witruimte). Val terug op default.");
                return DEFAULT_FALLBACK_CATEGORY;
            }

            // `chosenCategory` is al getrimd door de bovenstaande opschoning, maar deze regel kan blijven voor consistentie.
            // chosenCategory = chosenCategory.Trim(); 

            if (validCategories.Contains(chosenCategory))
                return chosenCategory;

            // Verbeterde fuzzy matching: controleer op containment en gelijkenis
            foreach (var validCat in validCategories)
            {
                if (validCat.Equals(chosenCategory, StringComparison.OrdinalIgnoreCase) ||
                    validCat.ToLowerInvariant().Contains(chosenCategory.ToLowerInvariant()) ||
                    chosenCategory.ToLowerInvariant().Contains(validCat.ToLowerInvariant()))
                {
                    _logger.Log($"INFO: Gevonden categorie '{chosenCategory}' fuzzy-matched naar '{validCat}'.");
                    return validCat;
                }
            }

            _logger.Log($"WAARSCHUWING: AI-gekozen categorie '{chosenCategory}' is niet valide en kon niet fuzzy-matched worden. Val terug op default.");
            return DEFAULT_FALLBACK_CATEGORY;
        }


        /// <summary>
        /// Sugereert een submapnaam op basis van de inhoud van een document en de originele bestandsnaam.
        /// </summary>
        public async Task<string> SuggestSubfolderNameAsync(
            string textToAnalyze,
            string originalFilename,
            IAiProvider aiProvider,
            string modelName,
            CancellationToken cancellationToken)
        {
            if (aiProvider == null)
            {
                _logger.Log("FOUT: AI-provider is null voor submapnaam-suggestie.");
                return null;
            }

            if (string.IsNullOrWhiteSpace(modelName))
            {
                _logger.Log("FOUT: Modelnaam is leeg voor submapnaam-suggestie.");
                return null;
            }

            bool wasTextMeaningful;
            string aiInputText = GetRelevantTextForAI(textToAnalyze, originalFilename, 2000, out wasTextMeaningful); // Max 2000 chars

            // Pas de prompt aan op basis van de aanwezigheid van zinvolle tekst
            string textContext = wasTextMeaningful ?
                $@"<tekst_inhoud>
{aiInputText}
</tekst_inhoud>" :
                $@"<document_zonder_inhoud>
{aiInputText}
</document_zonder_inhoud>";


            var prompt = $@"
### SYSTEM INSTRUCTIE
Je bent een AI-assistent die helpt bij het organiseren van documenten in logische mappen. 
Je taak is om een **korte en beschrijvende submapnaam** te suggereren op basis van de documentinhoud of de bestandsnaam als fallback.

### INSTRUCTIES
- Gebruik maximaal **5 woorden**.
- Vat het hoofdonderwerp of doel van het document bondig samen.
- Vermijd generieke termen zoals 'document', 'info', 'bestand', 'overig' of alleen een datum.
- Gebruik bij voorkeur betekenisvolle termen zoals 'Belastingaangifte 2023' of 'CV Jan Jansen'.
- **GEEF ENKEL DE SUBMAPNAAM TERUG ‚Äì GEEN uitleg, GEEN opmaak, GEEN opsomming, GEEN quotes of padscheidingstekens, GEEN inleidende zinnen (zoals 'De submapnaam is:').**
- Als het document geen leesbare inhoud heeft (<document_zonder_inhoud>), focus dan op de originele bestandsnaam en de algemene beschrijving in dat blok.

### FEW-SHOT VOORBEELDEN
<voorbeeld>
Bestandsnaam: jaaropgave_2023_ing.pdf  
Tekst: Dit document betreft uw jaarlijkse jaaropgave voor belastingdoeleinden...  
Antwoord: Jaaropgave ING 2023
</voorbeeld>

<voorbeeld>
Bestandsnaam: cv_jan.docx  
Tekst: Curriculum Vitae van Jan Jansen met werkervaring in IT...  
Antwoord: CV Jan Jansen
</voorbeeld>

<voorbeeld>
Bestandsnaam: offerte_hypotheek_rabobank.pdf  
Tekst: Geachte heer, hierbij ontvangt u uw hypotheekofferte...  
Antwoord: Hypotheekofferte Rabobank
</voorbeeld>

<voorbeeld>
Bestandsnaam: huwelijksakte_piet_en_nel_2023.pdf
Tekst: Dit document heeft de bestandsnaam 'huwelijksakte_piet_en_nel_2023'. Er kon geen inhoud uit het document worden ge√´xtraheerd, of de inhoud was leeg. Analyseer alleen de bestandsnaam en probeer daaruit de essentie te halen.
Antwoord: Huwelijksakte Piet en Nel
</voorbeeld>

### INPUT
<bestandsnaam>
{originalFilename}
</bestandsnaam>

{textContext}

Antwoord: "; // AANGEPAST: Maak de laatste promptregel consistenter met de voorbeelden

            string suggestedName = null;

            try
            {
                suggestedName = await aiProvider.GetTextCompletionAsync(
                    prompt,
                    modelName,
                    SUBFOLDER_MAX_TOKENS,
                    SUBFOLDER_TEMPERATURE,
                    cancellationToken
                );
            }
            catch (OperationCanceledException)
            {
                _logger.Log($"INFO: Submapnaam AI-suggestie voor '{originalFilename}' geannuleerd.");
                throw;
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Fout bij submapnaam AI-aanroep voor '{originalFilename}': {ex.Message}");
                return null;
            }

            _logger.Log($"DEBUG: Ruwe AI-antwoord voor submapnaam: '{suggestedName?.Replace("\n", "\\n")}'.");

            // GECORRIGEERD: Gebruik Regex.Replace voor case-insensitive vervanging
            if (!string.IsNullOrWhiteSpace(suggestedName))
            {
                suggestedName = Regex.Replace(suggestedName, "Antwoord:", "", RegexOptions.IgnoreCase).Trim();
                suggestedName = suggestedName.Trim('\'', '\"');
            }

            string cleaned = FileUtils.SanitizeFolderOrFileName(suggestedName?.Trim() ?? "");
            var generiek = new[] { "document", "bestand", "info", "overig", "algemeen", "diversen", "" };

            // Controleer of de eerste AI-suggestie bruikbaar is.
            bool needsRetry = string.IsNullOrWhiteSpace(cleaned) || cleaned.Length < 3 || generiek.Contains(cleaned.ToLowerInvariant());

            if (needsRetry)
            {
                _logger.Log($"INFO: Eerste AI-suggestie '{suggestedName?.Trim() ?? "[LEEG]"}' voor '{originalFilename}' was onbruikbaar (leeg/te kort/generiek). Start retry...");

                // Sterkere retry prompt om de AI te dwingen een bruikbare naam te geven.
                var retryPrompt = prompt + "\n\nDe vorige suggestie was niet bruikbaar. Denk goed na en geef nu alsnog een CONCRETE, KORTE EN BESCHRIJVENDE mapnaam. De output moet DIRECT de naam zijn.";
                try
                {
                    suggestedName = await aiProvider.GetTextCompletionAsync(
                        retryPrompt,
                        modelName,
                        SUBFOLDER_MAX_TOKENS,
                        SUBFOLDER_TEMPERATURE,
                        cancellationToken
                    );

                    _logger.Log($"DEBUG: Ruwe AI-antwoord voor submapnaam (retry): '{suggestedName?.Replace("\n", "\\n")}'.");
                    // GECORRIGEERD: Opschoning na retry met Regex.Replace
                    if (!string.IsNullOrWhiteSpace(suggestedName))
                    {
                        suggestedName = Regex.Replace(suggestedName, "Antwoord:", "", RegexOptions.IgnoreCase).Trim();
                        suggestedName = suggestedName.Trim('\'', '\"');
                    }
                    cleaned = FileUtils.SanitizeFolderOrFileName(suggestedName?.Trim() ?? "");
                }
                catch (Exception ex)
                {
                    _logger.Log($"FOUT: Retry submapnaam faalde voor '{originalFilename}': {ex.Message}");
                }
            }

            // Finale validatie na (eventuele) retry
            if (string.IsNullOrWhiteSpace(cleaned) || cleaned.Length < 3 || generiek.Contains(cleaned.ToLowerInvariant()))
            {
                _logger.Log($"INFO: AI faalde voor '{originalFilename}' na retry of initieel. Probeer patroon-gebaseerde fallback...");

                cleaned = FileUtils.FallbackFolderNameFromFilename(originalFilename);

                if (string.IsNullOrWhiteSpace(cleaned))
                {
                    _logger.Log($"WAARSCHUWING: Geen bruikbare submapnaam gevonden voor '{originalFilename}'. Bestand blijft mogelijk in hoofdmap van de categorie.");
                    return null; // Geen bruikbare submapnaam, laat hoger niveau bepalen
                }
            }

            // Zet naar title case voor consistentie
            return CultureInfo.CurrentCulture.TextInfo.ToTitleCase(cleaned.ToLowerInvariant());
        }


        /// <summary>
        /// Sugereert een nieuwe bestandsnaam op basis van de inhoud van een document en de originele bestandsnaam.
        /// </summary>
        public async Task<string> SuggestFileNameAsync(
            string textToAnalyze,
            string originalFilename,
            IAiProvider aiProvider,
            string modelName,
            CancellationToken cancellationToken)
        {
            if (aiProvider == null)
            {
                _logger.Log("FOUT: AI-provider is null voor bestandsnaam-suggestie.");
                return Path.GetFileNameWithoutExtension(originalFilename); // Fallback gracefully
            }
            if (string.IsNullOrWhiteSpace(modelName))
            {
                _logger.Log("FOUT: Modelnaam is leeg voor bestandsnaam-suggestie.");
                return Path.GetFileNameWithoutExtension(originalFilename); // Fallback gracefully
            }

            bool wasTextMeaningful;
            string aiInputText = GetRelevantTextForAI(textToAnalyze, originalFilename, 2000, out wasTextMeaningful); // Max 2000 chars

            string textContext = wasTextMeaningful ?
                $@"<tekst_inhoud>
{aiInputText}
</tekst_inhoud>" :
                $@"<document_zonder_inhoud>
{aiInputText}
</document_zonder_inhoud>";


            var prompt = $@"
Je bent een AI-assistent die helpt bij het organiseren van bestanden.
Analyseer de volgende informatie over een document (oorspronkelijke bestandsnaam: ""{originalFilename}"") en stel een KORTE, BESCHRIJVENDE bestandsnaam voor (maximaal 10 woorden).
Deze bestandsnaam moet het hoofdonderwerp of de essentie van het document samenvatten, zonder de bestandsextensie.
Gebruik geen ongeldige karakters voor bestandsnamen.
Voorbeelden: ""Jaarverslag 2023 Hypotheekofferte Rabobank"", ""Notulen Project X"", ""CV Jan Jansen"".
Vermijd generieke namen zoals ""Document"", ""Bestand"", ""Info"", ""Factuur"" of simpelweg een datum zonder context.
**Geef ALLEEN de voorgestelde bestandsnaam terug, zonder extra uitleg of opmaak, en ZONDER quotes of extensie, en GEEN inleidende zinnen (zoals 'De bestandsnaam is:').**
Als het document geen leesbare inhoud heeft (<document_zonder_inhoud>), focus dan op de originele bestandsnaam en de algemene beschrijving in dat blok.

<bestandsnaam>
{originalFilename}
</bestandsnaam>

{textContext}

Antwoord: "; // AANGEPAST: Maak de laatste promptregel consistenter met de voorbeelden

            string suggestedName = null;
            try
            {
                suggestedName = await aiProvider.GetTextCompletionAsync(
                    prompt,
                    modelName,
                    FILENAME_MAX_TOKENS,
                    FILENAME_TEMPERATURE,
                    cancellationToken
                );
            }
            catch (OperationCanceledException)
            {
                _logger.Log($"INFO: Bestandsnaam AI-suggestie voor '{originalFilename}' geannuleerd.");
                throw; // Propagate cancellation
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Fout bij bestandsnaam AI-aanroep voor '{originalFilename}': {ex.Message}");
                return Path.GetFileNameWithoutExtension(originalFilename); // Fallback on error
            }

            _logger.Log($"DEBUG: Ruwe AI-antwoord voor bestandsnaam: '{suggestedName?.Replace("\n", "\\n")}'.");

            // GECORRIGEERD: Gebruik Regex.Replace voor case-insensitive vervanging
            if (!string.IsNullOrWhiteSpace(suggestedName))
            {
                suggestedName = Regex.Replace(suggestedName, "Antwoord:", "", RegexOptions.IgnoreCase).Trim();
                suggestedName = suggestedName.Trim('\'', '\"');
            }


            if (string.IsNullOrWhiteSpace(suggestedName))
            {
                _logger.Log($"WAARSCHUWING: AI retourneerde geen bruikbare bestandsnaam (leeg of witruimte) voor '{originalFilename}'. Gebruik originele naam.");
                return Path.GetFileNameWithoutExtension(originalFilename);
            }

            string cleanedName = FileUtils.SanitizeFolderOrFileName(suggestedName?.Trim() ?? "");

            var genericNames = new[] { "document", "bestand", "info", "overig", "algemeen", "factuur", "" };
            if (cleanedName.Length < 3 || genericNames.Contains(cleanedName.ToLowerInvariant()))
            {
                _logger.Log($"WAARSCHUWING: AI-suggestie '{suggestedName?.Trim() ?? "[LEEG]"}' voor '{originalFilename}' is te kort of te generiek na opschonen. Gebruik originele naam.");
                return Path.GetFileNameWithoutExtension(originalFilename);
            }

            // Apply max length constraint
            if (cleanedName.Length > 100) // Hardcoded max length for filenames, adjust as needed
            {
                cleanedName = cleanedName.Substring(0, 100);
                _logger.Log($"INFO: AI-gegenereerde bestandsnaam voor '{originalFilename}' afgekort naar '{cleanedName}' wegens lengtebeperking.");
            }

            return cleanedName;
        }
    }
}


================================================
FILE: Services/AzureOpenAiProvider.cs
================================================
Ôªø// AI_FileOrganizer/Services/AzureOpenAiProvider.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.AI.OpenAI;
using Azure.AI.OpenAI.Chat;
using OpenAI.Chat;

namespace AI_FileOrganizer.Services
{
    public class AzureOpenAiProvider : IAiProvider
    {
        private readonly Uri _azureEndpoint;
        private readonly string _apiKey;

        public AzureOpenAiProvider(string azureEndpoint, string apiKey)
        {
            if (string.IsNullOrWhiteSpace(azureEndpoint) || !Uri.TryCreate(azureEndpoint, UriKind.Absolute, out _azureEndpoint))
                throw new ArgumentException("Ongeldig Azure Endpoint URL.", nameof(azureEndpoint));

            if (string.IsNullOrWhiteSpace(apiKey))
                throw new ArgumentException("API key voor Azure OpenAI mag niet leeg zijn.", nameof(apiKey));

            _apiKey = apiKey;
        }

        public async Task<string> GetTextCompletionAsync(string prompt, string modelName, int maxTokens, float temperature, CancellationToken cancellationToken)
        {
            // === Validatie ===
            if (string.IsNullOrWhiteSpace(prompt))
                throw new ArgumentException("De prompt mag niet leeg zijn.", nameof(prompt));
            if (string.IsNullOrWhiteSpace(modelName))
                throw new ArgumentException("Modelnaam mag niet leeg zijn.", nameof(modelName));
            if (maxTokens <= 0 || maxTokens > 4096)
                throw new ArgumentOutOfRangeException(nameof(maxTokens), "maxTokens moet tussen 1 en 4096 zijn.");
            if (temperature < 0 || temperature > 1)
                throw new ArgumentOutOfRangeException(nameof(temperature), "temperature moet tussen 0.0 en 1.0 zijn.");

            try
            {
                var azureClient = new AzureOpenAIClient(_azureEndpoint, new AzureKeyCredential(_apiKey));
                var chatClient = azureClient.GetChatClient(modelName);

                var messages = new List<ChatMessage>
                {
                    new UserChatMessage(prompt)
                };

                var chatCompletionOptions = new ChatCompletionOptions
                {
                    Temperature = temperature,
                    MaxOutputTokenCount = maxTokens
                };

                var completion = await chatClient.CompleteChatAsync(messages, chatCompletionOptions, cancellationToken);

                var firstContent = completion.Value.Content.FirstOrDefault();
                if (firstContent != null && !string.IsNullOrWhiteSpace(firstContent.Text))
                    return firstContent.Text.Trim();

                return null;
            }
            catch (OperationCanceledException)
            {
                throw;
            }
            catch (RequestFailedException ex)
            {
                Console.WriteLine($"[AzureOpenAiProvider] Azure API-fout: {ex.Message}");
                return null;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[AzureOpenAiProvider] Algemene fout: {ex.Message}");
                return null;
            }
        }
    }
}



================================================
FILE: Services/CredentialStorageService.cs
================================================
Ôªø// AI_FileOrganizer/Services/CredentialStorageService.cs
using System;
using CredentialManagement; // Vereist de CredentialManagement NuGet-package
using AI_FileOrganizer.Utils; // Voor ILogger
using Newtonsoft.Json; // Voor het serialiseren van Azure-gegevens

namespace AI_FileOrganizer.Services
{
    public class CredentialStorageService
    {
        private readonly ILogger _logger;
        private const string AppPrefix = "AIFileOrganizer."; // Unieke prefix voor onze referenties

        public CredentialStorageService(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        /// <summary>
        /// Slaat een API-sleutel en optioneel een Azure Endpoint op in de Windows Credential Manager.
        /// De sleutel wordt opgeslagen als een credential voor de lokale gebruiker.
        /// </summary>
        /// <param name="providerName">De naam van de provider (bijv. "Gemini (Google)", "Azure OpenAI").</param>
        /// <param name="apiKey">De API-sleutel.</param>
        /// <param name="azureEndpoint">Optioneel: Het Azure Endpoint voor Azure OpenAI.</param>
        public void SaveApiKey(string providerName, string apiKey, string azureEndpoint = null)
        {
            if (string.IsNullOrWhiteSpace(providerName))
            {
                _logger.Log("FOUT bij opslaan API-sleutel: Providernaam is leeg.");
                return;
            }
            if (string.IsNullOrWhiteSpace(apiKey))
            {
                _logger.Log($"WAARSCHUWING bij opslaan API-sleutel voor '{providerName}': API-sleutel is leeg. Verwijder bestaande.");
                DeleteApiKey(providerName); // Verwijder indien de sleutel wordt gewist
                return;
            }

            try
            {
                using (var credential = new Credential())
                {
                    credential.Target = GetCredentialTarget(providerName);
                    credential.Username = providerName; // Username kan de provider naam zijn, of leeg

                    if (!string.IsNullOrWhiteSpace(azureEndpoint))
                    {
                        // Voor Azure, combineer sleutel en endpoint in een JSON-string in het wachtwoordveld
                        var azureConfig = new { ApiKey = apiKey, Endpoint = azureEndpoint };
                        credential.Password = JsonConvert.SerializeObject(azureConfig);
                        credential.Type = CredentialType.Generic;
                    }
                    else
                    {
                        credential.Password = apiKey;
                        credential.Type = CredentialType.Generic; // Kan ook NetworkPassword zijn, maar Generic is flexibeler
                    }

                    credential.PersistanceType = PersistanceType.LocalComputer; // Alleen voor de huidige gebruiker

                    credential.Save(); // Slaat de referentie op
                    _logger.Log($"INFO: API-sleutel voor '{providerName}' succesvol opgeslagen.");
                }
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT bij opslaan API-sleutel voor '{providerName}': {ex.Message}");
            }
        }

        /// <summary>
        /// Haalt een API-sleutel en optioneel Azure Endpoint op uit de Windows Credential Manager.
        /// </summary>
        /// <param name="providerName">De naam van de provider.</param>
        /// <returns>Een tuple (APIKey, AzureEndpoint), of (null, null) indien niet gevonden of fout.</returns>
        public (string ApiKey, string AzureEndpoint) GetApiKey(string providerName)
        {
            if (string.IsNullOrWhiteSpace(providerName))
            {
                _logger.Log("FOUT bij ophalen API-sleutel: Providernaam is leeg.");
                return (null, null);
            }

            try
            {
                using (var credential = new Credential())
                {
                    credential.Target = GetCredentialTarget(providerName);
                    credential.Load(); // Laadt de referentie

                    if (credential.Type == CredentialType.Generic && credential.Password.StartsWith("{") && credential.Password.Contains("ApiKey"))
                    {
                        // Dit is waarschijnlijk een Azure-configuratie (JSON)
                        var azureConfig = JsonConvert.DeserializeAnonymousType(credential.Password, new { ApiKey = "", Endpoint = "" });
                        _logger.Log($"INFO: Azure-configuratie voor '{providerName}' succesvol geladen.");
                        return (azureConfig.ApiKey, azureConfig.Endpoint);
                    }
                    else
                    {
                        _logger.Log($"INFO: API-sleutel voor '{providerName}' succesvol geladen.");
                        return (credential.Password, null); // Retourneer alleen de sleutel
                    }
                }
            }

            catch (Exception ex)
            {
                _logger.Log($"FOUT bij ophalen API-sleutel voor '{providerName}': {ex.Message}");
                return (null, null);
            }
        }

        /// <summary>
        /// Verwijdert een opgeslagen API-sleutel uit de Windows Credential Manager.
        /// </summary>
        /// <param name="providerName">De naam van de provider.</param>
        public void DeleteApiKey(string providerName)
        {
            if (string.IsNullOrWhiteSpace(providerName)) return;

            try
            {
                using (var credential = new Credential())
                {
                    credential.Target = GetCredentialTarget(providerName);
                    credential.Delete(); // Verwijdert de referentie
                    _logger.Log($"INFO: API-sleutel voor '{providerName}' succesvol verwijderd.");
                }
            }
          //  catch (Exception ex)
        //    {
                // Al niet aanwezig, dat is prima
           //     _logger.Log($"INFO: API-sleutel voor '{providerName}' was niet aanwezig om te verwijderen.");
       //     }
            catch (Exception ex)
            {
                _logger.Log($"FOUT bij verwijderen API-sleutel voor '{providerName}': {ex.Message}");
            }
        }

        private string GetCredentialTarget(string providerName)
        {
            return AppPrefix + providerName.Replace(" ", "").Replace("(", "").Replace(")", "").Replace(".", ""); // Maak een veilige target naam
        }
    }
}


================================================
FILE: Services/DocxTextExtractor.cs
================================================
Ôªø// AI_FileOrganizer/Services/DocxTextExtractor.cs
using System;
using System.IO;
using System.Linq;
using DocumentFormat.OpenXml.Packaging;
using DocumentFormat.OpenXml.Wordprocessing;
using DocumentFormat.OpenXml; // Voor OpenXmlPackageException
using AI_FileOrganizer.Utils; // Voor ILogger

namespace AI_FileOrganizer.Services
{
    public class DocxTextExtractor : ITextExtractor
    {
        private readonly ILogger _logger;

        public DocxTextExtractor(ILogger logger)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
        }

        public bool CanExtract(string filePath)
        {
            return Path.GetExtension(filePath).Equals(".docx", StringComparison.OrdinalIgnoreCase);
        }

        public string Extract(string filePath)
        {
            try
            {
                if (!File.Exists(filePath))
                {
                    _logger.Log($"WAARSCHUWING: Bestand niet gevonden voor DOCX-extractie: '{Path.GetFileName(filePath)}'.");
                    return string.Empty;
                }

                using (WordprocessingDocument wordDoc = WordprocessingDocument.Open(filePath, false)) // Openen in read-only modus
                {
                    Body body = wordDoc.MainDocumentPart?.Document?.Body;
                    if (body != null)
                    {
                        // Gebruik Environment.NewLine voor consistentie en trim elke paragraaf
                        return string.Join(Environment.NewLine, body.Elements<Paragraph>().Select(p => p.InnerText.Trim())).Trim();
                    }
                }
            }
            catch (OpenXmlPackageException oxmlEx)
            {
                _logger.Log($"FOUT: Beschadigd DOCX-bestand '{Path.GetFileName(filePath)}' bij extractie: {oxmlEx.Message}");
                return string.Empty;
            }
            catch (UnauthorizedAccessException uaEx)
            {
                _logger.Log($"FOUT: Toegang geweigerd tot DOCX-bestand '{Path.GetFileName(filePath)}': {uaEx.Message}");
                return string.Empty;
            }
            catch (IOException ioEx) when ((ioEx.HResult & 0xFFFF) == 32) // ERROR_SHARING_VIOLATION
            {
                _logger.Log($"WAARSCHUWING: Bestand '{Path.GetFileName(filePath)}' is vergrendeld en kan niet worden gelezen voor DOCX-extractie.");
                return string.Empty;
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Onbekende fout bij DOCX-extractie van '{Path.GetFileName(filePath)}': {ex.Message}");
                return string.Empty;
            }
            return string.Empty; // In geval van een onverwachte codepad zonder return
        }
    }
}


================================================
FILE: Services/FileOrganizerService.cs
================================================
Ôªøusing AI_FileOrganizer.Models; // For ApplicationSettings
using AI_FileOrganizer.Utils;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms; // Needed for DialogResult

namespace AI_FileOrganizer.Services
{
    public class FileOrganizerService
    {
        private readonly ILogger _logger;
        private readonly AiClassificationService _aiService;
        private readonly TextExtractionService _textExtractionService;
        private readonly CredentialStorageService _credentialStorageService;
        private readonly HttpClient _httpClient; // Shared HttpClient for AI providers

        // Events for UI updates
        public event Action<int, int> ProgressChanged; // (currentFileIndex, totalFiles)
        public event Action<long> TokensUsedUpdated; // (totalTokensUsed)
        // Callback for interactive rename. Returns (DialogResult, newFileName, skipFile)
        public event Func<string, string, Task<(DialogResult result, string newFileName, bool skipFile)>> RequestRenameFile;

        // Note: _totalTokensUsed tracking needs to be properly implemented within IAiProvider for accurate reporting.
        // For now, it's a placeholder.
        private long _totalTokensUsed = 0;

        public FileOrganizerService(
            ILogger logger,
            AiClassificationService aiService,
            TextExtractionService textExtractionService,
            CredentialStorageService credentialStorageService,
            HttpClient httpClient)
        {
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            _aiService = aiService ?? throw new ArgumentNullException(nameof(aiService));
            _textExtractionService = textExtractionService ?? throw new ArgumentNullException(nameof(textExtractionService));
            _credentialStorageService = credentialStorageService ?? throw new ArgumentNullException(nameof(credentialStorageService));
            _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
        }

        /// <summary>
        /// Orchestrates the main file organization process.
        /// </summary>
        public async Task OrganizeFilesAsync(string sourcePath, string destinationBasePath, string apiKey, string providerName, string modelName, string azureEndpoint, bool shouldRenameFiles, CancellationToken cancellationToken)
        {
            _totalTokensUsed = 0; // Reset token counter for each new run
            TokensUsedUpdated?.Invoke(_totalTokensUsed);

            IAiProvider currentAiProvider = GetAiProvider(apiKey, providerName, azureEndpoint);
            if (currentAiProvider == null) return; // Error already logged by GetAiProvider

            // Save API key using the credential storage service
            _credentialStorageService.SaveApiKey(providerName, apiKey, azureEndpoint);

            // Ensure destination base path exists
            if (!Directory.Exists(destinationBasePath))
            {
                try
                {
                    Directory.CreateDirectory(destinationBasePath);
                    _logger.Log($"[MAP] Basisdoelmap '{destinationBasePath}' aangemaakt.");
                }
                catch (Exception ex)
                {
                    _logger.Log($"FOUT: Fout bij aanmaken basisdoelmap '{destinationBasePath}': {ex.Message}");
                    return;
                }
            }

            var allFiles = Directory.EnumerateFiles(sourcePath, "*", SearchOption.AllDirectories)
                                    .Where(f => ApplicationSettings.SupportedExtensions.Contains(Path.GetExtension(f).ToLower()))
                                    .ToList();

            int processedCount = 0;
            int movedFiles = 0;
            int filesWithSubfolders = 0;
            int renamedFiles = 0;

            ProgressChanged?.Invoke(0, allFiles.Count);

            foreach (string filePath in allFiles)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    cancellationToken.ThrowIfCancellationRequested(); // Propagate cancellation
                }

                var fileInfo = new FileInfo(filePath);
                processedCount++;
                _logger.Log($"\n[BESTAND] Verwerken van: {fileInfo.Name} (locatie: {Path.GetDirectoryName(filePath)})");

                try
                {
                    var (processed, moved, hadSubfolder, renamed) = await ProcessAndMoveSingleFileInternalAsync(
                        filePath,
                        fileInfo,
                        sourcePath,
                        destinationBasePath,
                        currentAiProvider,
                        modelName,
                        shouldRenameFiles,
                        cancellationToken);

                    if (processed)
                    {
                        if (moved) movedFiles++;
                        if (hadSubfolder) filesWithSubfolders++;
                        if (renamed) renamedFiles++;
                    }
                }
                catch (OperationCanceledException)
                {
                    throw; // Important: rethrow to be caught by Form1's main try-catch
                }
                catch (Exception ex)
                {
                    _logger.Log($"FOUT: Fout bij verwerken van {fileInfo.Name}: {ex.Message}");
                }
                finally
                {
                    ProgressChanged?.Invoke(processedCount, allFiles.Count);
                }
            }

            _logger.Log($"\nTotaal aantal bestanden bekeken (met ondersteunde extensie): {processedCount}");
            _logger.Log($"Aantal bestanden succesvol verplaatst: {movedFiles}");
            _logger.Log($"Aantal bestanden geplaatst in een AI-gegenereerde submap: {filesWithSubfolders}");
            _logger.Log($"Aantal bestanden hernoemd: {renamedFiles}");
        }

        /// <summary>
        /// Handles interactive renaming of a single selected file.
        /// </summary>
        public async Task RenameSingleFileInteractiveAsync(string filePath, string apiKey, string providerName, string modelName, string azureEndpoint, CancellationToken cancellationToken)
        {
            _totalTokensUsed = 0; // Reset tokens for single operation
            TokensUsedUpdated?.Invoke(_totalTokensUsed);

            IAiProvider currentAiProvider = GetAiProvider(apiKey, providerName, azureEndpoint);
            if (currentAiProvider == null) return; // Error already logged

            _credentialStorageService.SaveApiKey(providerName, apiKey, azureEndpoint);

            if (!File.Exists(filePath))
            {
                _logger.Log($"FOUT: Bestand niet gevonden voor hernoemen: '{Path.GetFileName(filePath)}'.");
                return;
            }

            FileInfo fileInfo = new FileInfo(filePath);
            _logger.Log($"\n[BESTAND] Voorbereiden van hernoemen voor: {fileInfo.Name}");

            try
            {
                string extractedText = _textExtractionService.ExtractText(filePath);
                _logger.Log($"Extractedtext: '{extractedText}'...");
                if (string.IsNullOrWhiteSpace(extractedText))
                {
                    _logger.Log($"INFO: Geen zinvolle tekst ge√´xtraheerd uit {fileInfo.Name}. Gebruik bestandsnaam als context.");
                    extractedText = fileInfo.Name;
                }
                if (extractedText.Length > ApplicationSettings.MaxTextLengthForLlm)
                {
                    _logger.Log($"WAARSCHUWING: Tekstlengte voor '{fileInfo.Name}' overschrijdt {ApplicationSettings.MaxTextLengthForLlm} tekens. Tekst wordt afgekapt.");
                    extractedText = extractedText.Substring(0, ApplicationSettings.MaxTextLengthForLlm);
                }

                _logger.Log($"INFO: AI-bestandsnaam genereren voor '{fileInfo.Name}'...");
                string suggestedNewBaseName = await _aiService.SuggestFileNameAsync(
                    extractedText,
                    fileInfo.Name,
                    currentAiProvider,
                    modelName,
                    cancellationToken
                );

                // Request UI interaction for rename
                if (RequestRenameFile == null)
                {
                    _logger.Log("FOUT: UI callback voor hernoemen is niet ingesteld. Kan bestand niet interactief hernoemen.");
                    return;
                }

                var (dialogResult, returnedFileName, skipFile) = await RequestRenameFile.Invoke(fileInfo.Name, suggestedNewBaseName + fileInfo.Extension);

                if (dialogResult == DialogResult.OK)
                {
                    if (skipFile)
                    {
                        _logger.Log($"INFO: Gebruiker koos om '{fileInfo.Name}' niet te hernoemen. Geen actie ondernomen.");
                    }
                    else
                    {
                        string proposedFullName = returnedFileName;
                        string proposedBaseName = Path.GetFileNameWithoutExtension(proposedFullName);
                        string proposedExtension = Path.GetExtension(proposedFullName);

                        if (string.IsNullOrEmpty(proposedExtension))
                        {
                            proposedFullName = proposedBaseName + fileInfo.Extension;
                        }
                        else if (proposedExtension.ToLower() != fileInfo.Extension.ToLower())
                        {
                            _logger.Log($"WAARSCHUWING: Bestandsnaam '{proposedFullName}' heeft afwijkende extensie. Originele extensie '{fileInfo.Extension}' behouden.");
                            proposedFullName = proposedBaseName + fileInfo.Extension;
                        }

                        string newFileName = FileUtils.SanitizeFileName(proposedFullName);

                        string baseNameWithoutExt = Path.GetFileNameWithoutExtension(newFileName);
                        string extension = Path.GetExtension(newFileName);
                        if (baseNameWithoutExt.Length > ApplicationSettings.MaxFilenameLength)
                        {
                            baseNameWithoutExt = baseNameWithoutExt.Substring(0, ApplicationSettings.MaxFilenameLength);
                            newFileName = baseNameWithoutExt + extension;
                            _logger.Log($"WAARSCHUWING: Nieuwe bestandsnaam te lang. Afgekapt naar '{newFileName}'.");
                        }

                        if (newFileName != fileInfo.Name)
                        {
                            string destinationFilePath = Path.Combine(Path.GetDirectoryName(filePath), newFileName);

                            if (File.Exists(destinationFilePath))
                            {
                                string baseNameConflict = Path.GetFileNameWithoutExtension(newFileName);
                                string extensionConflict = Path.GetExtension(newFileName);
                                int counter = 1;
                                string uniqueDestinationFilePath = destinationFilePath;
                                while (File.Exists(uniqueDestinationFilePath))
                                {
                                    uniqueDestinationFilePath = Path.Combine(Path.GetDirectoryName(filePath), $"{baseNameConflict}_{counter}{extensionConflict}");
                                    counter++;
                                }
                                _logger.Log($"INFO: Bestand '{newFileName}' bestaat al. Hernoemd naar '{Path.GetFileName(uniqueDestinationFilePath)}' om conflict te voorkomen.");
                                destinationFilePath = uniqueDestinationFilePath;
                            }

                            File.Move(filePath, destinationFilePath);
                            _logger.Log($"OK: '{fileInfo.Name}' hernoemd naar '{Path.GetFileName(destinationFilePath)}'.");
                        }
                        else
                        {
                            _logger.Log($"INFO: AI-suggestie was gelijk aan origineel of ongeldig na opschonen. '{fileInfo.Name}' niet hernoemd.");
                        }
                    }
                }
                else
                {
                    _logger.Log($"INFO: Hernoem-actie voor '{fileInfo.Name}' geannuleerd door gebruiker. Geen actie ondernomen.");
                }
            }
            catch (OperationCanceledException)
            {
                _logger.Log("Hernoem-actie geannuleerd.");
                throw; // Propagate cancellation
            }
            catch (Exception ex)
            {
                _logger.Log($"FOUT: Fout bij hernoemen van {fileInfo.Name}: {ex.Message}");
            }
            finally
            {
                _logger.Log("\nEnkel bestand hernoemen voltooid.");
            }
        }


        /// <summary>
        /// Helper method to process a single file: extract, classify, suggest subfolder/filename, and move.
        /// Returns (wasProcessed, wasMoved, hadSubfolder, wasRenamed)
        /// </summary>
        private async Task<(bool processed, bool moved, bool hadSubfolder, bool renamed)> ProcessAndMoveSingleFileInternalAsync(
            string filePath,
            FileInfo fileInfo,
            string sourcePath,
            string destinationBasePath,
            IAiProvider currentAiProvider,
            string modelName,
            bool shouldRenameFiles,
            CancellationToken cancellationToken)
        {
            string extractedText = _textExtractionService.ExtractText(filePath);

            if (string.IsNullOrWhiteSpace(extractedText))
            {
                _logger.Log($"INFO: Geen zinvolle tekst ge√´xtraheerd uit {fileInfo.Name}. Bestand wordt behandeld met bestandsnaam context (als fallback).");
                extractedText = fileInfo.Name; // Use filename as minimal context
            }

            if (extractedText.Length > ApplicationSettings.MaxTextLengthForLlm)
            {
                _logger.Log($"WAARSCHUWING: Tekstlengte voor '{fileInfo.Name}' overschrijdt {ApplicationSettings.MaxTextLengthForLlm} tekens. Tekst wordt afgekapt.");
                extractedText = extractedText.Substring(0, ApplicationSettings.MaxTextLengthForLlm);
            }

            string llmCategoryChoice = await _aiService.ClassifyCategoryAsync(
                extractedText,
                filePath,
                ApplicationSettings.FolderCategories.Keys.ToList(),
                currentAiProvider,
                modelName,
                cancellationToken
            );

            if (string.IsNullOrWhiteSpace(llmCategoryChoice))
            {
                _logger.Log($"WAARSCHUWING: Kon '{fileInfo.Name}' niet classificeren met AI (retourneerde leeg of None). Bestand wordt niet verplaatst.");
                return (false, false, false, false);
            }

            string targetCategoryFolderName = ApplicationSettings.FolderCategories.ContainsKey(llmCategoryChoice)
                ? ApplicationSettings.FolderCategories[llmCategoryChoice]
                : ApplicationSettings.FallbackFolderName;
            string targetCategoryFolderPath = Path.Combine(destinationBasePath, targetCategoryFolderName);
            Directory.CreateDirectory(targetCategoryFolderPath); // Ensure the category folder exists

            string aiSuggestedSubfolderName = null;
            bool hadSubfolder = false;

            _logger.Log($"INFO: Poging tot genereren submapnaam voor '{fileInfo.Name}'...");
            string subfolderNameSuggestion = await _aiService.SuggestSubfolderNameAsync(
                extractedText,
                fileInfo.Name,
                currentAiProvider,
                modelName,
                cancellationToken
            );

            if (!string.IsNullOrWhiteSpace(subfolderNameSuggestion))
            {
                subfolderNameSuggestion = FileUtils.SanitizeFolderOrFileName(subfolderNameSuggestion);
                if (subfolderNameSuggestion.Length < ApplicationSettings.MinSubfolderNameLength || subfolderNameSuggestion.Length > ApplicationSettings.MaxSubfolderNameLength)
                {
                    _logger.Log($"WAARSCHUWING: AI-gegenereerde submapnaam '{subfolderNameSuggestion}' is ongeldig (lengte). Wordt niet gebruikt.");
                    subfolderNameSuggestion = null; // Set to null if invalid to trigger fallback
                }
            }

            if (!string.IsNullOrWhiteSpace(subfolderNameSuggestion))
            {
                aiSuggestedSubfolderName = subfolderNameSuggestion; // Store the validated AI-suggested name
                _logger.Log($"INFO: AI suggereerde submap: '{aiSuggestedSubfolderName}'");
                hadSubfolder = true;
            }
            else
            {
                _logger.Log($"INFO: Geen geschikte submapnaam gegenereerd. Bestand komt direct in categorie '{targetCategoryFolderName}' of in originele submap structuur.");
            }

            string finalTargetDirectory;

            // AANGEPAST: Bepaal het uiteindelijke doelpad
            if (hadSubfolder)
            {
                // Als er een AI-gesuggereerde submap is, plaats het bestand DIRECT daarin.
                finalTargetDirectory = Path.Combine(targetCategoryFolderPath, aiSuggestedSubfolderName);
            }
            else
            {
                // Als er GEEN AI-gesuggereerde submap is, behoud dan de originele relatieve mapstructuur onder de categorie.
                string relativePathFromSource = FileUtils.GetRelativePath(sourcePath, Path.GetDirectoryName(filePath));
                finalTargetDirectory = Path.Combine(targetCategoryFolderPath, relativePathFromSource);
            }
            Directory.CreateDirectory(finalTargetDirectory); // Ensure the full target directory structure exists


            string newFileName = fileInfo.Name;
            bool wasRenamed = false;

            if (shouldRenameFiles)
            {
                _logger.Log($"INFO: AI-bestandsnaam genereren voor '{fileInfo.Name}'...");
                string suggestedNewBaseName = await _aiService.SuggestFileNameAsync(
                    extractedText,
                    fileInfo.Name,
                    currentAiProvider,
                    modelName,
                    cancellationToken
                );

                if (RequestRenameFile == null)
                {
                    _logger.Log("WAARSCHUWING: UI callback voor hernoemen is niet ingesteld. Kan bestand niet interactief hernoemen. Gebruik AI suggestie direct.");
                    newFileName = FileUtils.SanitizeFileName(suggestedNewBaseName + fileInfo.Extension);
                    string baseNameWithoutExt = Path.GetFileNameWithoutExtension(newFileName);
                    string extension = Path.GetExtension(newFileName);
                    if (baseNameWithoutExt.Length > ApplicationSettings.MaxFilenameLength)
                    {
                        baseNameWithoutExt = baseNameWithoutExt.Substring(0, ApplicationSettings.MaxFilenameLength);
                        newFileName = baseNameWithoutExt + extension;
                        _logger.Log($"WAARSCHUWING: Nieuwe bestandsnaam te lang. Afgekapt naar '{newFileName}'.");
                    }
                    if (newFileName != fileInfo.Name) wasRenamed = true;
                }
                else
                {
                    // Call the UI callback to show the rename form
                    var (dialogResult, returnedFileName, skipFile) = await RequestRenameFile.Invoke(fileInfo.Name, suggestedNewBaseName + fileInfo.Extension);

                    if (dialogResult == DialogResult.OK)
                    {
                        if (skipFile)
                        {
                            _logger.Log($"INFO: Gebruiker koos om '{fileInfo.Name}' niet te hernoemen. Bestand wordt verplaatst met originele naam.");
                            // newFileName remains the original name
                        }
                        else
                        {
                            string proposedFullName = returnedFileName;
                            string proposedBaseName = Path.GetFileNameWithoutExtension(proposedFullName);
                            string proposedExtension = Path.GetExtension(proposedFullName);

                            // Ensure extension is preserved or handled correctly
                            if (string.IsNullOrEmpty(proposedExtension))
                            {
                                proposedFullName = proposedBaseName + fileInfo.Extension;
                            }
                            else if (proposedExtension.ToLower() != fileInfo.Extension.ToLower())
                            {
                                _logger.Log($"WAARSCHUWING: Bestandsnaam '{proposedFullName}' heeft afwijkende extensie. Originele extensie '{fileInfo.Extension}' wordt behouden.");
                                proposedFullName = proposedBaseName + fileInfo.Extension; // Force original extension
                            }

                            newFileName = FileUtils.SanitizeFileName(proposedFullName); // Sanitize the confirmed new name

                            // Apply max length constraint
                            string baseNameWithoutExt = Path.GetFileNameWithoutExtension(newFileName);
                            string extension = Path.GetExtension(newFileName);
                            if (baseNameWithoutExt.Length > ApplicationSettings.MaxFilenameLength)
                            {
                                baseNameWithoutExt = baseNameWithoutExt.Substring(0, ApplicationSettings.MaxFilenameLength);
                                newFileName = baseNameWithoutExt + extension;
                                _logger.Log($"WAARSCHUWING: Nieuwe bestandsnaam te lang. Afgekapt naar '{newFileName}'.");
                            }

                            if (newFileName != fileInfo.Name)
                            {
                                _logger.Log($"INFO: '{fileInfo.Name}' wordt hernoemd naar '{newFileName}'.");
                                wasRenamed = true;
                            }
                            else
                            {
                                _logger.Log($"INFO: AI-suggestie voor '{fileInfo.Name}' was gelijk aan origineel of ongeldig na opschonen, niet hernoemd.");
                            }
                        }
                    }
                    else
                    {
                        // User cancelled the rename dialog, means skip this file for now
                        _logger.Log($"INFO: Hernoem-actie voor '{fileInfo.Name}' geannuleerd door gebruiker. Bestand wordt overgeslagen.");
                        return (false, false, false, false); // Return false for processed, so it's not counted as moved/renamed
                    }
                }
            }

            string destinationFilePath = Path.Combine(finalTargetDirectory, newFileName);

            // Handle existing file names in target directory
            if (File.Exists(destinationFilePath))
            {
                string baseName = Path.GetFileNameWithoutExtension(newFileName);
                string extension = Path.GetExtension(newFileName);
                int counter = 1;
                string uniqueDestinationFilePath = destinationFilePath;
                while (File.Exists(uniqueDestinationFilePath))
                {
                    uniqueDestinationFilePath = Path.Combine(finalTargetDirectory, $"{baseName}_{counter}{extension}");
                    counter++;
                }
                _logger.Log($"INFO: Bestand '{newFileName}' bestaat al op doel. Hernoemd naar '{Path.GetFileName(uniqueDestinationFilePath)}' om conflict te voorkomen.");
                destinationFilePath = uniqueDestinationFilePath;
            }

            File.Move(filePath, destinationFilePath);

            _logger.Log($"OK: '{fileInfo.Name}' verplaatst naar '{FileUtils.GetRelativePath(destinationBasePath, destinationFilePath)}'");
            return (true, true, hadSubfolder, wasRenamed);
        }

        /// <summary>
        /// Factory method to get the correct AI provider based on selection.
        /// </summary>
        private IAiProvider GetAiProvider(string apiKey, string providerName, string azureEndpoint)
        {
            try
            {
                switch (providerName)
                {
                    case "Gemini (Google)":
                        return new GeminiAiProvider(apiKey, _httpClient);
                    case "OpenAI (openai.com)":
                        return new OpenAiProvider(apiKey);
                    case "Azure OpenAI":
                        return new AzureOpenAiProvider(azureEndpoint, apiKey);
                    default:
                        _logger.Log($"FOUT: Onbekende AI-provider geselect